
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyStatusMessage
 * 
 */
export type CompanyStatusMessage = $Result.DefaultSelection<Prisma.$CompanyStatusMessagePayload>
/**
 * Model Director
 * 
 */
export type Director = $Result.DefaultSelection<Prisma.$DirectorPayload>
/**
 * Model Shareholder
 * 
 */
export type Shareholder = $Result.DefaultSelection<Prisma.$ShareholderPayload>
/**
 * Model CompanyDocument
 * 
 */
export type CompanyDocument = $Result.DefaultSelection<Prisma.$CompanyDocumentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model CompanyService
 * 
 */
export type CompanyService = $Result.DefaultSelection<Prisma.$CompanyServicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model InsightRecommendation
 * 
 */
export type InsightRecommendation = $Result.DefaultSelection<Prisma.$InsightRecommendationPayload>
/**
 * Model CalendarAction
 * 
 */
export type CalendarAction = $Result.DefaultSelection<Prisma.$CalendarActionPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model DashboardState
 * 
 */
export type DashboardState = $Result.DefaultSelection<Prisma.$DashboardStatePayload>
/**
 * Model RoleAssignment
 * 
 */
export type RoleAssignment = $Result.DefaultSelection<Prisma.$RoleAssignmentPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model ContactUs
 * 
 */
export type ContactUs = $Result.DefaultSelection<Prisma.$ContactUsPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model StagingCompany
 * 
 */
export type StagingCompany = $Result.DefaultSelection<Prisma.$StagingCompanyPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model RegisteredCompanyName
 * 
 */
export type RegisteredCompanyName = $Result.DefaultSelection<Prisma.$RegisteredCompanyNamePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Admin: 'Admin',
  preparer: 'preparer',
  approver: 'approver',
  client: 'client'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DocumentPurpose: {
  MOA: 'MOA',
  AOA: 'AOA',
  ID_PROOF: 'ID_PROOF',
  ADDRESS_PROOF: 'ADDRESS_PROOF',
  BOARD_RESOLUTION: 'BOARD_RESOLUTION',
  INVOICE: 'INVOICE',
  OTHER: 'OTHER'
};

export type DocumentPurpose = (typeof DocumentPurpose)[keyof typeof DocumentPurpose]


export const ShareholderType: {
  Individual: 'Individual',
  Corporate: 'Corporate'
};

export type ShareholderType = (typeof ShareholderType)[keyof typeof ShareholderType]


export const CompanyStatus: {
  Draft: 'Draft',
  Submitted: 'Submitted',
  PreparerApproved: 'PreparerApproved',
  ApproverApproved: 'ApproverApproved',
  AdminApproved: 'AdminApproved',
  RevertedToClient: 'RevertedToClient',
  RevertedToPreparer: 'RevertedToPreparer',
  Completed: 'Completed'
};

export type CompanyStatus = (typeof CompanyStatus)[keyof typeof CompanyStatus]


export const PaymentStatus: {
  Pending: 'Pending',
  Completed: 'Completed',
  Failed: 'Failed',
  Refunded: 'Refunded',
  Disputed: 'Disputed'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const DocumentType: {
  PDF: 'PDF',
  DOCX: 'DOCX',
  XLSX: 'XLSX',
  JPG: 'JPG',
  PNG: 'PNG'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const RefundStatus: {
  Requested: 'Requested',
  Processed: 'Processed',
  Failed: 'Failed'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DocumentPurpose = $Enums.DocumentPurpose

export const DocumentPurpose: typeof $Enums.DocumentPurpose

export type ShareholderType = $Enums.ShareholderType

export const ShareholderType: typeof $Enums.ShareholderType

export type CompanyStatus = $Enums.CompanyStatus

export const CompanyStatus: typeof $Enums.CompanyStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyStatusMessage`: Exposes CRUD operations for the **CompanyStatusMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyStatusMessages
    * const companyStatusMessages = await prisma.companyStatusMessage.findMany()
    * ```
    */
  get companyStatusMessage(): Prisma.CompanyStatusMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.director`: Exposes CRUD operations for the **Director** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Directors
    * const directors = await prisma.director.findMany()
    * ```
    */
  get director(): Prisma.DirectorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareholder`: Exposes CRUD operations for the **Shareholder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shareholders
    * const shareholders = await prisma.shareholder.findMany()
    * ```
    */
  get shareholder(): Prisma.ShareholderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyDocument`: Exposes CRUD operations for the **CompanyDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyDocuments
    * const companyDocuments = await prisma.companyDocument.findMany()
    * ```
    */
  get companyDocument(): Prisma.CompanyDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyService`: Exposes CRUD operations for the **CompanyService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyServices
    * const companyServices = await prisma.companyService.findMany()
    * ```
    */
  get companyService(): Prisma.CompanyServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insightRecommendation`: Exposes CRUD operations for the **InsightRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightRecommendations
    * const insightRecommendations = await prisma.insightRecommendation.findMany()
    * ```
    */
  get insightRecommendation(): Prisma.InsightRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarAction`: Exposes CRUD operations for the **CalendarAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarActions
    * const calendarActions = await prisma.calendarAction.findMany()
    * ```
    */
  get calendarAction(): Prisma.CalendarActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardState`: Exposes CRUD operations for the **DashboardState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardStates
    * const dashboardStates = await prisma.dashboardState.findMany()
    * ```
    */
  get dashboardState(): Prisma.DashboardStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleAssignment`: Exposes CRUD operations for the **RoleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleAssignments
    * const roleAssignments = await prisma.roleAssignment.findMany()
    * ```
    */
  get roleAssignment(): Prisma.RoleAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stagingCompany`: Exposes CRUD operations for the **StagingCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StagingCompanies
    * const stagingCompanies = await prisma.stagingCompany.findMany()
    * ```
    */
  get stagingCompany(): Prisma.StagingCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registeredCompanyName`: Exposes CRUD operations for the **RegisteredCompanyName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisteredCompanyNames
    * const registeredCompanyNames = await prisma.registeredCompanyName.findMany()
    * ```
    */
  get registeredCompanyName(): Prisma.RegisteredCompanyNameDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    CompanyStatusMessage: 'CompanyStatusMessage',
    Director: 'Director',
    Shareholder: 'Shareholder',
    CompanyDocument: 'CompanyDocument',
    Payment: 'Payment',
    Refund: 'Refund',
    Service: 'Service',
    CompanyService: 'CompanyService',
    Notification: 'Notification',
    InsightRecommendation: 'InsightRecommendation',
    CalendarAction: 'CalendarAction',
    ChatMessage: 'ChatMessage',
    DashboardState: 'DashboardState',
    RoleAssignment: 'RoleAssignment',
    Article: 'Article',
    ContactUs: 'ContactUs',
    FAQ: 'FAQ',
    StagingCompany: 'StagingCompany',
    AuditLog: 'AuditLog',
    RegisteredCompanyName: 'RegisteredCompanyName'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "company" | "companyStatusMessage" | "director" | "shareholder" | "companyDocument" | "payment" | "refund" | "service" | "companyService" | "notification" | "insightRecommendation" | "calendarAction" | "chatMessage" | "dashboardState" | "roleAssignment" | "article" | "contactUs" | "fAQ" | "stagingCompany" | "auditLog" | "registeredCompanyName"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyStatusMessage: {
        payload: Prisma.$CompanyStatusMessagePayload<ExtArgs>
        fields: Prisma.CompanyStatusMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyStatusMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyStatusMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          findFirst: {
            args: Prisma.CompanyStatusMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyStatusMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          findMany: {
            args: Prisma.CompanyStatusMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>[]
          }
          create: {
            args: Prisma.CompanyStatusMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          createMany: {
            args: Prisma.CompanyStatusMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyStatusMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>[]
          }
          delete: {
            args: Prisma.CompanyStatusMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          update: {
            args: Prisma.CompanyStatusMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          deleteMany: {
            args: Prisma.CompanyStatusMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyStatusMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyStatusMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>[]
          }
          upsert: {
            args: Prisma.CompanyStatusMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyStatusMessagePayload>
          }
          aggregate: {
            args: Prisma.CompanyStatusMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyStatusMessage>
          }
          groupBy: {
            args: Prisma.CompanyStatusMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyStatusMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyStatusMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyStatusMessageCountAggregateOutputType> | number
          }
        }
      }
      Director: {
        payload: Prisma.$DirectorPayload<ExtArgs>
        fields: Prisma.DirectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          findFirst: {
            args: Prisma.DirectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          findMany: {
            args: Prisma.DirectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>[]
          }
          create: {
            args: Prisma.DirectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          createMany: {
            args: Prisma.DirectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>[]
          }
          delete: {
            args: Prisma.DirectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          update: {
            args: Prisma.DirectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          deleteMany: {
            args: Prisma.DirectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DirectorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>[]
          }
          upsert: {
            args: Prisma.DirectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectorPayload>
          }
          aggregate: {
            args: Prisma.DirectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirector>
          }
          groupBy: {
            args: Prisma.DirectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectorCountArgs<ExtArgs>
            result: $Utils.Optional<DirectorCountAggregateOutputType> | number
          }
        }
      }
      Shareholder: {
        payload: Prisma.$ShareholderPayload<ExtArgs>
        fields: Prisma.ShareholderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareholderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareholderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          findFirst: {
            args: Prisma.ShareholderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareholderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          findMany: {
            args: Prisma.ShareholderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>[]
          }
          create: {
            args: Prisma.ShareholderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          createMany: {
            args: Prisma.ShareholderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareholderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>[]
          }
          delete: {
            args: Prisma.ShareholderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          update: {
            args: Prisma.ShareholderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          deleteMany: {
            args: Prisma.ShareholderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareholderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShareholderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>[]
          }
          upsert: {
            args: Prisma.ShareholderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          aggregate: {
            args: Prisma.ShareholderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareholder>
          }
          groupBy: {
            args: Prisma.ShareholderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareholderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareholderCountArgs<ExtArgs>
            result: $Utils.Optional<ShareholderCountAggregateOutputType> | number
          }
        }
      }
      CompanyDocument: {
        payload: Prisma.$CompanyDocumentPayload<ExtArgs>
        fields: Prisma.CompanyDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findFirst: {
            args: Prisma.CompanyDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findMany: {
            args: Prisma.CompanyDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>[]
          }
          create: {
            args: Prisma.CompanyDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          createMany: {
            args: Prisma.CompanyDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>[]
          }
          delete: {
            args: Prisma.CompanyDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          update: {
            args: Prisma.CompanyDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>[]
          }
          upsert: {
            args: Prisma.CompanyDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          aggregate: {
            args: Prisma.CompanyDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyDocument>
          }
          groupBy: {
            args: Prisma.CompanyDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      CompanyService: {
        payload: Prisma.$CompanyServicePayload<ExtArgs>
        fields: Prisma.CompanyServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          findFirst: {
            args: Prisma.CompanyServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          findMany: {
            args: Prisma.CompanyServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>[]
          }
          create: {
            args: Prisma.CompanyServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          createMany: {
            args: Prisma.CompanyServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>[]
          }
          delete: {
            args: Prisma.CompanyServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          update: {
            args: Prisma.CompanyServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          deleteMany: {
            args: Prisma.CompanyServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>[]
          }
          upsert: {
            args: Prisma.CompanyServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyServicePayload>
          }
          aggregate: {
            args: Prisma.CompanyServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyService>
          }
          groupBy: {
            args: Prisma.CompanyServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyServiceCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyServiceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      InsightRecommendation: {
        payload: Prisma.$InsightRecommendationPayload<ExtArgs>
        fields: Prisma.InsightRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          findFirst: {
            args: Prisma.InsightRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          findMany: {
            args: Prisma.InsightRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>[]
          }
          create: {
            args: Prisma.InsightRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          createMany: {
            args: Prisma.InsightRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>[]
          }
          delete: {
            args: Prisma.InsightRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          update: {
            args: Prisma.InsightRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.InsightRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.InsightRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightRecommendationPayload>
          }
          aggregate: {
            args: Prisma.InsightRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightRecommendation>
          }
          groupBy: {
            args: Prisma.InsightRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<InsightRecommendationCountAggregateOutputType> | number
          }
        }
      }
      CalendarAction: {
        payload: Prisma.$CalendarActionPayload<ExtArgs>
        fields: Prisma.CalendarActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          findFirst: {
            args: Prisma.CalendarActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          findMany: {
            args: Prisma.CalendarActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>[]
          }
          create: {
            args: Prisma.CalendarActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          createMany: {
            args: Prisma.CalendarActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>[]
          }
          delete: {
            args: Prisma.CalendarActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          update: {
            args: Prisma.CalendarActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          deleteMany: {
            args: Prisma.CalendarActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>[]
          }
          upsert: {
            args: Prisma.CalendarActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarActionPayload>
          }
          aggregate: {
            args: Prisma.CalendarActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarAction>
          }
          groupBy: {
            args: Prisma.CalendarActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarActionCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarActionCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      DashboardState: {
        payload: Prisma.$DashboardStatePayload<ExtArgs>
        fields: Prisma.DashboardStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          findFirst: {
            args: Prisma.DashboardStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          findMany: {
            args: Prisma.DashboardStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>[]
          }
          create: {
            args: Prisma.DashboardStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          createMany: {
            args: Prisma.DashboardStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>[]
          }
          delete: {
            args: Prisma.DashboardStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          update: {
            args: Prisma.DashboardStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          deleteMany: {
            args: Prisma.DashboardStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>[]
          }
          upsert: {
            args: Prisma.DashboardStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardStatePayload>
          }
          aggregate: {
            args: Prisma.DashboardStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardState>
          }
          groupBy: {
            args: Prisma.DashboardStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardStateCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardStateCountAggregateOutputType> | number
          }
        }
      }
      RoleAssignment: {
        payload: Prisma.$RoleAssignmentPayload<ExtArgs>
        fields: Prisma.RoleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.RoleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          findMany: {
            args: Prisma.RoleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          create: {
            args: Prisma.RoleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          createMany: {
            args: Prisma.RoleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.RoleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          update: {
            args: Prisma.RoleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.RoleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.RoleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.RoleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleAssignment>
          }
          groupBy: {
            args: Prisma.RoleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<RoleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: Prisma.$ContactUsPayload<ExtArgs>
        fields: Prisma.ContactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactUsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      StagingCompany: {
        payload: Prisma.$StagingCompanyPayload<ExtArgs>
        fields: Prisma.StagingCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StagingCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StagingCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          findFirst: {
            args: Prisma.StagingCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StagingCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          findMany: {
            args: Prisma.StagingCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>[]
          }
          create: {
            args: Prisma.StagingCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          createMany: {
            args: Prisma.StagingCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StagingCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>[]
          }
          delete: {
            args: Prisma.StagingCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          update: {
            args: Prisma.StagingCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          deleteMany: {
            args: Prisma.StagingCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StagingCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StagingCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>[]
          }
          upsert: {
            args: Prisma.StagingCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingCompanyPayload>
          }
          aggregate: {
            args: Prisma.StagingCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStagingCompany>
          }
          groupBy: {
            args: Prisma.StagingCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<StagingCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.StagingCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<StagingCompanyCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      RegisteredCompanyName: {
        payload: Prisma.$RegisteredCompanyNamePayload<ExtArgs>
        fields: Prisma.RegisteredCompanyNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegisteredCompanyNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisteredCompanyNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          findFirst: {
            args: Prisma.RegisteredCompanyNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisteredCompanyNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          findMany: {
            args: Prisma.RegisteredCompanyNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>[]
          }
          create: {
            args: Prisma.RegisteredCompanyNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          createMany: {
            args: Prisma.RegisteredCompanyNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegisteredCompanyNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>[]
          }
          delete: {
            args: Prisma.RegisteredCompanyNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          update: {
            args: Prisma.RegisteredCompanyNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          deleteMany: {
            args: Prisma.RegisteredCompanyNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegisteredCompanyNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegisteredCompanyNameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>[]
          }
          upsert: {
            args: Prisma.RegisteredCompanyNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisteredCompanyNamePayload>
          }
          aggregate: {
            args: Prisma.RegisteredCompanyNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegisteredCompanyName>
          }
          groupBy: {
            args: Prisma.RegisteredCompanyNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegisteredCompanyNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegisteredCompanyNameCountArgs<ExtArgs>
            result: $Utils.Optional<RegisteredCompanyNameCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    company?: CompanyOmit
    companyStatusMessage?: CompanyStatusMessageOmit
    director?: DirectorOmit
    shareholder?: ShareholderOmit
    companyDocument?: CompanyDocumentOmit
    payment?: PaymentOmit
    refund?: RefundOmit
    service?: ServiceOmit
    companyService?: CompanyServiceOmit
    notification?: NotificationOmit
    insightRecommendation?: InsightRecommendationOmit
    calendarAction?: CalendarActionOmit
    chatMessage?: ChatMessageOmit
    dashboardState?: DashboardStateOmit
    roleAssignment?: RoleAssignmentOmit
    article?: ArticleOmit
    contactUs?: ContactUsOmit
    fAQ?: FAQOmit
    stagingCompany?: StagingCompanyOmit
    auditLog?: AuditLogOmit
    registeredCompanyName?: RegisteredCompanyNameOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedTasks: number
    messagesReceived: number
    messagesSent: number
    companies: number
    insights: number
    notifications: number
    payments: number
    assignedRoles: number
    revertMessage: number
    uploadedDocs: number
    receivedDocs: number
    auditLogs: number
    CalendarAction: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    messagesReceived?: boolean | UserCountOutputTypeCountMessagesReceivedArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    insights?: boolean | UserCountOutputTypeCountInsightsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    assignedRoles?: boolean | UserCountOutputTypeCountAssignedRolesArgs
    revertMessage?: boolean | UserCountOutputTypeCountRevertMessageArgs
    uploadedDocs?: boolean | UserCountOutputTypeCountUploadedDocsArgs
    receivedDocs?: boolean | UserCountOutputTypeCountReceivedDocsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    CalendarAction?: boolean | UserCountOutputTypeCountCalendarActionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightRecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRevertMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyStatusMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarActionWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    tasks: number
    documents: number
    companyServices: number
    directors: number
    payments: number
    roleAssignments: number
    shareholders: number
    revertMessage: number
    auditLogs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | CompanyCountOutputTypeCountTasksArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    companyServices?: boolean | CompanyCountOutputTypeCountCompanyServicesArgs
    directors?: boolean | CompanyCountOutputTypeCountDirectorsArgs
    payments?: boolean | CompanyCountOutputTypeCountPaymentsArgs
    roleAssignments?: boolean | CompanyCountOutputTypeCountRoleAssignmentsArgs
    shareholders?: boolean | CompanyCountOutputTypeCountShareholdersArgs
    revertMessage?: boolean | CompanyCountOutputTypeCountRevertMessageArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarActionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyServiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDirectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectorWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRoleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountShareholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRevertMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyStatusMessageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    refunds: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    companyServices: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyServices?: boolean | ServiceCountOutputTypeCountCompanyServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCompanyServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyServiceWhereInput
  }


  /**
   * Count Type StagingCompanyCountOutputType
   */

  export type StagingCompanyCountOutputType = {
    payments: number
  }

  export type StagingCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | StagingCompanyCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * StagingCompanyCountOutputType without action
   */
  export type StagingCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompanyCountOutputType
     */
    select?: StagingCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StagingCompanyCountOutputType without action
   */
  export type StagingCompanyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    mobile: string | null
    country: string | null
    role: $Enums.UserRole | null
    profilePic: string | null
    profileThumbnail: string | null
    lastLogin: Date | null
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
    otp: string | null
    otpExpires: Date | null
    refreshToken: string | null
    isVerified: boolean | null
    isDeactivated: boolean | null
    isDeleted: boolean | null
    isSuspended: boolean | null
    suspendMessage: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    mobile: string | null
    country: string | null
    role: $Enums.UserRole | null
    profilePic: string | null
    profileThumbnail: string | null
    lastLogin: Date | null
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
    otp: string | null
    otpExpires: Date | null
    refreshToken: string | null
    isVerified: boolean | null
    isDeactivated: boolean | null
    isDeleted: boolean | null
    isSuspended: boolean | null
    suspendMessage: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    mobile: number
    country: number
    role: number
    profilePic: number
    profileThumbnail: number
    lastLogin: number
    resetPasswordToken: number
    resetPasswordExpires: number
    otp: number
    otpExpires: number
    refreshToken: number
    isVerified: number
    isDeactivated: number
    isDeleted: number
    isSuspended: number
    suspendMessage: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    mobile?: true
    country?: true
    role?: true
    profilePic?: true
    profileThumbnail?: true
    lastLogin?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
    otp?: true
    otpExpires?: true
    refreshToken?: true
    isVerified?: true
    isDeactivated?: true
    isDeleted?: true
    isSuspended?: true
    suspendMessage?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    mobile?: true
    country?: true
    role?: true
    profilePic?: true
    profileThumbnail?: true
    lastLogin?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
    otp?: true
    otpExpires?: true
    refreshToken?: true
    isVerified?: true
    isDeactivated?: true
    isDeleted?: true
    isSuspended?: true
    suspendMessage?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    mobile?: true
    country?: true
    role?: true
    profilePic?: true
    profileThumbnail?: true
    lastLogin?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
    otp?: true
    otpExpires?: true
    refreshToken?: true
    isVerified?: true
    isDeactivated?: true
    isDeleted?: true
    isSuspended?: true
    suspendMessage?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic: string | null
    profileThumbnail: string | null
    lastLogin: Date | null
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
    otp: string | null
    otpExpires: Date | null
    refreshToken: string | null
    isVerified: boolean
    isDeactivated: boolean
    isDeleted: boolean
    isSuspended: boolean
    suspendMessage: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    mobile?: boolean
    country?: boolean
    role?: boolean
    profilePic?: boolean
    profileThumbnail?: boolean
    lastLogin?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
    otp?: boolean
    otpExpires?: boolean
    refreshToken?: boolean
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: boolean
    createdAt?: boolean
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    revertMessage?: boolean | User$revertMessageArgs<ExtArgs>
    uploadedDocs?: boolean | User$uploadedDocsArgs<ExtArgs>
    receivedDocs?: boolean | User$receivedDocsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    CalendarAction?: boolean | User$CalendarActionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    mobile?: boolean
    country?: boolean
    role?: boolean
    profilePic?: boolean
    profileThumbnail?: boolean
    lastLogin?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
    otp?: boolean
    otpExpires?: boolean
    refreshToken?: boolean
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    mobile?: boolean
    country?: boolean
    role?: boolean
    profilePic?: boolean
    profileThumbnail?: boolean
    lastLogin?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
    otp?: boolean
    otpExpires?: boolean
    refreshToken?: boolean
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    mobile?: boolean
    country?: boolean
    role?: boolean
    profilePic?: boolean
    profileThumbnail?: boolean
    lastLogin?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
    otp?: boolean
    otpExpires?: boolean
    refreshToken?: boolean
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "mobile" | "country" | "role" | "profilePic" | "profileThumbnail" | "lastLogin" | "resetPasswordToken" | "resetPasswordExpires" | "otp" | "otpExpires" | "refreshToken" | "isVerified" | "isDeactivated" | "isDeleted" | "isSuspended" | "suspendMessage" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    revertMessage?: boolean | User$revertMessageArgs<ExtArgs>
    uploadedDocs?: boolean | User$uploadedDocsArgs<ExtArgs>
    receivedDocs?: boolean | User$receivedDocsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    CalendarAction?: boolean | User$CalendarActionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      assignedTasks: Prisma.$CalendarActionPayload<ExtArgs>[]
      messagesReceived: Prisma.$ChatMessagePayload<ExtArgs>[]
      messagesSent: Prisma.$ChatMessagePayload<ExtArgs>[]
      companies: Prisma.$CompanyPayload<ExtArgs>[]
      insights: Prisma.$InsightRecommendationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      assignedRoles: Prisma.$RoleAssignmentPayload<ExtArgs>[]
      revertMessage: Prisma.$CompanyStatusMessagePayload<ExtArgs>[]
      uploadedDocs: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      receivedDocs: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      CalendarAction: Prisma.$CalendarActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      mobile: string
      country: string
      role: $Enums.UserRole
      profilePic: string | null
      profileThumbnail: string | null
      lastLogin: Date | null
      resetPasswordToken: string | null
      resetPasswordExpires: Date | null
      otp: string | null
      otpExpires: Date | null
      refreshToken: string | null
      isVerified: boolean
      isDeactivated: boolean
      isDeleted: boolean
      isSuspended: boolean
      suspendMessage: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesReceived<T extends User$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insights<T extends User$insightsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedRoles<T extends User$assignedRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    revertMessage<T extends User$revertMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$revertMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocs<T extends User$uploadedDocsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedDocs<T extends User$receivedDocsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CalendarAction<T extends User$CalendarActionArgs<ExtArgs> = {}>(args?: Subset<T, User$CalendarActionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly mobile: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly profilePic: FieldRef<"User", 'String'>
    readonly profileThumbnail: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly resetPasswordExpires: FieldRef<"User", 'DateTime'>
    readonly otp: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isDeactivated: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly isSuspended: FieldRef<"User", 'Boolean'>
    readonly suspendMessage: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    where?: CalendarActionWhereInput
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    cursor?: CalendarActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * User.messagesReceived
   */
  export type User$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * User.insights
   */
  export type User$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    where?: InsightRecommendationWhereInput
    orderBy?: InsightRecommendationOrderByWithRelationInput | InsightRecommendationOrderByWithRelationInput[]
    cursor?: InsightRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightRecommendationScalarFieldEnum | InsightRecommendationScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.assignedRoles
   */
  export type User$assignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    cursor?: RoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * User.revertMessage
   */
  export type User$revertMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    where?: CompanyStatusMessageWhereInput
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    cursor?: CompanyStatusMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyStatusMessageScalarFieldEnum | CompanyStatusMessageScalarFieldEnum[]
  }

  /**
   * User.uploadedDocs
   */
  export type User$uploadedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * User.receivedDocs
   */
  export type User$receivedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.CalendarAction
   */
  export type User$CalendarActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    where?: CalendarActionWhereInput
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    cursor?: CalendarActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    companyId: number | null
    proposedShares: number | null
    proposedShareCapital: Decimal | null
    userId: number | null
  }

  export type CompanySumAggregateOutputType = {
    companyId: number | null
    proposedShares: number | null
    proposedShareCapital: Decimal | null
    userId: number | null
  }

  export type CompanyMinAggregateOutputType = {
    companyId: number | null
    companyName: string | null
    registrationDate: Date | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    proposedShares: number | null
    currency: string | null
    proposedShareCapital: Decimal | null
    businessActivity1: string | null
    businessActivity1Desc: string | null
    businessActivity2: string | null
    businessActivity2Desc: string | null
    createdAt: Date | null
    status: $Enums.CompanyStatus | null
    statusRemarks: string | null
    isDeleted: boolean | null
    userId: number | null
    canEditC: boolean | null
    canEditD: boolean | null
    canEditS: boolean | null
  }

  export type CompanyMaxAggregateOutputType = {
    companyId: number | null
    companyName: string | null
    registrationDate: Date | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    proposedShares: number | null
    currency: string | null
    proposedShareCapital: Decimal | null
    businessActivity1: string | null
    businessActivity1Desc: string | null
    businessActivity2: string | null
    businessActivity2Desc: string | null
    createdAt: Date | null
    status: $Enums.CompanyStatus | null
    statusRemarks: string | null
    isDeleted: boolean | null
    userId: number | null
    canEditC: boolean | null
    canEditD: boolean | null
    canEditS: boolean | null
  }

  export type CompanyCountAggregateOutputType = {
    companyId: number
    companyName: number
    registrationDate: number
    addressLine1: number
    addressLine2: number
    country: number
    postalCode: number
    proposedShares: number
    currency: number
    proposedShareCapital: number
    businessActivity1: number
    businessActivity1Desc: number
    businessActivity2: number
    businessActivity2Desc: number
    createdAt: number
    status: number
    statusRemarks: number
    isDeleted: number
    userId: number
    canEditC: number
    canEditD: number
    canEditS: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    companyId?: true
    proposedShares?: true
    proposedShareCapital?: true
    userId?: true
  }

  export type CompanySumAggregateInputType = {
    companyId?: true
    proposedShares?: true
    proposedShareCapital?: true
    userId?: true
  }

  export type CompanyMinAggregateInputType = {
    companyId?: true
    companyName?: true
    registrationDate?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    proposedShares?: true
    currency?: true
    proposedShareCapital?: true
    businessActivity1?: true
    businessActivity1Desc?: true
    businessActivity2?: true
    businessActivity2Desc?: true
    createdAt?: true
    status?: true
    statusRemarks?: true
    isDeleted?: true
    userId?: true
    canEditC?: true
    canEditD?: true
    canEditS?: true
  }

  export type CompanyMaxAggregateInputType = {
    companyId?: true
    companyName?: true
    registrationDate?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    proposedShares?: true
    currency?: true
    proposedShareCapital?: true
    businessActivity1?: true
    businessActivity1Desc?: true
    businessActivity2?: true
    businessActivity2Desc?: true
    createdAt?: true
    status?: true
    statusRemarks?: true
    isDeleted?: true
    userId?: true
    canEditC?: true
    canEditD?: true
    canEditS?: true
  }

  export type CompanyCountAggregateInputType = {
    companyId?: true
    companyName?: true
    registrationDate?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    proposedShares?: true
    currency?: true
    proposedShareCapital?: true
    businessActivity1?: true
    businessActivity1Desc?: true
    businessActivity2?: true
    businessActivity2Desc?: true
    createdAt?: true
    status?: true
    statusRemarks?: true
    isDeleted?: true
    userId?: true
    canEditC?: true
    canEditD?: true
    canEditS?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    companyId: number
    companyName: string
    registrationDate: Date
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt: Date
    status: $Enums.CompanyStatus
    statusRemarks: string | null
    isDeleted: boolean
    userId: number
    canEditC: boolean
    canEditD: boolean
    canEditS: boolean
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    companyName?: boolean
    registrationDate?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    proposedShares?: boolean
    currency?: boolean
    proposedShareCapital?: boolean
    businessActivity1?: boolean
    businessActivity1Desc?: boolean
    businessActivity2?: boolean
    businessActivity2Desc?: boolean
    createdAt?: boolean
    status?: boolean
    statusRemarks?: boolean
    isDeleted?: boolean
    userId?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: boolean | Company$tasksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    companyServices?: boolean | Company$companyServicesArgs<ExtArgs>
    dashboardState?: boolean | Company$dashboardStateArgs<ExtArgs>
    directors?: boolean | Company$directorsArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    roleAssignments?: boolean | Company$roleAssignmentsArgs<ExtArgs>
    shareholders?: boolean | Company$shareholdersArgs<ExtArgs>
    revertMessage?: boolean | Company$revertMessageArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    companyName?: boolean
    registrationDate?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    proposedShares?: boolean
    currency?: boolean
    proposedShareCapital?: boolean
    businessActivity1?: boolean
    businessActivity1Desc?: boolean
    businessActivity2?: boolean
    businessActivity2Desc?: boolean
    createdAt?: boolean
    status?: boolean
    statusRemarks?: boolean
    isDeleted?: boolean
    userId?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    companyName?: boolean
    registrationDate?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    proposedShares?: boolean
    currency?: boolean
    proposedShareCapital?: boolean
    businessActivity1?: boolean
    businessActivity1Desc?: boolean
    businessActivity2?: boolean
    businessActivity2Desc?: boolean
    createdAt?: boolean
    status?: boolean
    statusRemarks?: boolean
    isDeleted?: boolean
    userId?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    companyId?: boolean
    companyName?: boolean
    registrationDate?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    proposedShares?: boolean
    currency?: boolean
    proposedShareCapital?: boolean
    businessActivity1?: boolean
    businessActivity1Desc?: boolean
    businessActivity2?: boolean
    businessActivity2Desc?: boolean
    createdAt?: boolean
    status?: boolean
    statusRemarks?: boolean
    isDeleted?: boolean
    userId?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"companyId" | "companyName" | "registrationDate" | "addressLine1" | "addressLine2" | "country" | "postalCode" | "proposedShares" | "currency" | "proposedShareCapital" | "businessActivity1" | "businessActivity1Desc" | "businessActivity2" | "businessActivity2Desc" | "createdAt" | "status" | "statusRemarks" | "isDeleted" | "userId" | "canEditC" | "canEditD" | "canEditS", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Company$tasksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    companyServices?: boolean | Company$companyServicesArgs<ExtArgs>
    dashboardState?: boolean | Company$dashboardStateArgs<ExtArgs>
    directors?: boolean | Company$directorsArgs<ExtArgs>
    payments?: boolean | Company$paymentsArgs<ExtArgs>
    roleAssignments?: boolean | Company$roleAssignmentsArgs<ExtArgs>
    shareholders?: boolean | Company$shareholdersArgs<ExtArgs>
    revertMessage?: boolean | Company$revertMessageArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      tasks: Prisma.$CalendarActionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      companyServices: Prisma.$CompanyServicePayload<ExtArgs>[]
      dashboardState: Prisma.$DashboardStatePayload<ExtArgs> | null
      directors: Prisma.$DirectorPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      roleAssignments: Prisma.$RoleAssignmentPayload<ExtArgs>[]
      shareholders: Prisma.$ShareholderPayload<ExtArgs>[]
      revertMessage: Prisma.$CompanyStatusMessagePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      companyId: number
      companyName: string
      registrationDate: Date
      addressLine1: string
      addressLine2: string
      country: string
      postalCode: string
      proposedShares: number
      currency: string
      proposedShareCapital: Prisma.Decimal
      businessActivity1: string
      businessActivity1Desc: string
      businessActivity2: string
      businessActivity2Desc: string
      createdAt: Date
      status: $Enums.CompanyStatus
      statusRemarks: string | null
      isDeleted: boolean
      userId: number
      canEditC: boolean
      canEditD: boolean
      canEditS: boolean
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `companyId`
     * const companyWithCompanyIdOnly = await prisma.company.findMany({ select: { companyId: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `companyId`
     * const companyWithCompanyIdOnly = await prisma.company.createManyAndReturn({
     *   select: { companyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `companyId`
     * const companyWithCompanyIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { companyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Company$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Company$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyServices<T extends Company$companyServicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboardState<T extends Company$dashboardStateArgs<ExtArgs> = {}>(args?: Subset<T, Company$dashboardStateArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    directors<T extends Company$directorsArgs<ExtArgs> = {}>(args?: Subset<T, Company$directorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Company$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleAssignments<T extends Company$roleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$roleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareholders<T extends Company$shareholdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$shareholdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    revertMessage<T extends Company$revertMessageArgs<ExtArgs> = {}>(args?: Subset<T, Company$revertMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly companyId: FieldRef<"Company", 'Int'>
    readonly companyName: FieldRef<"Company", 'String'>
    readonly registrationDate: FieldRef<"Company", 'DateTime'>
    readonly addressLine1: FieldRef<"Company", 'String'>
    readonly addressLine2: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly proposedShares: FieldRef<"Company", 'Int'>
    readonly currency: FieldRef<"Company", 'String'>
    readonly proposedShareCapital: FieldRef<"Company", 'Decimal'>
    readonly businessActivity1: FieldRef<"Company", 'String'>
    readonly businessActivity1Desc: FieldRef<"Company", 'String'>
    readonly businessActivity2: FieldRef<"Company", 'String'>
    readonly businessActivity2Desc: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly status: FieldRef<"Company", 'CompanyStatus'>
    readonly statusRemarks: FieldRef<"Company", 'String'>
    readonly isDeleted: FieldRef<"Company", 'Boolean'>
    readonly userId: FieldRef<"Company", 'Int'>
    readonly canEditC: FieldRef<"Company", 'Boolean'>
    readonly canEditD: FieldRef<"Company", 'Boolean'>
    readonly canEditS: FieldRef<"Company", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.tasks
   */
  export type Company$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    where?: CalendarActionWhereInput
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    cursor?: CalendarActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * Company.companyServices
   */
  export type Company$companyServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    where?: CompanyServiceWhereInput
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    cursor?: CompanyServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * Company.dashboardState
   */
  export type Company$dashboardStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    where?: DashboardStateWhereInput
  }

  /**
   * Company.directors
   */
  export type Company$directorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    where?: DirectorWhereInput
    orderBy?: DirectorOrderByWithRelationInput | DirectorOrderByWithRelationInput[]
    cursor?: DirectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectorScalarFieldEnum | DirectorScalarFieldEnum[]
  }

  /**
   * Company.payments
   */
  export type Company$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Company.roleAssignments
   */
  export type Company$roleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    cursor?: RoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * Company.shareholders
   */
  export type Company$shareholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    where?: ShareholderWhereInput
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    cursor?: ShareholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Company.revertMessage
   */
  export type Company$revertMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    where?: CompanyStatusMessageWhereInput
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    cursor?: CompanyStatusMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyStatusMessageScalarFieldEnum | CompanyStatusMessageScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyStatusMessage
   */

  export type AggregateCompanyStatusMessage = {
    _count: CompanyStatusMessageCountAggregateOutputType | null
    _avg: CompanyStatusMessageAvgAggregateOutputType | null
    _sum: CompanyStatusMessageSumAggregateOutputType | null
    _min: CompanyStatusMessageMinAggregateOutputType | null
    _max: CompanyStatusMessageMaxAggregateOutputType | null
  }

  export type CompanyStatusMessageAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    senderId: number | null
  }

  export type CompanyStatusMessageSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    senderId: number | null
  }

  export type CompanyStatusMessageMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    senderId: number | null
    senderRole: $Enums.UserRole | null
    fromStatus: $Enums.CompanyStatus | null
    toStatus: $Enums.CompanyStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type CompanyStatusMessageMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    senderId: number | null
    senderRole: $Enums.UserRole | null
    fromStatus: $Enums.CompanyStatus | null
    toStatus: $Enums.CompanyStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type CompanyStatusMessageCountAggregateOutputType = {
    id: number
    companyId: number
    senderId: number
    senderRole: number
    fromStatus: number
    toStatus: number
    message: number
    createdAt: number
    _all: number
  }


  export type CompanyStatusMessageAvgAggregateInputType = {
    id?: true
    companyId?: true
    senderId?: true
  }

  export type CompanyStatusMessageSumAggregateInputType = {
    id?: true
    companyId?: true
    senderId?: true
  }

  export type CompanyStatusMessageMinAggregateInputType = {
    id?: true
    companyId?: true
    senderId?: true
    senderRole?: true
    fromStatus?: true
    toStatus?: true
    message?: true
    createdAt?: true
  }

  export type CompanyStatusMessageMaxAggregateInputType = {
    id?: true
    companyId?: true
    senderId?: true
    senderRole?: true
    fromStatus?: true
    toStatus?: true
    message?: true
    createdAt?: true
  }

  export type CompanyStatusMessageCountAggregateInputType = {
    id?: true
    companyId?: true
    senderId?: true
    senderRole?: true
    fromStatus?: true
    toStatus?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyStatusMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyStatusMessage to aggregate.
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStatusMessages to fetch.
     */
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyStatusMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStatusMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStatusMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyStatusMessages
    **/
    _count?: true | CompanyStatusMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyStatusMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyStatusMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyStatusMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyStatusMessageMaxAggregateInputType
  }

  export type GetCompanyStatusMessageAggregateType<T extends CompanyStatusMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyStatusMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyStatusMessage[P]>
      : GetScalarType<T[P], AggregateCompanyStatusMessage[P]>
  }




  export type CompanyStatusMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyStatusMessageWhereInput
    orderBy?: CompanyStatusMessageOrderByWithAggregationInput | CompanyStatusMessageOrderByWithAggregationInput[]
    by: CompanyStatusMessageScalarFieldEnum[] | CompanyStatusMessageScalarFieldEnum
    having?: CompanyStatusMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyStatusMessageCountAggregateInputType | true
    _avg?: CompanyStatusMessageAvgAggregateInputType
    _sum?: CompanyStatusMessageSumAggregateInputType
    _min?: CompanyStatusMessageMinAggregateInputType
    _max?: CompanyStatusMessageMaxAggregateInputType
  }

  export type CompanyStatusMessageGroupByOutputType = {
    id: number
    companyId: number
    senderId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt: Date
    _count: CompanyStatusMessageCountAggregateOutputType | null
    _avg: CompanyStatusMessageAvgAggregateOutputType | null
    _sum: CompanyStatusMessageSumAggregateOutputType | null
    _min: CompanyStatusMessageMinAggregateOutputType | null
    _max: CompanyStatusMessageMaxAggregateOutputType | null
  }

  type GetCompanyStatusMessageGroupByPayload<T extends CompanyStatusMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyStatusMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyStatusMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyStatusMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyStatusMessageGroupByOutputType[P]>
        }
      >
    >


  export type CompanyStatusMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    senderId?: boolean
    senderRole?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    message?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStatusMessage"]>

  export type CompanyStatusMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    senderId?: boolean
    senderRole?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    message?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStatusMessage"]>

  export type CompanyStatusMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    senderId?: boolean
    senderRole?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    message?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyStatusMessage"]>

  export type CompanyStatusMessageSelectScalar = {
    id?: boolean
    companyId?: boolean
    senderId?: boolean
    senderRole?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type CompanyStatusMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "senderId" | "senderRole" | "fromStatus" | "toStatus" | "message" | "createdAt", ExtArgs["result"]["companyStatusMessage"]>
  export type CompanyStatusMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyStatusMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyStatusMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyStatusMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyStatusMessage"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      senderId: number
      senderRole: $Enums.UserRole
      fromStatus: $Enums.CompanyStatus
      toStatus: $Enums.CompanyStatus
      message: string
      createdAt: Date
    }, ExtArgs["result"]["companyStatusMessage"]>
    composites: {}
  }

  type CompanyStatusMessageGetPayload<S extends boolean | null | undefined | CompanyStatusMessageDefaultArgs> = $Result.GetResult<Prisma.$CompanyStatusMessagePayload, S>

  type CompanyStatusMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyStatusMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyStatusMessageCountAggregateInputType | true
    }

  export interface CompanyStatusMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyStatusMessage'], meta: { name: 'CompanyStatusMessage' } }
    /**
     * Find zero or one CompanyStatusMessage that matches the filter.
     * @param {CompanyStatusMessageFindUniqueArgs} args - Arguments to find a CompanyStatusMessage
     * @example
     * // Get one CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyStatusMessageFindUniqueArgs>(args: SelectSubset<T, CompanyStatusMessageFindUniqueArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyStatusMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyStatusMessageFindUniqueOrThrowArgs} args - Arguments to find a CompanyStatusMessage
     * @example
     * // Get one CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyStatusMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyStatusMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyStatusMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageFindFirstArgs} args - Arguments to find a CompanyStatusMessage
     * @example
     * // Get one CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyStatusMessageFindFirstArgs>(args?: SelectSubset<T, CompanyStatusMessageFindFirstArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyStatusMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageFindFirstOrThrowArgs} args - Arguments to find a CompanyStatusMessage
     * @example
     * // Get one CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyStatusMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyStatusMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyStatusMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyStatusMessages
     * const companyStatusMessages = await prisma.companyStatusMessage.findMany()
     * 
     * // Get first 10 CompanyStatusMessages
     * const companyStatusMessages = await prisma.companyStatusMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyStatusMessageWithIdOnly = await prisma.companyStatusMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyStatusMessageFindManyArgs>(args?: SelectSubset<T, CompanyStatusMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyStatusMessage.
     * @param {CompanyStatusMessageCreateArgs} args - Arguments to create a CompanyStatusMessage.
     * @example
     * // Create one CompanyStatusMessage
     * const CompanyStatusMessage = await prisma.companyStatusMessage.create({
     *   data: {
     *     // ... data to create a CompanyStatusMessage
     *   }
     * })
     * 
     */
    create<T extends CompanyStatusMessageCreateArgs>(args: SelectSubset<T, CompanyStatusMessageCreateArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyStatusMessages.
     * @param {CompanyStatusMessageCreateManyArgs} args - Arguments to create many CompanyStatusMessages.
     * @example
     * // Create many CompanyStatusMessages
     * const companyStatusMessage = await prisma.companyStatusMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyStatusMessageCreateManyArgs>(args?: SelectSubset<T, CompanyStatusMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyStatusMessages and returns the data saved in the database.
     * @param {CompanyStatusMessageCreateManyAndReturnArgs} args - Arguments to create many CompanyStatusMessages.
     * @example
     * // Create many CompanyStatusMessages
     * const companyStatusMessage = await prisma.companyStatusMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyStatusMessages and only return the `id`
     * const companyStatusMessageWithIdOnly = await prisma.companyStatusMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyStatusMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyStatusMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyStatusMessage.
     * @param {CompanyStatusMessageDeleteArgs} args - Arguments to delete one CompanyStatusMessage.
     * @example
     * // Delete one CompanyStatusMessage
     * const CompanyStatusMessage = await prisma.companyStatusMessage.delete({
     *   where: {
     *     // ... filter to delete one CompanyStatusMessage
     *   }
     * })
     * 
     */
    delete<T extends CompanyStatusMessageDeleteArgs>(args: SelectSubset<T, CompanyStatusMessageDeleteArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyStatusMessage.
     * @param {CompanyStatusMessageUpdateArgs} args - Arguments to update one CompanyStatusMessage.
     * @example
     * // Update one CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyStatusMessageUpdateArgs>(args: SelectSubset<T, CompanyStatusMessageUpdateArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyStatusMessages.
     * @param {CompanyStatusMessageDeleteManyArgs} args - Arguments to filter CompanyStatusMessages to delete.
     * @example
     * // Delete a few CompanyStatusMessages
     * const { count } = await prisma.companyStatusMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyStatusMessageDeleteManyArgs>(args?: SelectSubset<T, CompanyStatusMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyStatusMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyStatusMessages
     * const companyStatusMessage = await prisma.companyStatusMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyStatusMessageUpdateManyArgs>(args: SelectSubset<T, CompanyStatusMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyStatusMessages and returns the data updated in the database.
     * @param {CompanyStatusMessageUpdateManyAndReturnArgs} args - Arguments to update many CompanyStatusMessages.
     * @example
     * // Update many CompanyStatusMessages
     * const companyStatusMessage = await prisma.companyStatusMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyStatusMessages and only return the `id`
     * const companyStatusMessageWithIdOnly = await prisma.companyStatusMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyStatusMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyStatusMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyStatusMessage.
     * @param {CompanyStatusMessageUpsertArgs} args - Arguments to update or create a CompanyStatusMessage.
     * @example
     * // Update or create a CompanyStatusMessage
     * const companyStatusMessage = await prisma.companyStatusMessage.upsert({
     *   create: {
     *     // ... data to create a CompanyStatusMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyStatusMessage we want to update
     *   }
     * })
     */
    upsert<T extends CompanyStatusMessageUpsertArgs>(args: SelectSubset<T, CompanyStatusMessageUpsertArgs<ExtArgs>>): Prisma__CompanyStatusMessageClient<$Result.GetResult<Prisma.$CompanyStatusMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyStatusMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageCountArgs} args - Arguments to filter CompanyStatusMessages to count.
     * @example
     * // Count the number of CompanyStatusMessages
     * const count = await prisma.companyStatusMessage.count({
     *   where: {
     *     // ... the filter for the CompanyStatusMessages we want to count
     *   }
     * })
    **/
    count<T extends CompanyStatusMessageCountArgs>(
      args?: Subset<T, CompanyStatusMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyStatusMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyStatusMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyStatusMessageAggregateArgs>(args: Subset<T, CompanyStatusMessageAggregateArgs>): Prisma.PrismaPromise<GetCompanyStatusMessageAggregateType<T>>

    /**
     * Group by CompanyStatusMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyStatusMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyStatusMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyStatusMessageGroupByArgs['orderBy'] }
        : { orderBy?: CompanyStatusMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyStatusMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyStatusMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyStatusMessage model
   */
  readonly fields: CompanyStatusMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyStatusMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyStatusMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyStatusMessage model
   */
  interface CompanyStatusMessageFieldRefs {
    readonly id: FieldRef<"CompanyStatusMessage", 'Int'>
    readonly companyId: FieldRef<"CompanyStatusMessage", 'Int'>
    readonly senderId: FieldRef<"CompanyStatusMessage", 'Int'>
    readonly senderRole: FieldRef<"CompanyStatusMessage", 'UserRole'>
    readonly fromStatus: FieldRef<"CompanyStatusMessage", 'CompanyStatus'>
    readonly toStatus: FieldRef<"CompanyStatusMessage", 'CompanyStatus'>
    readonly message: FieldRef<"CompanyStatusMessage", 'String'>
    readonly createdAt: FieldRef<"CompanyStatusMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyStatusMessage findUnique
   */
  export type CompanyStatusMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStatusMessage to fetch.
     */
    where: CompanyStatusMessageWhereUniqueInput
  }

  /**
   * CompanyStatusMessage findUniqueOrThrow
   */
  export type CompanyStatusMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStatusMessage to fetch.
     */
    where: CompanyStatusMessageWhereUniqueInput
  }

  /**
   * CompanyStatusMessage findFirst
   */
  export type CompanyStatusMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStatusMessage to fetch.
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStatusMessages to fetch.
     */
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyStatusMessages.
     */
    cursor?: CompanyStatusMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStatusMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStatusMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyStatusMessages.
     */
    distinct?: CompanyStatusMessageScalarFieldEnum | CompanyStatusMessageScalarFieldEnum[]
  }

  /**
   * CompanyStatusMessage findFirstOrThrow
   */
  export type CompanyStatusMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStatusMessage to fetch.
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStatusMessages to fetch.
     */
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyStatusMessages.
     */
    cursor?: CompanyStatusMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStatusMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStatusMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyStatusMessages.
     */
    distinct?: CompanyStatusMessageScalarFieldEnum | CompanyStatusMessageScalarFieldEnum[]
  }

  /**
   * CompanyStatusMessage findMany
   */
  export type CompanyStatusMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter, which CompanyStatusMessages to fetch.
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyStatusMessages to fetch.
     */
    orderBy?: CompanyStatusMessageOrderByWithRelationInput | CompanyStatusMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyStatusMessages.
     */
    cursor?: CompanyStatusMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyStatusMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyStatusMessages.
     */
    skip?: number
    distinct?: CompanyStatusMessageScalarFieldEnum | CompanyStatusMessageScalarFieldEnum[]
  }

  /**
   * CompanyStatusMessage create
   */
  export type CompanyStatusMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyStatusMessage.
     */
    data: XOR<CompanyStatusMessageCreateInput, CompanyStatusMessageUncheckedCreateInput>
  }

  /**
   * CompanyStatusMessage createMany
   */
  export type CompanyStatusMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyStatusMessages.
     */
    data: CompanyStatusMessageCreateManyInput | CompanyStatusMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyStatusMessage createManyAndReturn
   */
  export type CompanyStatusMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyStatusMessages.
     */
    data: CompanyStatusMessageCreateManyInput | CompanyStatusMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyStatusMessage update
   */
  export type CompanyStatusMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyStatusMessage.
     */
    data: XOR<CompanyStatusMessageUpdateInput, CompanyStatusMessageUncheckedUpdateInput>
    /**
     * Choose, which CompanyStatusMessage to update.
     */
    where: CompanyStatusMessageWhereUniqueInput
  }

  /**
   * CompanyStatusMessage updateMany
   */
  export type CompanyStatusMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyStatusMessages.
     */
    data: XOR<CompanyStatusMessageUpdateManyMutationInput, CompanyStatusMessageUncheckedUpdateManyInput>
    /**
     * Filter which CompanyStatusMessages to update
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * Limit how many CompanyStatusMessages to update.
     */
    limit?: number
  }

  /**
   * CompanyStatusMessage updateManyAndReturn
   */
  export type CompanyStatusMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * The data used to update CompanyStatusMessages.
     */
    data: XOR<CompanyStatusMessageUpdateManyMutationInput, CompanyStatusMessageUncheckedUpdateManyInput>
    /**
     * Filter which CompanyStatusMessages to update
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * Limit how many CompanyStatusMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyStatusMessage upsert
   */
  export type CompanyStatusMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyStatusMessage to update in case it exists.
     */
    where: CompanyStatusMessageWhereUniqueInput
    /**
     * In case the CompanyStatusMessage found by the `where` argument doesn't exist, create a new CompanyStatusMessage with this data.
     */
    create: XOR<CompanyStatusMessageCreateInput, CompanyStatusMessageUncheckedCreateInput>
    /**
     * In case the CompanyStatusMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyStatusMessageUpdateInput, CompanyStatusMessageUncheckedUpdateInput>
  }

  /**
   * CompanyStatusMessage delete
   */
  export type CompanyStatusMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
    /**
     * Filter which CompanyStatusMessage to delete.
     */
    where: CompanyStatusMessageWhereUniqueInput
  }

  /**
   * CompanyStatusMessage deleteMany
   */
  export type CompanyStatusMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyStatusMessages to delete
     */
    where?: CompanyStatusMessageWhereInput
    /**
     * Limit how many CompanyStatusMessages to delete.
     */
    limit?: number
  }

  /**
   * CompanyStatusMessage without action
   */
  export type CompanyStatusMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyStatusMessage
     */
    select?: CompanyStatusMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyStatusMessage
     */
    omit?: CompanyStatusMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyStatusMessageInclude<ExtArgs> | null
  }


  /**
   * Model Director
   */

  export type AggregateDirector = {
    _count: DirectorCountAggregateOutputType | null
    _avg: DirectorAvgAggregateOutputType | null
    _sum: DirectorSumAggregateOutputType | null
    _min: DirectorMinAggregateOutputType | null
    _max: DirectorMaxAggregateOutputType | null
  }

  export type DirectorAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type DirectorSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type DirectorMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    directorName: string | null
    email: string | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    contactNumber: string | null
    nationality: string | null
    idType: string | null
    idExpiryDate: Date | null
    idNumber: string | null
    isShareholder: boolean | null
    identityProof: string | null
    addressProof: string | null
    dateOfBirth: Date | null
    createdAt: Date | null
  }

  export type DirectorMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    directorName: string | null
    email: string | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    contactNumber: string | null
    nationality: string | null
    idType: string | null
    idExpiryDate: Date | null
    idNumber: string | null
    isShareholder: boolean | null
    identityProof: string | null
    addressProof: string | null
    dateOfBirth: Date | null
    createdAt: Date | null
  }

  export type DirectorCountAggregateOutputType = {
    id: number
    companyId: number
    directorName: number
    email: number
    addressLine1: number
    addressLine2: number
    country: number
    postalCode: number
    contactNumber: number
    nationality: number
    idType: number
    idExpiryDate: number
    idNumber: number
    isShareholder: number
    identityProof: number
    addressProof: number
    dateOfBirth: number
    createdAt: number
    _all: number
  }


  export type DirectorAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type DirectorSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type DirectorMinAggregateInputType = {
    id?: true
    companyId?: true
    directorName?: true
    email?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    isShareholder?: true
    identityProof?: true
    addressProof?: true
    dateOfBirth?: true
    createdAt?: true
  }

  export type DirectorMaxAggregateInputType = {
    id?: true
    companyId?: true
    directorName?: true
    email?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    isShareholder?: true
    identityProof?: true
    addressProof?: true
    dateOfBirth?: true
    createdAt?: true
  }

  export type DirectorCountAggregateInputType = {
    id?: true
    companyId?: true
    directorName?: true
    email?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    isShareholder?: true
    identityProof?: true
    addressProof?: true
    dateOfBirth?: true
    createdAt?: true
    _all?: true
  }

  export type DirectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Director to aggregate.
     */
    where?: DirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directors to fetch.
     */
    orderBy?: DirectorOrderByWithRelationInput | DirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Directors
    **/
    _count?: true | DirectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectorMaxAggregateInputType
  }

  export type GetDirectorAggregateType<T extends DirectorAggregateArgs> = {
        [P in keyof T & keyof AggregateDirector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirector[P]>
      : GetScalarType<T[P], AggregateDirector[P]>
  }




  export type DirectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectorWhereInput
    orderBy?: DirectorOrderByWithAggregationInput | DirectorOrderByWithAggregationInput[]
    by: DirectorScalarFieldEnum[] | DirectorScalarFieldEnum
    having?: DirectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectorCountAggregateInputType | true
    _avg?: DirectorAvgAggregateInputType
    _sum?: DirectorSumAggregateInputType
    _min?: DirectorMinAggregateInputType
    _max?: DirectorMaxAggregateInputType
  }

  export type DirectorGroupByOutputType = {
    id: number
    companyId: number
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date
    createdAt: Date
    _count: DirectorCountAggregateOutputType | null
    _avg: DirectorAvgAggregateOutputType | null
    _sum: DirectorSumAggregateOutputType | null
    _min: DirectorMinAggregateOutputType | null
    _max: DirectorMaxAggregateOutputType | null
  }

  type GetDirectorGroupByPayload<T extends DirectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectorGroupByOutputType[P]>
            : GetScalarType<T[P], DirectorGroupByOutputType[P]>
        }
      >
    >


  export type DirectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    directorName?: boolean
    email?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    isShareholder?: boolean
    identityProof?: boolean
    addressProof?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["director"]>

  export type DirectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    directorName?: boolean
    email?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    isShareholder?: boolean
    identityProof?: boolean
    addressProof?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["director"]>

  export type DirectorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    directorName?: boolean
    email?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    isShareholder?: boolean
    identityProof?: boolean
    addressProof?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["director"]>

  export type DirectorSelectScalar = {
    id?: boolean
    companyId?: boolean
    directorName?: boolean
    email?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    isShareholder?: boolean
    identityProof?: boolean
    addressProof?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
  }

  export type DirectorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "directorName" | "email" | "addressLine1" | "addressLine2" | "country" | "postalCode" | "contactNumber" | "nationality" | "idType" | "idExpiryDate" | "idNumber" | "isShareholder" | "identityProof" | "addressProof" | "dateOfBirth" | "createdAt", ExtArgs["result"]["director"]>
  export type DirectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DirectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DirectorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DirectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Director"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      directorName: string
      email: string
      addressLine1: string
      addressLine2: string
      country: string
      postalCode: string
      contactNumber: string
      nationality: string
      idType: string
      idExpiryDate: Date
      idNumber: string
      isShareholder: boolean
      identityProof: string
      addressProof: string
      dateOfBirth: Date
      createdAt: Date
    }, ExtArgs["result"]["director"]>
    composites: {}
  }

  type DirectorGetPayload<S extends boolean | null | undefined | DirectorDefaultArgs> = $Result.GetResult<Prisma.$DirectorPayload, S>

  type DirectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DirectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirectorCountAggregateInputType | true
    }

  export interface DirectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Director'], meta: { name: 'Director' } }
    /**
     * Find zero or one Director that matches the filter.
     * @param {DirectorFindUniqueArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectorFindUniqueArgs>(args: SelectSubset<T, DirectorFindUniqueArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Director that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DirectorFindUniqueOrThrowArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectorFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Director that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorFindFirstArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectorFindFirstArgs>(args?: SelectSubset<T, DirectorFindFirstArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Director that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorFindFirstOrThrowArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectorFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Directors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Directors
     * const directors = await prisma.director.findMany()
     * 
     * // Get first 10 Directors
     * const directors = await prisma.director.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directorWithIdOnly = await prisma.director.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectorFindManyArgs>(args?: SelectSubset<T, DirectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Director.
     * @param {DirectorCreateArgs} args - Arguments to create a Director.
     * @example
     * // Create one Director
     * const Director = await prisma.director.create({
     *   data: {
     *     // ... data to create a Director
     *   }
     * })
     * 
     */
    create<T extends DirectorCreateArgs>(args: SelectSubset<T, DirectorCreateArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Directors.
     * @param {DirectorCreateManyArgs} args - Arguments to create many Directors.
     * @example
     * // Create many Directors
     * const director = await prisma.director.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectorCreateManyArgs>(args?: SelectSubset<T, DirectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Directors and returns the data saved in the database.
     * @param {DirectorCreateManyAndReturnArgs} args - Arguments to create many Directors.
     * @example
     * // Create many Directors
     * const director = await prisma.director.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Directors and only return the `id`
     * const directorWithIdOnly = await prisma.director.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectorCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Director.
     * @param {DirectorDeleteArgs} args - Arguments to delete one Director.
     * @example
     * // Delete one Director
     * const Director = await prisma.director.delete({
     *   where: {
     *     // ... filter to delete one Director
     *   }
     * })
     * 
     */
    delete<T extends DirectorDeleteArgs>(args: SelectSubset<T, DirectorDeleteArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Director.
     * @param {DirectorUpdateArgs} args - Arguments to update one Director.
     * @example
     * // Update one Director
     * const director = await prisma.director.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectorUpdateArgs>(args: SelectSubset<T, DirectorUpdateArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Directors.
     * @param {DirectorDeleteManyArgs} args - Arguments to filter Directors to delete.
     * @example
     * // Delete a few Directors
     * const { count } = await prisma.director.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectorDeleteManyArgs>(args?: SelectSubset<T, DirectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Directors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Directors
     * const director = await prisma.director.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectorUpdateManyArgs>(args: SelectSubset<T, DirectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Directors and returns the data updated in the database.
     * @param {DirectorUpdateManyAndReturnArgs} args - Arguments to update many Directors.
     * @example
     * // Update many Directors
     * const director = await prisma.director.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Directors and only return the `id`
     * const directorWithIdOnly = await prisma.director.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DirectorUpdateManyAndReturnArgs>(args: SelectSubset<T, DirectorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Director.
     * @param {DirectorUpsertArgs} args - Arguments to update or create a Director.
     * @example
     * // Update or create a Director
     * const director = await prisma.director.upsert({
     *   create: {
     *     // ... data to create a Director
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Director we want to update
     *   }
     * })
     */
    upsert<T extends DirectorUpsertArgs>(args: SelectSubset<T, DirectorUpsertArgs<ExtArgs>>): Prisma__DirectorClient<$Result.GetResult<Prisma.$DirectorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Directors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorCountArgs} args - Arguments to filter Directors to count.
     * @example
     * // Count the number of Directors
     * const count = await prisma.director.count({
     *   where: {
     *     // ... the filter for the Directors we want to count
     *   }
     * })
    **/
    count<T extends DirectorCountArgs>(
      args?: Subset<T, DirectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Director.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectorAggregateArgs>(args: Subset<T, DirectorAggregateArgs>): Prisma.PrismaPromise<GetDirectorAggregateType<T>>

    /**
     * Group by Director.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectorGroupByArgs['orderBy'] }
        : { orderBy?: DirectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Director model
   */
  readonly fields: DirectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Director.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Director model
   */
  interface DirectorFieldRefs {
    readonly id: FieldRef<"Director", 'Int'>
    readonly companyId: FieldRef<"Director", 'Int'>
    readonly directorName: FieldRef<"Director", 'String'>
    readonly email: FieldRef<"Director", 'String'>
    readonly addressLine1: FieldRef<"Director", 'String'>
    readonly addressLine2: FieldRef<"Director", 'String'>
    readonly country: FieldRef<"Director", 'String'>
    readonly postalCode: FieldRef<"Director", 'String'>
    readonly contactNumber: FieldRef<"Director", 'String'>
    readonly nationality: FieldRef<"Director", 'String'>
    readonly idType: FieldRef<"Director", 'String'>
    readonly idExpiryDate: FieldRef<"Director", 'DateTime'>
    readonly idNumber: FieldRef<"Director", 'String'>
    readonly isShareholder: FieldRef<"Director", 'Boolean'>
    readonly identityProof: FieldRef<"Director", 'String'>
    readonly addressProof: FieldRef<"Director", 'String'>
    readonly dateOfBirth: FieldRef<"Director", 'DateTime'>
    readonly createdAt: FieldRef<"Director", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Director findUnique
   */
  export type DirectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter, which Director to fetch.
     */
    where: DirectorWhereUniqueInput
  }

  /**
   * Director findUniqueOrThrow
   */
  export type DirectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter, which Director to fetch.
     */
    where: DirectorWhereUniqueInput
  }

  /**
   * Director findFirst
   */
  export type DirectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter, which Director to fetch.
     */
    where?: DirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directors to fetch.
     */
    orderBy?: DirectorOrderByWithRelationInput | DirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Directors.
     */
    cursor?: DirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Directors.
     */
    distinct?: DirectorScalarFieldEnum | DirectorScalarFieldEnum[]
  }

  /**
   * Director findFirstOrThrow
   */
  export type DirectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter, which Director to fetch.
     */
    where?: DirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directors to fetch.
     */
    orderBy?: DirectorOrderByWithRelationInput | DirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Directors.
     */
    cursor?: DirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Directors.
     */
    distinct?: DirectorScalarFieldEnum | DirectorScalarFieldEnum[]
  }

  /**
   * Director findMany
   */
  export type DirectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter, which Directors to fetch.
     */
    where?: DirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directors to fetch.
     */
    orderBy?: DirectorOrderByWithRelationInput | DirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Directors.
     */
    cursor?: DirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directors.
     */
    skip?: number
    distinct?: DirectorScalarFieldEnum | DirectorScalarFieldEnum[]
  }

  /**
   * Director create
   */
  export type DirectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * The data needed to create a Director.
     */
    data: XOR<DirectorCreateInput, DirectorUncheckedCreateInput>
  }

  /**
   * Director createMany
   */
  export type DirectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Directors.
     */
    data: DirectorCreateManyInput | DirectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Director createManyAndReturn
   */
  export type DirectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * The data used to create many Directors.
     */
    data: DirectorCreateManyInput | DirectorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Director update
   */
  export type DirectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * The data needed to update a Director.
     */
    data: XOR<DirectorUpdateInput, DirectorUncheckedUpdateInput>
    /**
     * Choose, which Director to update.
     */
    where: DirectorWhereUniqueInput
  }

  /**
   * Director updateMany
   */
  export type DirectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Directors.
     */
    data: XOR<DirectorUpdateManyMutationInput, DirectorUncheckedUpdateManyInput>
    /**
     * Filter which Directors to update
     */
    where?: DirectorWhereInput
    /**
     * Limit how many Directors to update.
     */
    limit?: number
  }

  /**
   * Director updateManyAndReturn
   */
  export type DirectorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * The data used to update Directors.
     */
    data: XOR<DirectorUpdateManyMutationInput, DirectorUncheckedUpdateManyInput>
    /**
     * Filter which Directors to update
     */
    where?: DirectorWhereInput
    /**
     * Limit how many Directors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Director upsert
   */
  export type DirectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * The filter to search for the Director to update in case it exists.
     */
    where: DirectorWhereUniqueInput
    /**
     * In case the Director found by the `where` argument doesn't exist, create a new Director with this data.
     */
    create: XOR<DirectorCreateInput, DirectorUncheckedCreateInput>
    /**
     * In case the Director was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectorUpdateInput, DirectorUncheckedUpdateInput>
  }

  /**
   * Director delete
   */
  export type DirectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
    /**
     * Filter which Director to delete.
     */
    where: DirectorWhereUniqueInput
  }

  /**
   * Director deleteMany
   */
  export type DirectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Directors to delete
     */
    where?: DirectorWhereInput
    /**
     * Limit how many Directors to delete.
     */
    limit?: number
  }

  /**
   * Director without action
   */
  export type DirectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Director
     */
    select?: DirectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Director
     */
    omit?: DirectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectorInclude<ExtArgs> | null
  }


  /**
   * Model Shareholder
   */

  export type AggregateShareholder = {
    _count: ShareholderCountAggregateOutputType | null
    _avg: ShareholderAvgAggregateOutputType | null
    _sum: ShareholderSumAggregateOutputType | null
    _min: ShareholderMinAggregateOutputType | null
    _max: ShareholderMaxAggregateOutputType | null
  }

  export type ShareholderAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    numberOfShares: number | null
    shareCapitalAllocation: Decimal | null
  }

  export type ShareholderSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    numberOfShares: number | null
    shareCapitalAllocation: Decimal | null
  }

  export type ShareholderMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderName: string | null
    email: string | null
    type: $Enums.ShareholderType | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    contactNumber: string | null
    nationality: string | null
    idType: string | null
    idExpiryDate: Date | null
    idNumber: string | null
    dateOfBirth: Date | null
    numberOfShares: number | null
    shareCapitalAllocation: Decimal | null
    createdAt: Date | null
  }

  export type ShareholderMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderName: string | null
    email: string | null
    type: $Enums.ShareholderType | null
    addressLine1: string | null
    addressLine2: string | null
    country: string | null
    postalCode: string | null
    contactNumber: string | null
    nationality: string | null
    idType: string | null
    idExpiryDate: Date | null
    idNumber: string | null
    dateOfBirth: Date | null
    numberOfShares: number | null
    shareCapitalAllocation: Decimal | null
    createdAt: Date | null
  }

  export type ShareholderCountAggregateOutputType = {
    id: number
    companyId: number
    shareholderName: number
    email: number
    type: number
    addressLine1: number
    addressLine2: number
    country: number
    postalCode: number
    contactNumber: number
    nationality: number
    idType: number
    idExpiryDate: number
    idNumber: number
    dateOfBirth: number
    numberOfShares: number
    shareCapitalAllocation: number
    createdAt: number
    _all: number
  }


  export type ShareholderAvgAggregateInputType = {
    id?: true
    companyId?: true
    numberOfShares?: true
    shareCapitalAllocation?: true
  }

  export type ShareholderSumAggregateInputType = {
    id?: true
    companyId?: true
    numberOfShares?: true
    shareCapitalAllocation?: true
  }

  export type ShareholderMinAggregateInputType = {
    id?: true
    companyId?: true
    shareholderName?: true
    email?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    dateOfBirth?: true
    numberOfShares?: true
    shareCapitalAllocation?: true
    createdAt?: true
  }

  export type ShareholderMaxAggregateInputType = {
    id?: true
    companyId?: true
    shareholderName?: true
    email?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    dateOfBirth?: true
    numberOfShares?: true
    shareCapitalAllocation?: true
    createdAt?: true
  }

  export type ShareholderCountAggregateInputType = {
    id?: true
    companyId?: true
    shareholderName?: true
    email?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    country?: true
    postalCode?: true
    contactNumber?: true
    nationality?: true
    idType?: true
    idExpiryDate?: true
    idNumber?: true
    dateOfBirth?: true
    numberOfShares?: true
    shareCapitalAllocation?: true
    createdAt?: true
    _all?: true
  }

  export type ShareholderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholder to aggregate.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shareholders
    **/
    _count?: true | ShareholderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareholderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareholderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareholderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareholderMaxAggregateInputType
  }

  export type GetShareholderAggregateType<T extends ShareholderAggregateArgs> = {
        [P in keyof T & keyof AggregateShareholder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareholder[P]>
      : GetScalarType<T[P], AggregateShareholder[P]>
  }




  export type ShareholderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholderWhereInput
    orderBy?: ShareholderOrderByWithAggregationInput | ShareholderOrderByWithAggregationInput[]
    by: ShareholderScalarFieldEnum[] | ShareholderScalarFieldEnum
    having?: ShareholderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareholderCountAggregateInputType | true
    _avg?: ShareholderAvgAggregateInputType
    _sum?: ShareholderSumAggregateInputType
    _min?: ShareholderMinAggregateInputType
    _max?: ShareholderMaxAggregateInputType
  }

  export type ShareholderGroupByOutputType = {
    id: number
    companyId: number
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date
    idNumber: string
    dateOfBirth: Date
    numberOfShares: number
    shareCapitalAllocation: Decimal
    createdAt: Date
    _count: ShareholderCountAggregateOutputType | null
    _avg: ShareholderAvgAggregateOutputType | null
    _sum: ShareholderSumAggregateOutputType | null
    _min: ShareholderMinAggregateOutputType | null
    _max: ShareholderMaxAggregateOutputType | null
  }

  type GetShareholderGroupByPayload<T extends ShareholderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareholderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareholderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareholderGroupByOutputType[P]>
            : GetScalarType<T[P], ShareholderGroupByOutputType[P]>
        }
      >
    >


  export type ShareholderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareholderName?: boolean
    email?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    dateOfBirth?: boolean
    numberOfShares?: boolean
    shareCapitalAllocation?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholder"]>

  export type ShareholderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareholderName?: boolean
    email?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    dateOfBirth?: boolean
    numberOfShares?: boolean
    shareCapitalAllocation?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholder"]>

  export type ShareholderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareholderName?: boolean
    email?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    dateOfBirth?: boolean
    numberOfShares?: boolean
    shareCapitalAllocation?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholder"]>

  export type ShareholderSelectScalar = {
    id?: boolean
    companyId?: boolean
    shareholderName?: boolean
    email?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    country?: boolean
    postalCode?: boolean
    contactNumber?: boolean
    nationality?: boolean
    idType?: boolean
    idExpiryDate?: boolean
    idNumber?: boolean
    dateOfBirth?: boolean
    numberOfShares?: boolean
    shareCapitalAllocation?: boolean
    createdAt?: boolean
  }

  export type ShareholderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "shareholderName" | "email" | "type" | "addressLine1" | "addressLine2" | "country" | "postalCode" | "contactNumber" | "nationality" | "idType" | "idExpiryDate" | "idNumber" | "dateOfBirth" | "numberOfShares" | "shareCapitalAllocation" | "createdAt", ExtArgs["result"]["shareholder"]>
  export type ShareholderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ShareholderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ShareholderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ShareholderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shareholder"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      shareholderName: string
      email: string
      type: $Enums.ShareholderType
      addressLine1: string
      addressLine2: string
      country: string
      postalCode: string
      contactNumber: string
      nationality: string
      idType: string
      idExpiryDate: Date
      idNumber: string
      dateOfBirth: Date
      numberOfShares: number
      shareCapitalAllocation: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["shareholder"]>
    composites: {}
  }

  type ShareholderGetPayload<S extends boolean | null | undefined | ShareholderDefaultArgs> = $Result.GetResult<Prisma.$ShareholderPayload, S>

  type ShareholderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareholderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareholderCountAggregateInputType | true
    }

  export interface ShareholderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shareholder'], meta: { name: 'Shareholder' } }
    /**
     * Find zero or one Shareholder that matches the filter.
     * @param {ShareholderFindUniqueArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareholderFindUniqueArgs>(args: SelectSubset<T, ShareholderFindUniqueArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shareholder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareholderFindUniqueOrThrowArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareholderFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareholderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shareholder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindFirstArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareholderFindFirstArgs>(args?: SelectSubset<T, ShareholderFindFirstArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shareholder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindFirstOrThrowArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareholderFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareholderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shareholders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shareholders
     * const shareholders = await prisma.shareholder.findMany()
     * 
     * // Get first 10 Shareholders
     * const shareholders = await prisma.shareholder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareholderWithIdOnly = await prisma.shareholder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareholderFindManyArgs>(args?: SelectSubset<T, ShareholderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shareholder.
     * @param {ShareholderCreateArgs} args - Arguments to create a Shareholder.
     * @example
     * // Create one Shareholder
     * const Shareholder = await prisma.shareholder.create({
     *   data: {
     *     // ... data to create a Shareholder
     *   }
     * })
     * 
     */
    create<T extends ShareholderCreateArgs>(args: SelectSubset<T, ShareholderCreateArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shareholders.
     * @param {ShareholderCreateManyArgs} args - Arguments to create many Shareholders.
     * @example
     * // Create many Shareholders
     * const shareholder = await prisma.shareholder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareholderCreateManyArgs>(args?: SelectSubset<T, ShareholderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shareholders and returns the data saved in the database.
     * @param {ShareholderCreateManyAndReturnArgs} args - Arguments to create many Shareholders.
     * @example
     * // Create many Shareholders
     * const shareholder = await prisma.shareholder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shareholders and only return the `id`
     * const shareholderWithIdOnly = await prisma.shareholder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareholderCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareholderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shareholder.
     * @param {ShareholderDeleteArgs} args - Arguments to delete one Shareholder.
     * @example
     * // Delete one Shareholder
     * const Shareholder = await prisma.shareholder.delete({
     *   where: {
     *     // ... filter to delete one Shareholder
     *   }
     * })
     * 
     */
    delete<T extends ShareholderDeleteArgs>(args: SelectSubset<T, ShareholderDeleteArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shareholder.
     * @param {ShareholderUpdateArgs} args - Arguments to update one Shareholder.
     * @example
     * // Update one Shareholder
     * const shareholder = await prisma.shareholder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareholderUpdateArgs>(args: SelectSubset<T, ShareholderUpdateArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shareholders.
     * @param {ShareholderDeleteManyArgs} args - Arguments to filter Shareholders to delete.
     * @example
     * // Delete a few Shareholders
     * const { count } = await prisma.shareholder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareholderDeleteManyArgs>(args?: SelectSubset<T, ShareholderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shareholders
     * const shareholder = await prisma.shareholder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareholderUpdateManyArgs>(args: SelectSubset<T, ShareholderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shareholders and returns the data updated in the database.
     * @param {ShareholderUpdateManyAndReturnArgs} args - Arguments to update many Shareholders.
     * @example
     * // Update many Shareholders
     * const shareholder = await prisma.shareholder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shareholders and only return the `id`
     * const shareholderWithIdOnly = await prisma.shareholder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShareholderUpdateManyAndReturnArgs>(args: SelectSubset<T, ShareholderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shareholder.
     * @param {ShareholderUpsertArgs} args - Arguments to update or create a Shareholder.
     * @example
     * // Update or create a Shareholder
     * const shareholder = await prisma.shareholder.upsert({
     *   create: {
     *     // ... data to create a Shareholder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shareholder we want to update
     *   }
     * })
     */
    upsert<T extends ShareholderUpsertArgs>(args: SelectSubset<T, ShareholderUpsertArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderCountArgs} args - Arguments to filter Shareholders to count.
     * @example
     * // Count the number of Shareholders
     * const count = await prisma.shareholder.count({
     *   where: {
     *     // ... the filter for the Shareholders we want to count
     *   }
     * })
    **/
    count<T extends ShareholderCountArgs>(
      args?: Subset<T, ShareholderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareholderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareholderAggregateArgs>(args: Subset<T, ShareholderAggregateArgs>): Prisma.PrismaPromise<GetShareholderAggregateType<T>>

    /**
     * Group by Shareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareholderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareholderGroupByArgs['orderBy'] }
        : { orderBy?: ShareholderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareholderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareholderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shareholder model
   */
  readonly fields: ShareholderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shareholder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareholderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shareholder model
   */
  interface ShareholderFieldRefs {
    readonly id: FieldRef<"Shareholder", 'Int'>
    readonly companyId: FieldRef<"Shareholder", 'Int'>
    readonly shareholderName: FieldRef<"Shareholder", 'String'>
    readonly email: FieldRef<"Shareholder", 'String'>
    readonly type: FieldRef<"Shareholder", 'ShareholderType'>
    readonly addressLine1: FieldRef<"Shareholder", 'String'>
    readonly addressLine2: FieldRef<"Shareholder", 'String'>
    readonly country: FieldRef<"Shareholder", 'String'>
    readonly postalCode: FieldRef<"Shareholder", 'String'>
    readonly contactNumber: FieldRef<"Shareholder", 'String'>
    readonly nationality: FieldRef<"Shareholder", 'String'>
    readonly idType: FieldRef<"Shareholder", 'String'>
    readonly idExpiryDate: FieldRef<"Shareholder", 'DateTime'>
    readonly idNumber: FieldRef<"Shareholder", 'String'>
    readonly dateOfBirth: FieldRef<"Shareholder", 'DateTime'>
    readonly numberOfShares: FieldRef<"Shareholder", 'Int'>
    readonly shareCapitalAllocation: FieldRef<"Shareholder", 'Decimal'>
    readonly createdAt: FieldRef<"Shareholder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shareholder findUnique
   */
  export type ShareholderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder findUniqueOrThrow
   */
  export type ShareholderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder findFirst
   */
  export type ShareholderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholders.
     */
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder findFirstOrThrow
   */
  export type ShareholderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholders.
     */
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder findMany
   */
  export type ShareholderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholders to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder create
   */
  export type ShareholderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The data needed to create a Shareholder.
     */
    data: XOR<ShareholderCreateInput, ShareholderUncheckedCreateInput>
  }

  /**
   * Shareholder createMany
   */
  export type ShareholderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shareholders.
     */
    data: ShareholderCreateManyInput | ShareholderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shareholder createManyAndReturn
   */
  export type ShareholderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * The data used to create many Shareholders.
     */
    data: ShareholderCreateManyInput | ShareholderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shareholder update
   */
  export type ShareholderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The data needed to update a Shareholder.
     */
    data: XOR<ShareholderUpdateInput, ShareholderUncheckedUpdateInput>
    /**
     * Choose, which Shareholder to update.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder updateMany
   */
  export type ShareholderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shareholders.
     */
    data: XOR<ShareholderUpdateManyMutationInput, ShareholderUncheckedUpdateManyInput>
    /**
     * Filter which Shareholders to update
     */
    where?: ShareholderWhereInput
    /**
     * Limit how many Shareholders to update.
     */
    limit?: number
  }

  /**
   * Shareholder updateManyAndReturn
   */
  export type ShareholderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * The data used to update Shareholders.
     */
    data: XOR<ShareholderUpdateManyMutationInput, ShareholderUncheckedUpdateManyInput>
    /**
     * Filter which Shareholders to update
     */
    where?: ShareholderWhereInput
    /**
     * Limit how many Shareholders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shareholder upsert
   */
  export type ShareholderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The filter to search for the Shareholder to update in case it exists.
     */
    where: ShareholderWhereUniqueInput
    /**
     * In case the Shareholder found by the `where` argument doesn't exist, create a new Shareholder with this data.
     */
    create: XOR<ShareholderCreateInput, ShareholderUncheckedCreateInput>
    /**
     * In case the Shareholder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareholderUpdateInput, ShareholderUncheckedUpdateInput>
  }

  /**
   * Shareholder delete
   */
  export type ShareholderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter which Shareholder to delete.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder deleteMany
   */
  export type ShareholderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholders to delete
     */
    where?: ShareholderWhereInput
    /**
     * Limit how many Shareholders to delete.
     */
    limit?: number
  }

  /**
   * Shareholder without action
   */
  export type ShareholderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholder
     */
    omit?: ShareholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
  }


  /**
   * Model CompanyDocument
   */

  export type AggregateCompanyDocument = {
    _count: CompanyDocumentCountAggregateOutputType | null
    _avg: CompanyDocumentAvgAggregateOutputType | null
    _sum: CompanyDocumentSumAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  export type CompanyDocumentAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    uploadedBy: number | null
    uploadedFor: number | null
  }

  export type CompanyDocumentSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    uploadedBy: number | null
    uploadedFor: number | null
  }

  export type CompanyDocumentMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    documentLabel: string | null
    documentPath: string | null
    documentType: $Enums.DocumentType | null
    purpose: $Enums.DocumentPurpose | null
    thumbnail: string | null
    uploadedAt: Date | null
    isVerified: boolean | null
    uploadedBy: number | null
    uploadedRole: $Enums.UserRole | null
    uploadedFor: number | null
  }

  export type CompanyDocumentMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    documentLabel: string | null
    documentPath: string | null
    documentType: $Enums.DocumentType | null
    purpose: $Enums.DocumentPurpose | null
    thumbnail: string | null
    uploadedAt: Date | null
    isVerified: boolean | null
    uploadedBy: number | null
    uploadedRole: $Enums.UserRole | null
    uploadedFor: number | null
  }

  export type CompanyDocumentCountAggregateOutputType = {
    id: number
    companyId: number
    documentLabel: number
    documentPath: number
    documentType: number
    purpose: number
    thumbnail: number
    uploadedAt: number
    isVerified: number
    uploadedBy: number
    uploadedRole: number
    uploadedFor: number
    _all: number
  }


  export type CompanyDocumentAvgAggregateInputType = {
    id?: true
    companyId?: true
    uploadedBy?: true
    uploadedFor?: true
  }

  export type CompanyDocumentSumAggregateInputType = {
    id?: true
    companyId?: true
    uploadedBy?: true
    uploadedFor?: true
  }

  export type CompanyDocumentMinAggregateInputType = {
    id?: true
    companyId?: true
    documentLabel?: true
    documentPath?: true
    documentType?: true
    purpose?: true
    thumbnail?: true
    uploadedAt?: true
    isVerified?: true
    uploadedBy?: true
    uploadedRole?: true
    uploadedFor?: true
  }

  export type CompanyDocumentMaxAggregateInputType = {
    id?: true
    companyId?: true
    documentLabel?: true
    documentPath?: true
    documentType?: true
    purpose?: true
    thumbnail?: true
    uploadedAt?: true
    isVerified?: true
    uploadedBy?: true
    uploadedRole?: true
    uploadedFor?: true
  }

  export type CompanyDocumentCountAggregateInputType = {
    id?: true
    companyId?: true
    documentLabel?: true
    documentPath?: true
    documentType?: true
    purpose?: true
    thumbnail?: true
    uploadedAt?: true
    isVerified?: true
    uploadedBy?: true
    uploadedRole?: true
    uploadedFor?: true
    _all?: true
  }

  export type CompanyDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocument to aggregate.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyDocuments
    **/
    _count?: true | CompanyDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type GetCompanyDocumentAggregateType<T extends CompanyDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyDocument[P]>
      : GetScalarType<T[P], AggregateCompanyDocument[P]>
  }




  export type CompanyDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithAggregationInput | CompanyDocumentOrderByWithAggregationInput[]
    by: CompanyDocumentScalarFieldEnum[] | CompanyDocumentScalarFieldEnum
    having?: CompanyDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyDocumentCountAggregateInputType | true
    _avg?: CompanyDocumentAvgAggregateInputType
    _sum?: CompanyDocumentSumAggregateInputType
    _min?: CompanyDocumentMinAggregateInputType
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type CompanyDocumentGroupByOutputType = {
    id: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose: $Enums.DocumentPurpose
    thumbnail: string | null
    uploadedAt: Date
    isVerified: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
    uploadedFor: number | null
    _count: CompanyDocumentCountAggregateOutputType | null
    _avg: CompanyDocumentAvgAggregateOutputType | null
    _sum: CompanyDocumentSumAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  type GetCompanyDocumentGroupByPayload<T extends CompanyDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CompanyDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    documentLabel?: boolean
    documentPath?: boolean
    documentType?: boolean
    purpose?: boolean
    thumbnail?: boolean
    uploadedAt?: boolean
    isVerified?: boolean
    uploadedBy?: boolean
    uploadedRole?: boolean
    uploadedFor?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["companyDocument"]>

  export type CompanyDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    documentLabel?: boolean
    documentPath?: boolean
    documentType?: boolean
    purpose?: boolean
    thumbnail?: boolean
    uploadedAt?: boolean
    isVerified?: boolean
    uploadedBy?: boolean
    uploadedRole?: boolean
    uploadedFor?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["companyDocument"]>

  export type CompanyDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    documentLabel?: boolean
    documentPath?: boolean
    documentType?: boolean
    purpose?: boolean
    thumbnail?: boolean
    uploadedAt?: boolean
    isVerified?: boolean
    uploadedBy?: boolean
    uploadedRole?: boolean
    uploadedFor?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }, ExtArgs["result"]["companyDocument"]>

  export type CompanyDocumentSelectScalar = {
    id?: boolean
    companyId?: boolean
    documentLabel?: boolean
    documentPath?: boolean
    documentType?: boolean
    purpose?: boolean
    thumbnail?: boolean
    uploadedAt?: boolean
    isVerified?: boolean
    uploadedBy?: boolean
    uploadedRole?: boolean
    uploadedFor?: boolean
  }

  export type CompanyDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "documentLabel" | "documentPath" | "documentType" | "purpose" | "thumbnail" | "uploadedAt" | "isVerified" | "uploadedBy" | "uploadedRole" | "uploadedFor", ExtArgs["result"]["companyDocument"]>
  export type CompanyDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }
  export type CompanyDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }
  export type CompanyDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    forUser?: boolean | CompanyDocument$forUserArgs<ExtArgs>
  }

  export type $CompanyDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyDocument"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
      forUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      documentLabel: string
      documentPath: string
      documentType: $Enums.DocumentType
      purpose: $Enums.DocumentPurpose
      thumbnail: string | null
      uploadedAt: Date
      isVerified: boolean
      uploadedBy: number
      uploadedRole: $Enums.UserRole
      uploadedFor: number | null
    }, ExtArgs["result"]["companyDocument"]>
    composites: {}
  }

  type CompanyDocumentGetPayload<S extends boolean | null | undefined | CompanyDocumentDefaultArgs> = $Result.GetResult<Prisma.$CompanyDocumentPayload, S>

  type CompanyDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyDocumentCountAggregateInputType | true
    }

  export interface CompanyDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyDocument'], meta: { name: 'CompanyDocument' } }
    /**
     * Find zero or one CompanyDocument that matches the filter.
     * @param {CompanyDocumentFindUniqueArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyDocumentFindUniqueArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyDocumentFindUniqueOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyDocumentFindFirstArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany()
     * 
     * // Get first 10 CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyDocumentWithIdOnly = await prisma.companyDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyDocumentFindManyArgs>(args?: SelectSubset<T, CompanyDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyDocument.
     * @param {CompanyDocumentCreateArgs} args - Arguments to create a CompanyDocument.
     * @example
     * // Create one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.create({
     *   data: {
     *     // ... data to create a CompanyDocument
     *   }
     * })
     * 
     */
    create<T extends CompanyDocumentCreateArgs>(args: SelectSubset<T, CompanyDocumentCreateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyDocuments.
     * @param {CompanyDocumentCreateManyArgs} args - Arguments to create many CompanyDocuments.
     * @example
     * // Create many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyDocumentCreateManyArgs>(args?: SelectSubset<T, CompanyDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyDocuments and returns the data saved in the database.
     * @param {CompanyDocumentCreateManyAndReturnArgs} args - Arguments to create many CompanyDocuments.
     * @example
     * // Create many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyDocuments and only return the `id`
     * const companyDocumentWithIdOnly = await prisma.companyDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyDocument.
     * @param {CompanyDocumentDeleteArgs} args - Arguments to delete one CompanyDocument.
     * @example
     * // Delete one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.delete({
     *   where: {
     *     // ... filter to delete one CompanyDocument
     *   }
     * })
     * 
     */
    delete<T extends CompanyDocumentDeleteArgs>(args: SelectSubset<T, CompanyDocumentDeleteArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyDocument.
     * @param {CompanyDocumentUpdateArgs} args - Arguments to update one CompanyDocument.
     * @example
     * // Update one CompanyDocument
     * const companyDocument = await prisma.companyDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyDocumentUpdateArgs>(args: SelectSubset<T, CompanyDocumentUpdateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyDocuments.
     * @param {CompanyDocumentDeleteManyArgs} args - Arguments to filter CompanyDocuments to delete.
     * @example
     * // Delete a few CompanyDocuments
     * const { count } = await prisma.companyDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDocumentDeleteManyArgs>(args?: SelectSubset<T, CompanyDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyDocumentUpdateManyArgs>(args: SelectSubset<T, CompanyDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyDocuments and returns the data updated in the database.
     * @param {CompanyDocumentUpdateManyAndReturnArgs} args - Arguments to update many CompanyDocuments.
     * @example
     * // Update many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyDocuments and only return the `id`
     * const companyDocumentWithIdOnly = await prisma.companyDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyDocument.
     * @param {CompanyDocumentUpsertArgs} args - Arguments to update or create a CompanyDocument.
     * @example
     * // Update or create a CompanyDocument
     * const companyDocument = await prisma.companyDocument.upsert({
     *   create: {
     *     // ... data to create a CompanyDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyDocument we want to update
     *   }
     * })
     */
    upsert<T extends CompanyDocumentUpsertArgs>(args: SelectSubset<T, CompanyDocumentUpsertArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentCountArgs} args - Arguments to filter CompanyDocuments to count.
     * @example
     * // Count the number of CompanyDocuments
     * const count = await prisma.companyDocument.count({
     *   where: {
     *     // ... the filter for the CompanyDocuments we want to count
     *   }
     * })
    **/
    count<T extends CompanyDocumentCountArgs>(
      args?: Subset<T, CompanyDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyDocumentAggregateArgs>(args: Subset<T, CompanyDocumentAggregateArgs>): Prisma.PrismaPromise<GetCompanyDocumentAggregateType<T>>

    /**
     * Group by CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CompanyDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyDocument model
   */
  readonly fields: CompanyDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    forUser<T extends CompanyDocument$forUserArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDocument$forUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyDocument model
   */
  interface CompanyDocumentFieldRefs {
    readonly id: FieldRef<"CompanyDocument", 'Int'>
    readonly companyId: FieldRef<"CompanyDocument", 'Int'>
    readonly documentLabel: FieldRef<"CompanyDocument", 'String'>
    readonly documentPath: FieldRef<"CompanyDocument", 'String'>
    readonly documentType: FieldRef<"CompanyDocument", 'DocumentType'>
    readonly purpose: FieldRef<"CompanyDocument", 'DocumentPurpose'>
    readonly thumbnail: FieldRef<"CompanyDocument", 'String'>
    readonly uploadedAt: FieldRef<"CompanyDocument", 'DateTime'>
    readonly isVerified: FieldRef<"CompanyDocument", 'Boolean'>
    readonly uploadedBy: FieldRef<"CompanyDocument", 'Int'>
    readonly uploadedRole: FieldRef<"CompanyDocument", 'UserRole'>
    readonly uploadedFor: FieldRef<"CompanyDocument", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CompanyDocument findUnique
   */
  export type CompanyDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findUniqueOrThrow
   */
  export type CompanyDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findFirst
   */
  export type CompanyDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findFirstOrThrow
   */
  export type CompanyDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findMany
   */
  export type CompanyDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocuments to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument create
   */
  export type CompanyDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyDocument.
     */
    data: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
  }

  /**
   * CompanyDocument createMany
   */
  export type CompanyDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyDocuments.
     */
    data: CompanyDocumentCreateManyInput | CompanyDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyDocument createManyAndReturn
   */
  export type CompanyDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyDocuments.
     */
    data: CompanyDocumentCreateManyInput | CompanyDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyDocument update
   */
  export type CompanyDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyDocument.
     */
    data: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
    /**
     * Choose, which CompanyDocument to update.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument updateMany
   */
  export type CompanyDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyDocuments.
     */
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CompanyDocuments to update
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to update.
     */
    limit?: number
  }

  /**
   * CompanyDocument updateManyAndReturn
   */
  export type CompanyDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * The data used to update CompanyDocuments.
     */
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CompanyDocuments to update
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyDocument upsert
   */
  export type CompanyDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyDocument to update in case it exists.
     */
    where: CompanyDocumentWhereUniqueInput
    /**
     * In case the CompanyDocument found by the `where` argument doesn't exist, create a new CompanyDocument with this data.
     */
    create: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
    /**
     * In case the CompanyDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
  }

  /**
   * CompanyDocument delete
   */
  export type CompanyDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter which CompanyDocument to delete.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument deleteMany
   */
  export type CompanyDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocuments to delete
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to delete.
     */
    limit?: number
  }

  /**
   * CompanyDocument.forUser
   */
  export type CompanyDocument$forUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CompanyDocument without action
   */
  export type CompanyDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
    stagingCompanyId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentReference: string | null
    services: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
    stagingCompanyId: string | null
    paymentDate: Date | null
    amount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentReference: string | null
    services: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    stagingCompanyId: number
    paymentDate: number
    amount: number
    currency: number
    paymentMethod: number
    paymentStatus: number
    paymentReference: number
    services: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    stagingCompanyId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentStatus?: true
    paymentReference?: true
    services?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    stagingCompanyId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentStatus?: true
    paymentReference?: true
    services?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    stagingCompanyId?: true
    paymentDate?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentStatus?: true
    paymentReference?: true
    services?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    companyId: number | null
    userId: number | null
    stagingCompanyId: string | null
    paymentDate: Date
    amount: Decimal
    currency: string
    paymentMethod: string
    paymentStatus: $Enums.PaymentStatus
    paymentReference: string
    services: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    stagingCompanyId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paymentReference?: boolean
    services?: boolean
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    stagingCompanyId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paymentReference?: boolean
    services?: boolean
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    stagingCompanyId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paymentReference?: boolean
    services?: boolean
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    stagingCompanyId?: boolean
    paymentDate?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paymentReference?: boolean
    services?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "userId" | "stagingCompanyId" | "paymentDate" | "amount" | "currency" | "paymentMethod" | "paymentStatus" | "paymentReference" | "services", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Payment$companyArgs<ExtArgs>
    user?: boolean | Payment$userArgs<ExtArgs>
    stagingCompany?: boolean | Payment$stagingCompanyArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      refunds: Prisma.$RefundPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      stagingCompany: Prisma.$StagingCompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number | null
      userId: number | null
      stagingCompanyId: string | null
      paymentDate: Date
      amount: Prisma.Decimal
      currency: string
      paymentMethod: string
      paymentStatus: $Enums.PaymentStatus
      paymentReference: string
      services: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends Payment$companyArgs<ExtArgs> = {}>(args?: Subset<T, Payment$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Payment$userArgs<ExtArgs> = {}>(args?: Subset<T, Payment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stagingCompany<T extends Payment$stagingCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Payment$stagingCompanyArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly companyId: FieldRef<"Payment", 'Int'>
    readonly userId: FieldRef<"Payment", 'Int'>
    readonly stagingCompanyId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly paymentStatus: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentReference: FieldRef<"Payment", 'String'>
    readonly services: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Payment.company
   */
  export type Payment$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Payment.user
   */
  export type Payment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment.stagingCompany
   */
  export type Payment$stagingCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    where?: StagingCompanyWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    amount: Decimal | null
  }

  export type RefundSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
    amount: Decimal | null
  }

  export type RefundMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundId: string | null
    amount: Decimal | null
    status: $Enums.RefundStatus | null
    createdAt: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    refundId: string | null
    amount: Decimal | null
    status: $Enums.RefundStatus | null
    createdAt: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    paymentId: number
    refundId: number
    amount: number
    status: number
    createdAt: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    id?: true
    paymentId?: true
    amount?: true
  }

  export type RefundSumAggregateInputType = {
    id?: true
    paymentId?: true
    amount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    paymentId?: true
    refundId?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    paymentId?: true
    refundId?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    paymentId?: true
    refundId?: true
    amount?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: number
    paymentId: number
    refundId: string
    amount: Decimal
    status: $Enums.RefundStatus
    createdAt: Date
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    refundId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    paymentId?: boolean
    refundId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type RefundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "refundId" | "amount" | "status" | "createdAt", ExtArgs["result"]["refund"]>
  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentId: number
      refundId: string
      amount: Prisma.Decimal
      status: $Enums.RefundStatus
      createdAt: Date
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds and returns the data updated in the database.
     * @param {RefundUpdateManyAndReturnArgs} args - Arguments to update many Refunds.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'Int'>
    readonly paymentId: FieldRef<"Refund", 'Int'>
    readonly refundId: FieldRef<"Refund", 'String'>
    readonly amount: FieldRef<"Refund", 'Decimal'>
    readonly status: FieldRef<"Refund", 'RefundStatus'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
  }

  /**
   * Refund updateManyAndReturn
   */
  export type RefundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to delete.
     */
    limit?: number
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    cost: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    cost: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    serviceName: string | null
    serviceDescription: string | null
    cost: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    serviceName: string | null
    serviceDescription: string | null
    cost: Decimal | null
    status: string | null
    createdAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    serviceName: number
    serviceDescription: number
    cost: number
    status: number
    createdAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    cost?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    cost?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    serviceName?: true
    serviceDescription?: true
    cost?: true
    status?: true
    createdAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    serviceName?: true
    serviceDescription?: true
    cost?: true
    status?: true
    createdAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    serviceName?: true
    serviceDescription?: true
    cost?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    serviceName: string
    serviceDescription: string
    cost: Decimal
    status: string
    createdAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    serviceDescription?: boolean
    cost?: boolean
    status?: boolean
    createdAt?: boolean
    companyServices?: boolean | Service$companyServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    serviceDescription?: boolean
    cost?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceName?: boolean
    serviceDescription?: boolean
    cost?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    serviceName?: boolean
    serviceDescription?: boolean
    cost?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceName" | "serviceDescription" | "cost" | "status" | "createdAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyServices?: boolean | Service$companyServicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      companyServices: Prisma.$CompanyServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceName: string
      serviceDescription: string
      cost: Prisma.Decimal
      status: string
      createdAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyServices<T extends Service$companyServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$companyServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly serviceName: FieldRef<"Service", 'String'>
    readonly serviceDescription: FieldRef<"Service", 'String'>
    readonly cost: FieldRef<"Service", 'Decimal'>
    readonly status: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.companyServices
   */
  export type Service$companyServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    where?: CompanyServiceWhereInput
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    cursor?: CompanyServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model CompanyService
   */

  export type AggregateCompanyService = {
    _count: CompanyServiceCountAggregateOutputType | null
    _avg: CompanyServiceAvgAggregateOutputType | null
    _sum: CompanyServiceSumAggregateOutputType | null
    _min: CompanyServiceMinAggregateOutputType | null
    _max: CompanyServiceMaxAggregateOutputType | null
  }

  export type CompanyServiceAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    serviceId: number | null
  }

  export type CompanyServiceSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    serviceId: number | null
  }

  export type CompanyServiceMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    serviceId: number | null
    updateDate: Date | null
  }

  export type CompanyServiceMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    serviceId: number | null
    updateDate: Date | null
  }

  export type CompanyServiceCountAggregateOutputType = {
    id: number
    companyId: number
    serviceId: number
    updateDate: number
    _all: number
  }


  export type CompanyServiceAvgAggregateInputType = {
    id?: true
    companyId?: true
    serviceId?: true
  }

  export type CompanyServiceSumAggregateInputType = {
    id?: true
    companyId?: true
    serviceId?: true
  }

  export type CompanyServiceMinAggregateInputType = {
    id?: true
    companyId?: true
    serviceId?: true
    updateDate?: true
  }

  export type CompanyServiceMaxAggregateInputType = {
    id?: true
    companyId?: true
    serviceId?: true
    updateDate?: true
  }

  export type CompanyServiceCountAggregateInputType = {
    id?: true
    companyId?: true
    serviceId?: true
    updateDate?: true
    _all?: true
  }

  export type CompanyServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyService to aggregate.
     */
    where?: CompanyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyServices to fetch.
     */
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyServices
    **/
    _count?: true | CompanyServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyServiceMaxAggregateInputType
  }

  export type GetCompanyServiceAggregateType<T extends CompanyServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyService[P]>
      : GetScalarType<T[P], AggregateCompanyService[P]>
  }




  export type CompanyServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyServiceWhereInput
    orderBy?: CompanyServiceOrderByWithAggregationInput | CompanyServiceOrderByWithAggregationInput[]
    by: CompanyServiceScalarFieldEnum[] | CompanyServiceScalarFieldEnum
    having?: CompanyServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyServiceCountAggregateInputType | true
    _avg?: CompanyServiceAvgAggregateInputType
    _sum?: CompanyServiceSumAggregateInputType
    _min?: CompanyServiceMinAggregateInputType
    _max?: CompanyServiceMaxAggregateInputType
  }

  export type CompanyServiceGroupByOutputType = {
    id: number
    companyId: number
    serviceId: number
    updateDate: Date
    _count: CompanyServiceCountAggregateOutputType | null
    _avg: CompanyServiceAvgAggregateOutputType | null
    _sum: CompanyServiceSumAggregateOutputType | null
    _min: CompanyServiceMinAggregateOutputType | null
    _max: CompanyServiceMaxAggregateOutputType | null
  }

  type GetCompanyServiceGroupByPayload<T extends CompanyServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyServiceGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyServiceGroupByOutputType[P]>
        }
      >
    >


  export type CompanyServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    serviceId?: boolean
    updateDate?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyService"]>

  export type CompanyServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    serviceId?: boolean
    updateDate?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyService"]>

  export type CompanyServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    serviceId?: boolean
    updateDate?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyService"]>

  export type CompanyServiceSelectScalar = {
    id?: boolean
    companyId?: boolean
    serviceId?: boolean
    updateDate?: boolean
  }

  export type CompanyServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "serviceId" | "updateDate", ExtArgs["result"]["companyService"]>
  export type CompanyServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type CompanyServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type CompanyServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $CompanyServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyService"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      serviceId: number
      updateDate: Date
    }, ExtArgs["result"]["companyService"]>
    composites: {}
  }

  type CompanyServiceGetPayload<S extends boolean | null | undefined | CompanyServiceDefaultArgs> = $Result.GetResult<Prisma.$CompanyServicePayload, S>

  type CompanyServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyServiceCountAggregateInputType | true
    }

  export interface CompanyServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyService'], meta: { name: 'CompanyService' } }
    /**
     * Find zero or one CompanyService that matches the filter.
     * @param {CompanyServiceFindUniqueArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyServiceFindUniqueArgs>(args: SelectSubset<T, CompanyServiceFindUniqueArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyServiceFindUniqueOrThrowArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceFindFirstArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyServiceFindFirstArgs>(args?: SelectSubset<T, CompanyServiceFindFirstArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceFindFirstOrThrowArgs} args - Arguments to find a CompanyService
     * @example
     * // Get one CompanyService
     * const companyService = await prisma.companyService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyServices
     * const companyServices = await prisma.companyService.findMany()
     * 
     * // Get first 10 CompanyServices
     * const companyServices = await prisma.companyService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyServiceFindManyArgs>(args?: SelectSubset<T, CompanyServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyService.
     * @param {CompanyServiceCreateArgs} args - Arguments to create a CompanyService.
     * @example
     * // Create one CompanyService
     * const CompanyService = await prisma.companyService.create({
     *   data: {
     *     // ... data to create a CompanyService
     *   }
     * })
     * 
     */
    create<T extends CompanyServiceCreateArgs>(args: SelectSubset<T, CompanyServiceCreateArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyServices.
     * @param {CompanyServiceCreateManyArgs} args - Arguments to create many CompanyServices.
     * @example
     * // Create many CompanyServices
     * const companyService = await prisma.companyService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyServiceCreateManyArgs>(args?: SelectSubset<T, CompanyServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyServices and returns the data saved in the database.
     * @param {CompanyServiceCreateManyAndReturnArgs} args - Arguments to create many CompanyServices.
     * @example
     * // Create many CompanyServices
     * const companyService = await prisma.companyService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyServices and only return the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyService.
     * @param {CompanyServiceDeleteArgs} args - Arguments to delete one CompanyService.
     * @example
     * // Delete one CompanyService
     * const CompanyService = await prisma.companyService.delete({
     *   where: {
     *     // ... filter to delete one CompanyService
     *   }
     * })
     * 
     */
    delete<T extends CompanyServiceDeleteArgs>(args: SelectSubset<T, CompanyServiceDeleteArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyService.
     * @param {CompanyServiceUpdateArgs} args - Arguments to update one CompanyService.
     * @example
     * // Update one CompanyService
     * const companyService = await prisma.companyService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyServiceUpdateArgs>(args: SelectSubset<T, CompanyServiceUpdateArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyServices.
     * @param {CompanyServiceDeleteManyArgs} args - Arguments to filter CompanyServices to delete.
     * @example
     * // Delete a few CompanyServices
     * const { count } = await prisma.companyService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyServiceDeleteManyArgs>(args?: SelectSubset<T, CompanyServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyServices
     * const companyService = await prisma.companyService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyServiceUpdateManyArgs>(args: SelectSubset<T, CompanyServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyServices and returns the data updated in the database.
     * @param {CompanyServiceUpdateManyAndReturnArgs} args - Arguments to update many CompanyServices.
     * @example
     * // Update many CompanyServices
     * const companyService = await prisma.companyService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyServices and only return the `id`
     * const companyServiceWithIdOnly = await prisma.companyService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyService.
     * @param {CompanyServiceUpsertArgs} args - Arguments to update or create a CompanyService.
     * @example
     * // Update or create a CompanyService
     * const companyService = await prisma.companyService.upsert({
     *   create: {
     *     // ... data to create a CompanyService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyService we want to update
     *   }
     * })
     */
    upsert<T extends CompanyServiceUpsertArgs>(args: SelectSubset<T, CompanyServiceUpsertArgs<ExtArgs>>): Prisma__CompanyServiceClient<$Result.GetResult<Prisma.$CompanyServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceCountArgs} args - Arguments to filter CompanyServices to count.
     * @example
     * // Count the number of CompanyServices
     * const count = await prisma.companyService.count({
     *   where: {
     *     // ... the filter for the CompanyServices we want to count
     *   }
     * })
    **/
    count<T extends CompanyServiceCountArgs>(
      args?: Subset<T, CompanyServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyServiceAggregateArgs>(args: Subset<T, CompanyServiceAggregateArgs>): Prisma.PrismaPromise<GetCompanyServiceAggregateType<T>>

    /**
     * Group by CompanyService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyServiceGroupByArgs['orderBy'] }
        : { orderBy?: CompanyServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyService model
   */
  readonly fields: CompanyServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyService model
   */
  interface CompanyServiceFieldRefs {
    readonly id: FieldRef<"CompanyService", 'Int'>
    readonly companyId: FieldRef<"CompanyService", 'Int'>
    readonly serviceId: FieldRef<"CompanyService", 'Int'>
    readonly updateDate: FieldRef<"CompanyService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyService findUnique
   */
  export type CompanyServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyService to fetch.
     */
    where: CompanyServiceWhereUniqueInput
  }

  /**
   * CompanyService findUniqueOrThrow
   */
  export type CompanyServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyService to fetch.
     */
    where: CompanyServiceWhereUniqueInput
  }

  /**
   * CompanyService findFirst
   */
  export type CompanyServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyService to fetch.
     */
    where?: CompanyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyServices to fetch.
     */
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyServices.
     */
    cursor?: CompanyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyServices.
     */
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * CompanyService findFirstOrThrow
   */
  export type CompanyServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyService to fetch.
     */
    where?: CompanyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyServices to fetch.
     */
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyServices.
     */
    cursor?: CompanyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyServices.
     */
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * CompanyService findMany
   */
  export type CompanyServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyServices to fetch.
     */
    where?: CompanyServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyServices to fetch.
     */
    orderBy?: CompanyServiceOrderByWithRelationInput | CompanyServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyServices.
     */
    cursor?: CompanyServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyServices.
     */
    skip?: number
    distinct?: CompanyServiceScalarFieldEnum | CompanyServiceScalarFieldEnum[]
  }

  /**
   * CompanyService create
   */
  export type CompanyServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyService.
     */
    data: XOR<CompanyServiceCreateInput, CompanyServiceUncheckedCreateInput>
  }

  /**
   * CompanyService createMany
   */
  export type CompanyServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyServices.
     */
    data: CompanyServiceCreateManyInput | CompanyServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyService createManyAndReturn
   */
  export type CompanyServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyServices.
     */
    data: CompanyServiceCreateManyInput | CompanyServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyService update
   */
  export type CompanyServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyService.
     */
    data: XOR<CompanyServiceUpdateInput, CompanyServiceUncheckedUpdateInput>
    /**
     * Choose, which CompanyService to update.
     */
    where: CompanyServiceWhereUniqueInput
  }

  /**
   * CompanyService updateMany
   */
  export type CompanyServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyServices.
     */
    data: XOR<CompanyServiceUpdateManyMutationInput, CompanyServiceUncheckedUpdateManyInput>
    /**
     * Filter which CompanyServices to update
     */
    where?: CompanyServiceWhereInput
    /**
     * Limit how many CompanyServices to update.
     */
    limit?: number
  }

  /**
   * CompanyService updateManyAndReturn
   */
  export type CompanyServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * The data used to update CompanyServices.
     */
    data: XOR<CompanyServiceUpdateManyMutationInput, CompanyServiceUncheckedUpdateManyInput>
    /**
     * Filter which CompanyServices to update
     */
    where?: CompanyServiceWhereInput
    /**
     * Limit how many CompanyServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyService upsert
   */
  export type CompanyServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyService to update in case it exists.
     */
    where: CompanyServiceWhereUniqueInput
    /**
     * In case the CompanyService found by the `where` argument doesn't exist, create a new CompanyService with this data.
     */
    create: XOR<CompanyServiceCreateInput, CompanyServiceUncheckedCreateInput>
    /**
     * In case the CompanyService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyServiceUpdateInput, CompanyServiceUncheckedUpdateInput>
  }

  /**
   * CompanyService delete
   */
  export type CompanyServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
    /**
     * Filter which CompanyService to delete.
     */
    where: CompanyServiceWhereUniqueInput
  }

  /**
   * CompanyService deleteMany
   */
  export type CompanyServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyServices to delete
     */
    where?: CompanyServiceWhereInput
    /**
     * Limit how many CompanyServices to delete.
     */
    limit?: number
  }

  /**
   * CompanyService without action
   */
  export type CompanyServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyService
     */
    select?: CompanyServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyService
     */
    omit?: CompanyServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyServiceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    message: string
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      message: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model InsightRecommendation
   */

  export type AggregateInsightRecommendation = {
    _count: InsightRecommendationCountAggregateOutputType | null
    _avg: InsightRecommendationAvgAggregateOutputType | null
    _sum: InsightRecommendationSumAggregateOutputType | null
    _min: InsightRecommendationMinAggregateOutputType | null
    _max: InsightRecommendationMaxAggregateOutputType | null
  }

  export type InsightRecommendationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InsightRecommendationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InsightRecommendationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type InsightRecommendationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type InsightRecommendationCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    sampleDocUrls: number
    createdAt: number
    _all: number
  }


  export type InsightRecommendationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InsightRecommendationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InsightRecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type InsightRecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type InsightRecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    sampleDocUrls?: true
    createdAt?: true
    _all?: true
  }

  export type InsightRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightRecommendation to aggregate.
     */
    where?: InsightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightRecommendations to fetch.
     */
    orderBy?: InsightRecommendationOrderByWithRelationInput | InsightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightRecommendations
    **/
    _count?: true | InsightRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsightRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsightRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightRecommendationMaxAggregateInputType
  }

  export type GetInsightRecommendationAggregateType<T extends InsightRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightRecommendation[P]>
      : GetScalarType<T[P], AggregateInsightRecommendation[P]>
  }




  export type InsightRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightRecommendationWhereInput
    orderBy?: InsightRecommendationOrderByWithAggregationInput | InsightRecommendationOrderByWithAggregationInput[]
    by: InsightRecommendationScalarFieldEnum[] | InsightRecommendationScalarFieldEnum
    having?: InsightRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightRecommendationCountAggregateInputType | true
    _avg?: InsightRecommendationAvgAggregateInputType
    _sum?: InsightRecommendationSumAggregateInputType
    _min?: InsightRecommendationMinAggregateInputType
    _max?: InsightRecommendationMaxAggregateInputType
  }

  export type InsightRecommendationGroupByOutputType = {
    id: number
    userId: number
    content: string
    sampleDocUrls: string[]
    createdAt: Date
    _count: InsightRecommendationCountAggregateOutputType | null
    _avg: InsightRecommendationAvgAggregateOutputType | null
    _sum: InsightRecommendationSumAggregateOutputType | null
    _min: InsightRecommendationMinAggregateOutputType | null
    _max: InsightRecommendationMaxAggregateOutputType | null
  }

  type GetInsightRecommendationGroupByPayload<T extends InsightRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], InsightRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type InsightRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    sampleDocUrls?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightRecommendation"]>

  export type InsightRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    sampleDocUrls?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightRecommendation"]>

  export type InsightRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    sampleDocUrls?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightRecommendation"]>

  export type InsightRecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    sampleDocUrls?: boolean
    createdAt?: boolean
  }

  export type InsightRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "sampleDocUrls" | "createdAt", ExtArgs["result"]["insightRecommendation"]>
  export type InsightRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InsightRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InsightRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InsightRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightRecommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      content: string
      sampleDocUrls: string[]
      createdAt: Date
    }, ExtArgs["result"]["insightRecommendation"]>
    composites: {}
  }

  type InsightRecommendationGetPayload<S extends boolean | null | undefined | InsightRecommendationDefaultArgs> = $Result.GetResult<Prisma.$InsightRecommendationPayload, S>

  type InsightRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightRecommendationCountAggregateInputType | true
    }

  export interface InsightRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightRecommendation'], meta: { name: 'InsightRecommendation' } }
    /**
     * Find zero or one InsightRecommendation that matches the filter.
     * @param {InsightRecommendationFindUniqueArgs} args - Arguments to find a InsightRecommendation
     * @example
     * // Get one InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightRecommendationFindUniqueArgs>(args: SelectSubset<T, InsightRecommendationFindUniqueArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsightRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightRecommendationFindUniqueOrThrowArgs} args - Arguments to find a InsightRecommendation
     * @example
     * // Get one InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationFindFirstArgs} args - Arguments to find a InsightRecommendation
     * @example
     * // Get one InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightRecommendationFindFirstArgs>(args?: SelectSubset<T, InsightRecommendationFindFirstArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsightRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationFindFirstOrThrowArgs} args - Arguments to find a InsightRecommendation
     * @example
     * // Get one InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsightRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightRecommendations
     * const insightRecommendations = await prisma.insightRecommendation.findMany()
     * 
     * // Get first 10 InsightRecommendations
     * const insightRecommendations = await prisma.insightRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightRecommendationWithIdOnly = await prisma.insightRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightRecommendationFindManyArgs>(args?: SelectSubset<T, InsightRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsightRecommendation.
     * @param {InsightRecommendationCreateArgs} args - Arguments to create a InsightRecommendation.
     * @example
     * // Create one InsightRecommendation
     * const InsightRecommendation = await prisma.insightRecommendation.create({
     *   data: {
     *     // ... data to create a InsightRecommendation
     *   }
     * })
     * 
     */
    create<T extends InsightRecommendationCreateArgs>(args: SelectSubset<T, InsightRecommendationCreateArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsightRecommendations.
     * @param {InsightRecommendationCreateManyArgs} args - Arguments to create many InsightRecommendations.
     * @example
     * // Create many InsightRecommendations
     * const insightRecommendation = await prisma.insightRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightRecommendationCreateManyArgs>(args?: SelectSubset<T, InsightRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightRecommendations and returns the data saved in the database.
     * @param {InsightRecommendationCreateManyAndReturnArgs} args - Arguments to create many InsightRecommendations.
     * @example
     * // Create many InsightRecommendations
     * const insightRecommendation = await prisma.insightRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightRecommendations and only return the `id`
     * const insightRecommendationWithIdOnly = await prisma.insightRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsightRecommendation.
     * @param {InsightRecommendationDeleteArgs} args - Arguments to delete one InsightRecommendation.
     * @example
     * // Delete one InsightRecommendation
     * const InsightRecommendation = await prisma.insightRecommendation.delete({
     *   where: {
     *     // ... filter to delete one InsightRecommendation
     *   }
     * })
     * 
     */
    delete<T extends InsightRecommendationDeleteArgs>(args: SelectSubset<T, InsightRecommendationDeleteArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsightRecommendation.
     * @param {InsightRecommendationUpdateArgs} args - Arguments to update one InsightRecommendation.
     * @example
     * // Update one InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightRecommendationUpdateArgs>(args: SelectSubset<T, InsightRecommendationUpdateArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsightRecommendations.
     * @param {InsightRecommendationDeleteManyArgs} args - Arguments to filter InsightRecommendations to delete.
     * @example
     * // Delete a few InsightRecommendations
     * const { count } = await prisma.insightRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightRecommendationDeleteManyArgs>(args?: SelectSubset<T, InsightRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightRecommendations
     * const insightRecommendation = await prisma.insightRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightRecommendationUpdateManyArgs>(args: SelectSubset<T, InsightRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightRecommendations and returns the data updated in the database.
     * @param {InsightRecommendationUpdateManyAndReturnArgs} args - Arguments to update many InsightRecommendations.
     * @example
     * // Update many InsightRecommendations
     * const insightRecommendation = await prisma.insightRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsightRecommendations and only return the `id`
     * const insightRecommendationWithIdOnly = await prisma.insightRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsightRecommendation.
     * @param {InsightRecommendationUpsertArgs} args - Arguments to update or create a InsightRecommendation.
     * @example
     * // Update or create a InsightRecommendation
     * const insightRecommendation = await prisma.insightRecommendation.upsert({
     *   create: {
     *     // ... data to create a InsightRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends InsightRecommendationUpsertArgs>(args: SelectSubset<T, InsightRecommendationUpsertArgs<ExtArgs>>): Prisma__InsightRecommendationClient<$Result.GetResult<Prisma.$InsightRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsightRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationCountArgs} args - Arguments to filter InsightRecommendations to count.
     * @example
     * // Count the number of InsightRecommendations
     * const count = await prisma.insightRecommendation.count({
     *   where: {
     *     // ... the filter for the InsightRecommendations we want to count
     *   }
     * })
    **/
    count<T extends InsightRecommendationCountArgs>(
      args?: Subset<T, InsightRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightRecommendationAggregateArgs>(args: Subset<T, InsightRecommendationAggregateArgs>): Prisma.PrismaPromise<GetInsightRecommendationAggregateType<T>>

    /**
     * Group by InsightRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: InsightRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightRecommendation model
   */
  readonly fields: InsightRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightRecommendation model
   */
  interface InsightRecommendationFieldRefs {
    readonly id: FieldRef<"InsightRecommendation", 'Int'>
    readonly userId: FieldRef<"InsightRecommendation", 'Int'>
    readonly content: FieldRef<"InsightRecommendation", 'String'>
    readonly sampleDocUrls: FieldRef<"InsightRecommendation", 'String[]'>
    readonly createdAt: FieldRef<"InsightRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightRecommendation findUnique
   */
  export type InsightRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InsightRecommendation to fetch.
     */
    where: InsightRecommendationWhereUniqueInput
  }

  /**
   * InsightRecommendation findUniqueOrThrow
   */
  export type InsightRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InsightRecommendation to fetch.
     */
    where: InsightRecommendationWhereUniqueInput
  }

  /**
   * InsightRecommendation findFirst
   */
  export type InsightRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InsightRecommendation to fetch.
     */
    where?: InsightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightRecommendations to fetch.
     */
    orderBy?: InsightRecommendationOrderByWithRelationInput | InsightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightRecommendations.
     */
    cursor?: InsightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightRecommendations.
     */
    distinct?: InsightRecommendationScalarFieldEnum | InsightRecommendationScalarFieldEnum[]
  }

  /**
   * InsightRecommendation findFirstOrThrow
   */
  export type InsightRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InsightRecommendation to fetch.
     */
    where?: InsightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightRecommendations to fetch.
     */
    orderBy?: InsightRecommendationOrderByWithRelationInput | InsightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightRecommendations.
     */
    cursor?: InsightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightRecommendations.
     */
    distinct?: InsightRecommendationScalarFieldEnum | InsightRecommendationScalarFieldEnum[]
  }

  /**
   * InsightRecommendation findMany
   */
  export type InsightRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InsightRecommendations to fetch.
     */
    where?: InsightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightRecommendations to fetch.
     */
    orderBy?: InsightRecommendationOrderByWithRelationInput | InsightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightRecommendations.
     */
    cursor?: InsightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightRecommendations.
     */
    skip?: number
    distinct?: InsightRecommendationScalarFieldEnum | InsightRecommendationScalarFieldEnum[]
  }

  /**
   * InsightRecommendation create
   */
  export type InsightRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightRecommendation.
     */
    data: XOR<InsightRecommendationCreateInput, InsightRecommendationUncheckedCreateInput>
  }

  /**
   * InsightRecommendation createMany
   */
  export type InsightRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightRecommendations.
     */
    data: InsightRecommendationCreateManyInput | InsightRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightRecommendation createManyAndReturn
   */
  export type InsightRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many InsightRecommendations.
     */
    data: InsightRecommendationCreateManyInput | InsightRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightRecommendation update
   */
  export type InsightRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightRecommendation.
     */
    data: XOR<InsightRecommendationUpdateInput, InsightRecommendationUncheckedUpdateInput>
    /**
     * Choose, which InsightRecommendation to update.
     */
    where: InsightRecommendationWhereUniqueInput
  }

  /**
   * InsightRecommendation updateMany
   */
  export type InsightRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightRecommendations.
     */
    data: XOR<InsightRecommendationUpdateManyMutationInput, InsightRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which InsightRecommendations to update
     */
    where?: InsightRecommendationWhereInput
    /**
     * Limit how many InsightRecommendations to update.
     */
    limit?: number
  }

  /**
   * InsightRecommendation updateManyAndReturn
   */
  export type InsightRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update InsightRecommendations.
     */
    data: XOR<InsightRecommendationUpdateManyMutationInput, InsightRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which InsightRecommendations to update
     */
    where?: InsightRecommendationWhereInput
    /**
     * Limit how many InsightRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightRecommendation upsert
   */
  export type InsightRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightRecommendation to update in case it exists.
     */
    where: InsightRecommendationWhereUniqueInput
    /**
     * In case the InsightRecommendation found by the `where` argument doesn't exist, create a new InsightRecommendation with this data.
     */
    create: XOR<InsightRecommendationCreateInput, InsightRecommendationUncheckedCreateInput>
    /**
     * In case the InsightRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightRecommendationUpdateInput, InsightRecommendationUncheckedUpdateInput>
  }

  /**
   * InsightRecommendation delete
   */
  export type InsightRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
    /**
     * Filter which InsightRecommendation to delete.
     */
    where: InsightRecommendationWhereUniqueInput
  }

  /**
   * InsightRecommendation deleteMany
   */
  export type InsightRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightRecommendations to delete
     */
    where?: InsightRecommendationWhereInput
    /**
     * Limit how many InsightRecommendations to delete.
     */
    limit?: number
  }

  /**
   * InsightRecommendation without action
   */
  export type InsightRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightRecommendation
     */
    select?: InsightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightRecommendation
     */
    omit?: InsightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model CalendarAction
   */

  export type AggregateCalendarAction = {
    _count: CalendarActionCountAggregateOutputType | null
    _avg: CalendarActionAvgAggregateOutputType | null
    _sum: CalendarActionSumAggregateOutputType | null
    _min: CalendarActionMinAggregateOutputType | null
    _max: CalendarActionMaxAggregateOutputType | null
  }

  export type CalendarActionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    createdBy: number | null
  }

  export type CalendarActionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    createdBy: number | null
  }

  export type CalendarActionMinAggregateOutputType = {
    id: number | null
    title: string | null
    userId: number | null
    companyId: number | null
    dueDate: Date | null
    notes: string | null
    status: string | null
    createdBy: number | null
    createdByRole: $Enums.UserRole | null
  }

  export type CalendarActionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    userId: number | null
    companyId: number | null
    dueDate: Date | null
    notes: string | null
    status: string | null
    createdBy: number | null
    createdByRole: $Enums.UserRole | null
  }

  export type CalendarActionCountAggregateOutputType = {
    id: number
    title: number
    userId: number
    companyId: number
    dueDate: number
    notes: number
    status: number
    createdBy: number
    createdByRole: number
    _all: number
  }


  export type CalendarActionAvgAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    createdBy?: true
  }

  export type CalendarActionSumAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    createdBy?: true
  }

  export type CalendarActionMinAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    companyId?: true
    dueDate?: true
    notes?: true
    status?: true
    createdBy?: true
    createdByRole?: true
  }

  export type CalendarActionMaxAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    companyId?: true
    dueDate?: true
    notes?: true
    status?: true
    createdBy?: true
    createdByRole?: true
  }

  export type CalendarActionCountAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    companyId?: true
    dueDate?: true
    notes?: true
    status?: true
    createdBy?: true
    createdByRole?: true
    _all?: true
  }

  export type CalendarActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarAction to aggregate.
     */
    where?: CalendarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarActions to fetch.
     */
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarActions
    **/
    _count?: true | CalendarActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarActionMaxAggregateInputType
  }

  export type GetCalendarActionAggregateType<T extends CalendarActionAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarAction[P]>
      : GetScalarType<T[P], AggregateCalendarAction[P]>
  }




  export type CalendarActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarActionWhereInput
    orderBy?: CalendarActionOrderByWithAggregationInput | CalendarActionOrderByWithAggregationInput[]
    by: CalendarActionScalarFieldEnum[] | CalendarActionScalarFieldEnum
    having?: CalendarActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarActionCountAggregateInputType | true
    _avg?: CalendarActionAvgAggregateInputType
    _sum?: CalendarActionSumAggregateInputType
    _min?: CalendarActionMinAggregateInputType
    _max?: CalendarActionMaxAggregateInputType
  }

  export type CalendarActionGroupByOutputType = {
    id: number
    title: string
    userId: number
    companyId: number
    dueDate: Date
    notes: string | null
    status: string
    createdBy: number | null
    createdByRole: $Enums.UserRole
    _count: CalendarActionCountAggregateOutputType | null
    _avg: CalendarActionAvgAggregateOutputType | null
    _sum: CalendarActionSumAggregateOutputType | null
    _min: CalendarActionMinAggregateOutputType | null
    _max: CalendarActionMaxAggregateOutputType | null
  }

  type GetCalendarActionGroupByPayload<T extends CalendarActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarActionGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarActionGroupByOutputType[P]>
        }
      >
    >


  export type CalendarActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    userId?: boolean
    companyId?: boolean
    dueDate?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdByRole?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["calendarAction"]>

  export type CalendarActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    userId?: boolean
    companyId?: boolean
    dueDate?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdByRole?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["calendarAction"]>

  export type CalendarActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    userId?: boolean
    companyId?: boolean
    dueDate?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdByRole?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["calendarAction"]>

  export type CalendarActionSelectScalar = {
    id?: boolean
    title?: boolean
    userId?: boolean
    companyId?: boolean
    dueDate?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdByRole?: boolean
  }

  export type CalendarActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "userId" | "companyId" | "dueDate" | "notes" | "status" | "createdBy" | "createdByRole", ExtArgs["result"]["calendarAction"]>
  export type CalendarActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }
  export type CalendarActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }
  export type CalendarActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    creator?: boolean | CalendarAction$creatorArgs<ExtArgs>
  }

  export type $CalendarActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarAction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      userId: number
      companyId: number
      dueDate: Date
      notes: string | null
      status: string
      createdBy: number | null
      createdByRole: $Enums.UserRole
    }, ExtArgs["result"]["calendarAction"]>
    composites: {}
  }

  type CalendarActionGetPayload<S extends boolean | null | undefined | CalendarActionDefaultArgs> = $Result.GetResult<Prisma.$CalendarActionPayload, S>

  type CalendarActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarActionCountAggregateInputType | true
    }

  export interface CalendarActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarAction'], meta: { name: 'CalendarAction' } }
    /**
     * Find zero or one CalendarAction that matches the filter.
     * @param {CalendarActionFindUniqueArgs} args - Arguments to find a CalendarAction
     * @example
     * // Get one CalendarAction
     * const calendarAction = await prisma.calendarAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarActionFindUniqueArgs>(args: SelectSubset<T, CalendarActionFindUniqueArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarActionFindUniqueOrThrowArgs} args - Arguments to find a CalendarAction
     * @example
     * // Get one CalendarAction
     * const calendarAction = await prisma.calendarAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarActionFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionFindFirstArgs} args - Arguments to find a CalendarAction
     * @example
     * // Get one CalendarAction
     * const calendarAction = await prisma.calendarAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarActionFindFirstArgs>(args?: SelectSubset<T, CalendarActionFindFirstArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionFindFirstOrThrowArgs} args - Arguments to find a CalendarAction
     * @example
     * // Get one CalendarAction
     * const calendarAction = await prisma.calendarAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarActionFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarActions
     * const calendarActions = await prisma.calendarAction.findMany()
     * 
     * // Get first 10 CalendarActions
     * const calendarActions = await prisma.calendarAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarActionWithIdOnly = await prisma.calendarAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarActionFindManyArgs>(args?: SelectSubset<T, CalendarActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarAction.
     * @param {CalendarActionCreateArgs} args - Arguments to create a CalendarAction.
     * @example
     * // Create one CalendarAction
     * const CalendarAction = await prisma.calendarAction.create({
     *   data: {
     *     // ... data to create a CalendarAction
     *   }
     * })
     * 
     */
    create<T extends CalendarActionCreateArgs>(args: SelectSubset<T, CalendarActionCreateArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarActions.
     * @param {CalendarActionCreateManyArgs} args - Arguments to create many CalendarActions.
     * @example
     * // Create many CalendarActions
     * const calendarAction = await prisma.calendarAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarActionCreateManyArgs>(args?: SelectSubset<T, CalendarActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarActions and returns the data saved in the database.
     * @param {CalendarActionCreateManyAndReturnArgs} args - Arguments to create many CalendarActions.
     * @example
     * // Create many CalendarActions
     * const calendarAction = await prisma.calendarAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarActions and only return the `id`
     * const calendarActionWithIdOnly = await prisma.calendarAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarActionCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarAction.
     * @param {CalendarActionDeleteArgs} args - Arguments to delete one CalendarAction.
     * @example
     * // Delete one CalendarAction
     * const CalendarAction = await prisma.calendarAction.delete({
     *   where: {
     *     // ... filter to delete one CalendarAction
     *   }
     * })
     * 
     */
    delete<T extends CalendarActionDeleteArgs>(args: SelectSubset<T, CalendarActionDeleteArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarAction.
     * @param {CalendarActionUpdateArgs} args - Arguments to update one CalendarAction.
     * @example
     * // Update one CalendarAction
     * const calendarAction = await prisma.calendarAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarActionUpdateArgs>(args: SelectSubset<T, CalendarActionUpdateArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarActions.
     * @param {CalendarActionDeleteManyArgs} args - Arguments to filter CalendarActions to delete.
     * @example
     * // Delete a few CalendarActions
     * const { count } = await prisma.calendarAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarActionDeleteManyArgs>(args?: SelectSubset<T, CalendarActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarActions
     * const calendarAction = await prisma.calendarAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarActionUpdateManyArgs>(args: SelectSubset<T, CalendarActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarActions and returns the data updated in the database.
     * @param {CalendarActionUpdateManyAndReturnArgs} args - Arguments to update many CalendarActions.
     * @example
     * // Update many CalendarActions
     * const calendarAction = await prisma.calendarAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarActions and only return the `id`
     * const calendarActionWithIdOnly = await prisma.calendarAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarActionUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarAction.
     * @param {CalendarActionUpsertArgs} args - Arguments to update or create a CalendarAction.
     * @example
     * // Update or create a CalendarAction
     * const calendarAction = await prisma.calendarAction.upsert({
     *   create: {
     *     // ... data to create a CalendarAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarAction we want to update
     *   }
     * })
     */
    upsert<T extends CalendarActionUpsertArgs>(args: SelectSubset<T, CalendarActionUpsertArgs<ExtArgs>>): Prisma__CalendarActionClient<$Result.GetResult<Prisma.$CalendarActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionCountArgs} args - Arguments to filter CalendarActions to count.
     * @example
     * // Count the number of CalendarActions
     * const count = await prisma.calendarAction.count({
     *   where: {
     *     // ... the filter for the CalendarActions we want to count
     *   }
     * })
    **/
    count<T extends CalendarActionCountArgs>(
      args?: Subset<T, CalendarActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarActionAggregateArgs>(args: Subset<T, CalendarActionAggregateArgs>): Prisma.PrismaPromise<GetCalendarActionAggregateType<T>>

    /**
     * Group by CalendarAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarActionGroupByArgs['orderBy'] }
        : { orderBy?: CalendarActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarAction model
   */
  readonly fields: CalendarActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends CalendarAction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, CalendarAction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarAction model
   */
  interface CalendarActionFieldRefs {
    readonly id: FieldRef<"CalendarAction", 'Int'>
    readonly title: FieldRef<"CalendarAction", 'String'>
    readonly userId: FieldRef<"CalendarAction", 'Int'>
    readonly companyId: FieldRef<"CalendarAction", 'Int'>
    readonly dueDate: FieldRef<"CalendarAction", 'DateTime'>
    readonly notes: FieldRef<"CalendarAction", 'String'>
    readonly status: FieldRef<"CalendarAction", 'String'>
    readonly createdBy: FieldRef<"CalendarAction", 'Int'>
    readonly createdByRole: FieldRef<"CalendarAction", 'UserRole'>
  }
    

  // Custom InputTypes
  /**
   * CalendarAction findUnique
   */
  export type CalendarActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAction to fetch.
     */
    where: CalendarActionWhereUniqueInput
  }

  /**
   * CalendarAction findUniqueOrThrow
   */
  export type CalendarActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAction to fetch.
     */
    where: CalendarActionWhereUniqueInput
  }

  /**
   * CalendarAction findFirst
   */
  export type CalendarActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAction to fetch.
     */
    where?: CalendarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarActions to fetch.
     */
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarActions.
     */
    cursor?: CalendarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarActions.
     */
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * CalendarAction findFirstOrThrow
   */
  export type CalendarActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter, which CalendarAction to fetch.
     */
    where?: CalendarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarActions to fetch.
     */
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarActions.
     */
    cursor?: CalendarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarActions.
     */
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * CalendarAction findMany
   */
  export type CalendarActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter, which CalendarActions to fetch.
     */
    where?: CalendarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarActions to fetch.
     */
    orderBy?: CalendarActionOrderByWithRelationInput | CalendarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarActions.
     */
    cursor?: CalendarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarActions.
     */
    skip?: number
    distinct?: CalendarActionScalarFieldEnum | CalendarActionScalarFieldEnum[]
  }

  /**
   * CalendarAction create
   */
  export type CalendarActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarAction.
     */
    data: XOR<CalendarActionCreateInput, CalendarActionUncheckedCreateInput>
  }

  /**
   * CalendarAction createMany
   */
  export type CalendarActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarActions.
     */
    data: CalendarActionCreateManyInput | CalendarActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarAction createManyAndReturn
   */
  export type CalendarActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarActions.
     */
    data: CalendarActionCreateManyInput | CalendarActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarAction update
   */
  export type CalendarActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarAction.
     */
    data: XOR<CalendarActionUpdateInput, CalendarActionUncheckedUpdateInput>
    /**
     * Choose, which CalendarAction to update.
     */
    where: CalendarActionWhereUniqueInput
  }

  /**
   * CalendarAction updateMany
   */
  export type CalendarActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarActions.
     */
    data: XOR<CalendarActionUpdateManyMutationInput, CalendarActionUncheckedUpdateManyInput>
    /**
     * Filter which CalendarActions to update
     */
    where?: CalendarActionWhereInput
    /**
     * Limit how many CalendarActions to update.
     */
    limit?: number
  }

  /**
   * CalendarAction updateManyAndReturn
   */
  export type CalendarActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * The data used to update CalendarActions.
     */
    data: XOR<CalendarActionUpdateManyMutationInput, CalendarActionUncheckedUpdateManyInput>
    /**
     * Filter which CalendarActions to update
     */
    where?: CalendarActionWhereInput
    /**
     * Limit how many CalendarActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarAction upsert
   */
  export type CalendarActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarAction to update in case it exists.
     */
    where: CalendarActionWhereUniqueInput
    /**
     * In case the CalendarAction found by the `where` argument doesn't exist, create a new CalendarAction with this data.
     */
    create: XOR<CalendarActionCreateInput, CalendarActionUncheckedCreateInput>
    /**
     * In case the CalendarAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarActionUpdateInput, CalendarActionUncheckedUpdateInput>
  }

  /**
   * CalendarAction delete
   */
  export type CalendarActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
    /**
     * Filter which CalendarAction to delete.
     */
    where: CalendarActionWhereUniqueInput
  }

  /**
   * CalendarAction deleteMany
   */
  export type CalendarActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarActions to delete
     */
    where?: CalendarActionWhereInput
    /**
     * Limit how many CalendarActions to delete.
     */
    limit?: number
  }

  /**
   * CalendarAction.creator
   */
  export type CalendarAction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CalendarAction without action
   */
  export type CalendarActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarAction
     */
    select?: CalendarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarAction
     */
    omit?: CalendarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarActionInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    sentAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    sentAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    sentAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    sentAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    sentAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    sentAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: string
    sentAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    sentAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    sentAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    sentAt?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    sentAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "sentAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      receiver: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number
      content: string
      sentAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly senderId: FieldRef<"ChatMessage", 'Int'>
    readonly receiverId: FieldRef<"ChatMessage", 'Int'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly sentAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model DashboardState
   */

  export type AggregateDashboardState = {
    _count: DashboardStateCountAggregateOutputType | null
    _avg: DashboardStateAvgAggregateOutputType | null
    _sum: DashboardStateSumAggregateOutputType | null
    _min: DashboardStateMinAggregateOutputType | null
    _max: DashboardStateMaxAggregateOutputType | null
  }

  export type DashboardStateAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type DashboardStateSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type DashboardStateMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    step: string | null
    completedAt: Date | null
  }

  export type DashboardStateMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    step: string | null
    completedAt: Date | null
  }

  export type DashboardStateCountAggregateOutputType = {
    id: number
    companyId: number
    step: number
    completedAt: number
    _all: number
  }


  export type DashboardStateAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type DashboardStateSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type DashboardStateMinAggregateInputType = {
    id?: true
    companyId?: true
    step?: true
    completedAt?: true
  }

  export type DashboardStateMaxAggregateInputType = {
    id?: true
    companyId?: true
    step?: true
    completedAt?: true
  }

  export type DashboardStateCountAggregateInputType = {
    id?: true
    companyId?: true
    step?: true
    completedAt?: true
    _all?: true
  }

  export type DashboardStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardState to aggregate.
     */
    where?: DashboardStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardStates to fetch.
     */
    orderBy?: DashboardStateOrderByWithRelationInput | DashboardStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardStates
    **/
    _count?: true | DashboardStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardStateMaxAggregateInputType
  }

  export type GetDashboardStateAggregateType<T extends DashboardStateAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardState[P]>
      : GetScalarType<T[P], AggregateDashboardState[P]>
  }




  export type DashboardStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardStateWhereInput
    orderBy?: DashboardStateOrderByWithAggregationInput | DashboardStateOrderByWithAggregationInput[]
    by: DashboardStateScalarFieldEnum[] | DashboardStateScalarFieldEnum
    having?: DashboardStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardStateCountAggregateInputType | true
    _avg?: DashboardStateAvgAggregateInputType
    _sum?: DashboardStateSumAggregateInputType
    _min?: DashboardStateMinAggregateInputType
    _max?: DashboardStateMaxAggregateInputType
  }

  export type DashboardStateGroupByOutputType = {
    id: number
    companyId: number
    step: string
    completedAt: Date | null
    _count: DashboardStateCountAggregateOutputType | null
    _avg: DashboardStateAvgAggregateOutputType | null
    _sum: DashboardStateSumAggregateOutputType | null
    _min: DashboardStateMinAggregateOutputType | null
    _max: DashboardStateMaxAggregateOutputType | null
  }

  type GetDashboardStateGroupByPayload<T extends DashboardStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardStateGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardStateGroupByOutputType[P]>
        }
      >
    >


  export type DashboardStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    step?: boolean
    completedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardState"]>

  export type DashboardStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    step?: boolean
    completedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardState"]>

  export type DashboardStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    step?: boolean
    completedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardState"]>

  export type DashboardStateSelectScalar = {
    id?: boolean
    companyId?: boolean
    step?: boolean
    completedAt?: boolean
  }

  export type DashboardStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "step" | "completedAt", ExtArgs["result"]["dashboardState"]>
  export type DashboardStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DashboardStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DashboardStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DashboardStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardState"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      step: string
      completedAt: Date | null
    }, ExtArgs["result"]["dashboardState"]>
    composites: {}
  }

  type DashboardStateGetPayload<S extends boolean | null | undefined | DashboardStateDefaultArgs> = $Result.GetResult<Prisma.$DashboardStatePayload, S>

  type DashboardStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardStateCountAggregateInputType | true
    }

  export interface DashboardStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardState'], meta: { name: 'DashboardState' } }
    /**
     * Find zero or one DashboardState that matches the filter.
     * @param {DashboardStateFindUniqueArgs} args - Arguments to find a DashboardState
     * @example
     * // Get one DashboardState
     * const dashboardState = await prisma.dashboardState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardStateFindUniqueArgs>(args: SelectSubset<T, DashboardStateFindUniqueArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardStateFindUniqueOrThrowArgs} args - Arguments to find a DashboardState
     * @example
     * // Get one DashboardState
     * const dashboardState = await prisma.dashboardState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardStateFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateFindFirstArgs} args - Arguments to find a DashboardState
     * @example
     * // Get one DashboardState
     * const dashboardState = await prisma.dashboardState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardStateFindFirstArgs>(args?: SelectSubset<T, DashboardStateFindFirstArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateFindFirstOrThrowArgs} args - Arguments to find a DashboardState
     * @example
     * // Get one DashboardState
     * const dashboardState = await prisma.dashboardState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardStateFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardStates
     * const dashboardStates = await prisma.dashboardState.findMany()
     * 
     * // Get first 10 DashboardStates
     * const dashboardStates = await prisma.dashboardState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardStateWithIdOnly = await prisma.dashboardState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardStateFindManyArgs>(args?: SelectSubset<T, DashboardStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardState.
     * @param {DashboardStateCreateArgs} args - Arguments to create a DashboardState.
     * @example
     * // Create one DashboardState
     * const DashboardState = await prisma.dashboardState.create({
     *   data: {
     *     // ... data to create a DashboardState
     *   }
     * })
     * 
     */
    create<T extends DashboardStateCreateArgs>(args: SelectSubset<T, DashboardStateCreateArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardStates.
     * @param {DashboardStateCreateManyArgs} args - Arguments to create many DashboardStates.
     * @example
     * // Create many DashboardStates
     * const dashboardState = await prisma.dashboardState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardStateCreateManyArgs>(args?: SelectSubset<T, DashboardStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardStates and returns the data saved in the database.
     * @param {DashboardStateCreateManyAndReturnArgs} args - Arguments to create many DashboardStates.
     * @example
     * // Create many DashboardStates
     * const dashboardState = await prisma.dashboardState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardStates and only return the `id`
     * const dashboardStateWithIdOnly = await prisma.dashboardState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardStateCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardState.
     * @param {DashboardStateDeleteArgs} args - Arguments to delete one DashboardState.
     * @example
     * // Delete one DashboardState
     * const DashboardState = await prisma.dashboardState.delete({
     *   where: {
     *     // ... filter to delete one DashboardState
     *   }
     * })
     * 
     */
    delete<T extends DashboardStateDeleteArgs>(args: SelectSubset<T, DashboardStateDeleteArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardState.
     * @param {DashboardStateUpdateArgs} args - Arguments to update one DashboardState.
     * @example
     * // Update one DashboardState
     * const dashboardState = await prisma.dashboardState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardStateUpdateArgs>(args: SelectSubset<T, DashboardStateUpdateArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardStates.
     * @param {DashboardStateDeleteManyArgs} args - Arguments to filter DashboardStates to delete.
     * @example
     * // Delete a few DashboardStates
     * const { count } = await prisma.dashboardState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardStateDeleteManyArgs>(args?: SelectSubset<T, DashboardStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardStates
     * const dashboardState = await prisma.dashboardState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardStateUpdateManyArgs>(args: SelectSubset<T, DashboardStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardStates and returns the data updated in the database.
     * @param {DashboardStateUpdateManyAndReturnArgs} args - Arguments to update many DashboardStates.
     * @example
     * // Update many DashboardStates
     * const dashboardState = await prisma.dashboardState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardStates and only return the `id`
     * const dashboardStateWithIdOnly = await prisma.dashboardState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardStateUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardState.
     * @param {DashboardStateUpsertArgs} args - Arguments to update or create a DashboardState.
     * @example
     * // Update or create a DashboardState
     * const dashboardState = await prisma.dashboardState.upsert({
     *   create: {
     *     // ... data to create a DashboardState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardState we want to update
     *   }
     * })
     */
    upsert<T extends DashboardStateUpsertArgs>(args: SelectSubset<T, DashboardStateUpsertArgs<ExtArgs>>): Prisma__DashboardStateClient<$Result.GetResult<Prisma.$DashboardStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateCountArgs} args - Arguments to filter DashboardStates to count.
     * @example
     * // Count the number of DashboardStates
     * const count = await prisma.dashboardState.count({
     *   where: {
     *     // ... the filter for the DashboardStates we want to count
     *   }
     * })
    **/
    count<T extends DashboardStateCountArgs>(
      args?: Subset<T, DashboardStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardStateAggregateArgs>(args: Subset<T, DashboardStateAggregateArgs>): Prisma.PrismaPromise<GetDashboardStateAggregateType<T>>

    /**
     * Group by DashboardState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardStateGroupByArgs['orderBy'] }
        : { orderBy?: DashboardStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardState model
   */
  readonly fields: DashboardStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardState model
   */
  interface DashboardStateFieldRefs {
    readonly id: FieldRef<"DashboardState", 'Int'>
    readonly companyId: FieldRef<"DashboardState", 'Int'>
    readonly step: FieldRef<"DashboardState", 'String'>
    readonly completedAt: FieldRef<"DashboardState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardState findUnique
   */
  export type DashboardStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter, which DashboardState to fetch.
     */
    where: DashboardStateWhereUniqueInput
  }

  /**
   * DashboardState findUniqueOrThrow
   */
  export type DashboardStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter, which DashboardState to fetch.
     */
    where: DashboardStateWhereUniqueInput
  }

  /**
   * DashboardState findFirst
   */
  export type DashboardStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter, which DashboardState to fetch.
     */
    where?: DashboardStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardStates to fetch.
     */
    orderBy?: DashboardStateOrderByWithRelationInput | DashboardStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardStates.
     */
    cursor?: DashboardStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardStates.
     */
    distinct?: DashboardStateScalarFieldEnum | DashboardStateScalarFieldEnum[]
  }

  /**
   * DashboardState findFirstOrThrow
   */
  export type DashboardStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter, which DashboardState to fetch.
     */
    where?: DashboardStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardStates to fetch.
     */
    orderBy?: DashboardStateOrderByWithRelationInput | DashboardStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardStates.
     */
    cursor?: DashboardStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardStates.
     */
    distinct?: DashboardStateScalarFieldEnum | DashboardStateScalarFieldEnum[]
  }

  /**
   * DashboardState findMany
   */
  export type DashboardStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter, which DashboardStates to fetch.
     */
    where?: DashboardStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardStates to fetch.
     */
    orderBy?: DashboardStateOrderByWithRelationInput | DashboardStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardStates.
     */
    cursor?: DashboardStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardStates.
     */
    skip?: number
    distinct?: DashboardStateScalarFieldEnum | DashboardStateScalarFieldEnum[]
  }

  /**
   * DashboardState create
   */
  export type DashboardStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardState.
     */
    data: XOR<DashboardStateCreateInput, DashboardStateUncheckedCreateInput>
  }

  /**
   * DashboardState createMany
   */
  export type DashboardStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardStates.
     */
    data: DashboardStateCreateManyInput | DashboardStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardState createManyAndReturn
   */
  export type DashboardStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardStates.
     */
    data: DashboardStateCreateManyInput | DashboardStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardState update
   */
  export type DashboardStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardState.
     */
    data: XOR<DashboardStateUpdateInput, DashboardStateUncheckedUpdateInput>
    /**
     * Choose, which DashboardState to update.
     */
    where: DashboardStateWhereUniqueInput
  }

  /**
   * DashboardState updateMany
   */
  export type DashboardStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardStates.
     */
    data: XOR<DashboardStateUpdateManyMutationInput, DashboardStateUncheckedUpdateManyInput>
    /**
     * Filter which DashboardStates to update
     */
    where?: DashboardStateWhereInput
    /**
     * Limit how many DashboardStates to update.
     */
    limit?: number
  }

  /**
   * DashboardState updateManyAndReturn
   */
  export type DashboardStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * The data used to update DashboardStates.
     */
    data: XOR<DashboardStateUpdateManyMutationInput, DashboardStateUncheckedUpdateManyInput>
    /**
     * Filter which DashboardStates to update
     */
    where?: DashboardStateWhereInput
    /**
     * Limit how many DashboardStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardState upsert
   */
  export type DashboardStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardState to update in case it exists.
     */
    where: DashboardStateWhereUniqueInput
    /**
     * In case the DashboardState found by the `where` argument doesn't exist, create a new DashboardState with this data.
     */
    create: XOR<DashboardStateCreateInput, DashboardStateUncheckedCreateInput>
    /**
     * In case the DashboardState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardStateUpdateInput, DashboardStateUncheckedUpdateInput>
  }

  /**
   * DashboardState delete
   */
  export type DashboardStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
    /**
     * Filter which DashboardState to delete.
     */
    where: DashboardStateWhereUniqueInput
  }

  /**
   * DashboardState deleteMany
   */
  export type DashboardStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardStates to delete
     */
    where?: DashboardStateWhereInput
    /**
     * Limit how many DashboardStates to delete.
     */
    limit?: number
  }

  /**
   * DashboardState without action
   */
  export type DashboardStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardState
     */
    select?: DashboardStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardState
     */
    omit?: DashboardStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardStateInclude<ExtArgs> | null
  }


  /**
   * Model RoleAssignment
   */

  export type AggregateRoleAssignment = {
    _count: RoleAssignmentCountAggregateOutputType | null
    _avg: RoleAssignmentAvgAggregateOutputType | null
    _sum: RoleAssignmentSumAggregateOutputType | null
    _min: RoleAssignmentMinAggregateOutputType | null
    _max: RoleAssignmentMaxAggregateOutputType | null
  }

  export type RoleAssignmentAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    companyId: number | null
  }

  export type RoleAssignmentSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    companyId: number | null
  }

  export type RoleAssignmentMinAggregateOutputType = {
    id: number | null
    agentId: number | null
    companyId: number | null
    role: $Enums.UserRole | null
    assignedAt: Date | null
  }

  export type RoleAssignmentMaxAggregateOutputType = {
    id: number | null
    agentId: number | null
    companyId: number | null
    role: $Enums.UserRole | null
    assignedAt: Date | null
  }

  export type RoleAssignmentCountAggregateOutputType = {
    id: number
    agentId: number
    companyId: number
    role: number
    assignedAt: number
    _all: number
  }


  export type RoleAssignmentAvgAggregateInputType = {
    id?: true
    agentId?: true
    companyId?: true
  }

  export type RoleAssignmentSumAggregateInputType = {
    id?: true
    agentId?: true
    companyId?: true
  }

  export type RoleAssignmentMinAggregateInputType = {
    id?: true
    agentId?: true
    companyId?: true
    role?: true
    assignedAt?: true
  }

  export type RoleAssignmentMaxAggregateInputType = {
    id?: true
    agentId?: true
    companyId?: true
    role?: true
    assignedAt?: true
  }

  export type RoleAssignmentCountAggregateInputType = {
    id?: true
    agentId?: true
    companyId?: true
    role?: true
    assignedAt?: true
    _all?: true
  }

  export type RoleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssignment to aggregate.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleAssignments
    **/
    _count?: true | RoleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleAssignmentMaxAggregateInputType
  }

  export type GetRoleAssignmentAggregateType<T extends RoleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleAssignment[P]>
      : GetScalarType<T[P], AggregateRoleAssignment[P]>
  }




  export type RoleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithAggregationInput | RoleAssignmentOrderByWithAggregationInput[]
    by: RoleAssignmentScalarFieldEnum[] | RoleAssignmentScalarFieldEnum
    having?: RoleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleAssignmentCountAggregateInputType | true
    _avg?: RoleAssignmentAvgAggregateInputType
    _sum?: RoleAssignmentSumAggregateInputType
    _min?: RoleAssignmentMinAggregateInputType
    _max?: RoleAssignmentMaxAggregateInputType
  }

  export type RoleAssignmentGroupByOutputType = {
    id: number
    agentId: number
    companyId: number
    role: $Enums.UserRole
    assignedAt: Date
    _count: RoleAssignmentCountAggregateOutputType | null
    _avg: RoleAssignmentAvgAggregateOutputType | null
    _sum: RoleAssignmentSumAggregateOutputType | null
    _min: RoleAssignmentMinAggregateOutputType | null
    _max: RoleAssignmentMaxAggregateOutputType | null
  }

  type GetRoleAssignmentGroupByPayload<T extends RoleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], RoleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type RoleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    companyId?: boolean
    role?: boolean
    assignedAt?: boolean
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    companyId?: boolean
    role?: boolean
    assignedAt?: boolean
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    companyId?: boolean
    role?: boolean
    assignedAt?: boolean
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectScalar = {
    id?: boolean
    agentId?: boolean
    companyId?: boolean
    role?: boolean
    assignedAt?: boolean
  }

  export type RoleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "companyId" | "role" | "assignedAt", ExtArgs["result"]["roleAssignment"]>
  export type RoleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type RoleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type RoleAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $RoleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleAssignment"
    objects: {
      agent: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agentId: number
      companyId: number
      role: $Enums.UserRole
      assignedAt: Date
    }, ExtArgs["result"]["roleAssignment"]>
    composites: {}
  }

  type RoleAssignmentGetPayload<S extends boolean | null | undefined | RoleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$RoleAssignmentPayload, S>

  type RoleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleAssignmentCountAggregateInputType | true
    }

  export interface RoleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleAssignment'], meta: { name: 'RoleAssignment' } }
    /**
     * Find zero or one RoleAssignment that matches the filter.
     * @param {RoleAssignmentFindUniqueArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleAssignmentFindUniqueArgs>(args: SelectSubset<T, RoleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindFirstArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleAssignmentFindFirstArgs>(args?: SelectSubset<T, RoleAssignmentFindFirstArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindFirstOrThrowArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleAssignments
     * const roleAssignments = await prisma.roleAssignment.findMany()
     * 
     * // Get first 10 RoleAssignments
     * const roleAssignments = await prisma.roleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleAssignmentFindManyArgs>(args?: SelectSubset<T, RoleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleAssignment.
     * @param {RoleAssignmentCreateArgs} args - Arguments to create a RoleAssignment.
     * @example
     * // Create one RoleAssignment
     * const RoleAssignment = await prisma.roleAssignment.create({
     *   data: {
     *     // ... data to create a RoleAssignment
     *   }
     * })
     * 
     */
    create<T extends RoleAssignmentCreateArgs>(args: SelectSubset<T, RoleAssignmentCreateArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleAssignments.
     * @param {RoleAssignmentCreateManyArgs} args - Arguments to create many RoleAssignments.
     * @example
     * // Create many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleAssignmentCreateManyArgs>(args?: SelectSubset<T, RoleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleAssignments and returns the data saved in the database.
     * @param {RoleAssignmentCreateManyAndReturnArgs} args - Arguments to create many RoleAssignments.
     * @example
     * // Create many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleAssignments and only return the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleAssignment.
     * @param {RoleAssignmentDeleteArgs} args - Arguments to delete one RoleAssignment.
     * @example
     * // Delete one RoleAssignment
     * const RoleAssignment = await prisma.roleAssignment.delete({
     *   where: {
     *     // ... filter to delete one RoleAssignment
     *   }
     * })
     * 
     */
    delete<T extends RoleAssignmentDeleteArgs>(args: SelectSubset<T, RoleAssignmentDeleteArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleAssignment.
     * @param {RoleAssignmentUpdateArgs} args - Arguments to update one RoleAssignment.
     * @example
     * // Update one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleAssignmentUpdateArgs>(args: SelectSubset<T, RoleAssignmentUpdateArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleAssignments.
     * @param {RoleAssignmentDeleteManyArgs} args - Arguments to filter RoleAssignments to delete.
     * @example
     * // Delete a few RoleAssignments
     * const { count } = await prisma.roleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleAssignmentDeleteManyArgs>(args?: SelectSubset<T, RoleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleAssignmentUpdateManyArgs>(args: SelectSubset<T, RoleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssignments and returns the data updated in the database.
     * @param {RoleAssignmentUpdateManyAndReturnArgs} args - Arguments to update many RoleAssignments.
     * @example
     * // Update many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleAssignments and only return the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleAssignment.
     * @param {RoleAssignmentUpsertArgs} args - Arguments to update or create a RoleAssignment.
     * @example
     * // Update or create a RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.upsert({
     *   create: {
     *     // ... data to create a RoleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends RoleAssignmentUpsertArgs>(args: SelectSubset<T, RoleAssignmentUpsertArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentCountArgs} args - Arguments to filter RoleAssignments to count.
     * @example
     * // Count the number of RoleAssignments
     * const count = await prisma.roleAssignment.count({
     *   where: {
     *     // ... the filter for the RoleAssignments we want to count
     *   }
     * })
    **/
    count<T extends RoleAssignmentCountArgs>(
      args?: Subset<T, RoleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAssignmentAggregateArgs>(args: Subset<T, RoleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetRoleAssignmentAggregateType<T>>

    /**
     * Group by RoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: RoleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleAssignment model
   */
  readonly fields: RoleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleAssignment model
   */
  interface RoleAssignmentFieldRefs {
    readonly id: FieldRef<"RoleAssignment", 'Int'>
    readonly agentId: FieldRef<"RoleAssignment", 'Int'>
    readonly companyId: FieldRef<"RoleAssignment", 'Int'>
    readonly role: FieldRef<"RoleAssignment", 'UserRole'>
    readonly assignedAt: FieldRef<"RoleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleAssignment findUnique
   */
  export type RoleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment findUniqueOrThrow
   */
  export type RoleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment findFirst
   */
  export type RoleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssignments.
     */
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment findFirstOrThrow
   */
  export type RoleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssignments.
     */
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment findMany
   */
  export type RoleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignments to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment create
   */
  export type RoleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleAssignment.
     */
    data: XOR<RoleAssignmentCreateInput, RoleAssignmentUncheckedCreateInput>
  }

  /**
   * RoleAssignment createMany
   */
  export type RoleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleAssignments.
     */
    data: RoleAssignmentCreateManyInput | RoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleAssignment createManyAndReturn
   */
  export type RoleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many RoleAssignments.
     */
    data: RoleAssignmentCreateManyInput | RoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssignment update
   */
  export type RoleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleAssignment.
     */
    data: XOR<RoleAssignmentUpdateInput, RoleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which RoleAssignment to update.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment updateMany
   */
  export type RoleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleAssignments.
     */
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssignments to update
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to update.
     */
    limit?: number
  }

  /**
   * RoleAssignment updateManyAndReturn
   */
  export type RoleAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update RoleAssignments.
     */
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssignments to update
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssignment upsert
   */
  export type RoleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleAssignment to update in case it exists.
     */
    where: RoleAssignmentWhereUniqueInput
    /**
     * In case the RoleAssignment found by the `where` argument doesn't exist, create a new RoleAssignment with this data.
     */
    create: XOR<RoleAssignmentCreateInput, RoleAssignmentUncheckedCreateInput>
    /**
     * In case the RoleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleAssignmentUpdateInput, RoleAssignmentUncheckedUpdateInput>
  }

  /**
   * RoleAssignment delete
   */
  export type RoleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which RoleAssignment to delete.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment deleteMany
   */
  export type RoleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssignments to delete
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to delete.
     */
    limit?: number
  }

  /**
   * RoleAssignment without action
   */
  export type RoleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
    views: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: number | null
    views: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: string | null
    createdAt: Date | null
    publishedAt: Date | null
    imagePath: string | null
    views: number | null
    hashtag: string | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    status: string | null
    createdAt: Date | null
    publishedAt: Date | null
    imagePath: string | null
    views: number | null
    hashtag: string | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    title: number
    content: number
    status: number
    createdAt: number
    publishedAt: number
    imagePath: number
    views: number
    hashtag: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    id?: true
    views?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
    views?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    createdAt?: true
    publishedAt?: true
    imagePath?: true
    views?: true
    hashtag?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    createdAt?: true
    publishedAt?: true
    imagePath?: true
    views?: true
    hashtag?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    status?: true
    createdAt?: true
    publishedAt?: true
    imagePath?: true
    views?: true
    hashtag?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: number
    title: string
    content: string
    status: string
    createdAt: Date
    publishedAt: Date
    imagePath: string
    views: number
    hashtag: string
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    publishedAt?: boolean
    imagePath?: boolean
    views?: boolean
    hashtag?: boolean
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    publishedAt?: boolean
    imagePath?: boolean
    views?: boolean
    hashtag?: boolean
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    publishedAt?: boolean
    imagePath?: boolean
    views?: boolean
    hashtag?: boolean
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    createdAt?: boolean
    publishedAt?: boolean
    imagePath?: boolean
    views?: boolean
    hashtag?: boolean
  }

  export type ArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "status" | "createdAt" | "publishedAt" | "imagePath" | "views" | "hashtag", ExtArgs["result"]["article"]>

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      status: string
      createdAt: Date
      publishedAt: Date
      imagePath: string
      views: number
      hashtag: string
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleFindManyArgs>(args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends ArticleCreateArgs>(args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCreateManyArgs>(args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {ArticleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends ArticleDeleteArgs>(args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleUpdateArgs>(args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleDeleteManyArgs>(args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleUpdateManyArgs>(args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles and returns the data updated in the database.
     * @param {ArticleUpdateManyAndReturnArgs} args - Arguments to update many Articles.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Article model
   */
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'Int'>
    readonly title: FieldRef<"Article", 'String'>
    readonly content: FieldRef<"Article", 'String'>
    readonly status: FieldRef<"Article", 'String'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly publishedAt: FieldRef<"Article", 'DateTime'>
    readonly imagePath: FieldRef<"Article", 'String'>
    readonly views: FieldRef<"Article", 'Int'>
    readonly hashtag: FieldRef<"Article", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article createManyAndReturn
   */
  export type ArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
  }

  /**
   * Article updateManyAndReturn
   */
  export type ArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to delete.
     */
    limit?: number
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
  }


  /**
   * Model ContactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactUsSumAggregateOutputType = {
    id: number | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    details: string | null
    status: string | null
    ticketUpdate: string | null
    createdAt: Date | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    details: string | null
    status: string | null
    ticketUpdate: string | null
    createdAt: Date | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    details: number
    status: number
    ticketUpdate: number
    createdAt: number
    _all: number
  }


  export type ContactUsAvgAggregateInputType = {
    id?: true
  }

  export type ContactUsSumAggregateInputType = {
    id?: true
  }

  export type ContactUsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    details?: true
    status?: true
    ticketUpdate?: true
    createdAt?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    details?: true
    status?: true
    ticketUpdate?: true
    createdAt?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    details?: true
    status?: true
    ticketUpdate?: true
    createdAt?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactUsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactUsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithAggregationInput | ContactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _avg?: ContactUsAvgAggregateInputType
    _sum?: ContactUsSumAggregateInputType
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    subject: string
    details: string
    status: string
    ticketUpdate: string
    createdAt: Date
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    details?: boolean
    status?: boolean
    ticketUpdate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    details?: boolean
    status?: boolean
    ticketUpdate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    details?: boolean
    status?: boolean
    ticketUpdate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactUs"]>

  export type ContactUsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    details?: boolean
    status?: boolean
    ticketUpdate?: boolean
    createdAt?: boolean
  }

  export type ContactUsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "subject" | "details" | "status" | "ticketUpdate" | "createdAt", ExtArgs["result"]["contactUs"]>

  export type $ContactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      subject: string
      details: string
      status: string
      ticketUpdate: string
      createdAt: Date
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }

  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsDefaultArgs> = $Result.GetResult<Prisma.$ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactUsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactUsFindUniqueArgs>(args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactUs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactUsFindFirstArgs>(args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactUsFindManyArgs>(args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
     */
    create<T extends ContactUsCreateArgs>(args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contactuses.
     * @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactUsCreateManyArgs>(args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contactuses and returns the data saved in the database.
     * @param {ContactUsCreateManyAndReturnArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contactuses and only return the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactUsCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactUsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
     */
    delete<T extends ContactUsDeleteArgs>(args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUsUpdateArgs>(args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactUsDeleteManyArgs>(args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUsUpdateManyArgs>(args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses and returns the data updated in the database.
     * @param {ContactUsUpdateManyAndReturnArgs} args - Arguments to update many Contactuses.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contactuses and only return the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUsUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
     */
    upsert<T extends ContactUsUpsertArgs>(args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUs model
   */
  readonly fields: ContactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactUs model
   */
  interface ContactUsFieldRefs {
    readonly id: FieldRef<"ContactUs", 'Int'>
    readonly name: FieldRef<"ContactUs", 'String'>
    readonly email: FieldRef<"ContactUs", 'String'>
    readonly phone: FieldRef<"ContactUs", 'String'>
    readonly subject: FieldRef<"ContactUs", 'String'>
    readonly details: FieldRef<"ContactUs", 'String'>
    readonly status: FieldRef<"ContactUs", 'String'>
    readonly ticketUpdate: FieldRef<"ContactUs", 'String'>
    readonly createdAt: FieldRef<"ContactUs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }

  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs createManyAndReturn
   */
  export type ContactUsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to update.
     */
    limit?: number
  }

  /**
   * ContactUs updateManyAndReturn
   */
  export type ContactUsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to update.
     */
    limit?: number
  }

  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }

  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to delete.
     */
    limit?: number
  }

  /**
   * ContactUs without action
   */
  export type ContactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQAvgAggregateOutputType = {
    id: number | null
  }

  export type FAQSumAggregateOutputType = {
    id: number | null
  }

  export type FAQMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
  }

  export type FAQMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    _all: number
  }


  export type FAQAvgAggregateInputType = {
    id?: true
  }

  export type FAQSumAggregateInputType = {
    id?: true
  }

  export type FAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _avg?: FAQAvgAggregateInputType
    _sum?: FAQSumAggregateInputType
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: number
    question: string
    answer: string
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
  }

  export type FAQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer", ExtArgs["result"]["fAQ"]>

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      answer: string
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS and returns the data updated in the database.
     * @param {FAQUpdateManyAndReturnArgs} args - Arguments to update many FAQS.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'Int'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ updateManyAndReturn
   */
  export type FAQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to delete.
     */
    limit?: number
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
  }


  /**
   * Model StagingCompany
   */

  export type AggregateStagingCompany = {
    _count: StagingCompanyCountAggregateOutputType | null
    _avg: StagingCompanyAvgAggregateOutputType | null
    _sum: StagingCompanySumAggregateOutputType | null
    _min: StagingCompanyMinAggregateOutputType | null
    _max: StagingCompanyMaxAggregateOutputType | null
  }

  export type StagingCompanyAvgAggregateOutputType = {
    step: number | null
  }

  export type StagingCompanySumAggregateOutputType = {
    step: number | null
  }

  export type StagingCompanyMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    contactNumber: string | null
    isEmailVerified: boolean | null
    isPaid: boolean | null
    isCompleted: boolean | null
    isRejected: boolean | null
    step: number | null
    registrationDate: Date | null
    directorData: string | null
    shareholderData: string | null
    servicesSelected: string | null
    createdAt: Date | null
    razorpayOrderId: string | null
    emailOtp: string | null
    emailOtpExpires: Date | null
  }

  export type StagingCompanyMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    contactNumber: string | null
    isEmailVerified: boolean | null
    isPaid: boolean | null
    isCompleted: boolean | null
    isRejected: boolean | null
    step: number | null
    registrationDate: Date | null
    directorData: string | null
    shareholderData: string | null
    servicesSelected: string | null
    createdAt: Date | null
    razorpayOrderId: string | null
    emailOtp: string | null
    emailOtpExpires: Date | null
  }

  export type StagingCompanyCountAggregateOutputType = {
    id: number
    companyName: number
    contactEmail: number
    contactNumber: number
    isEmailVerified: number
    isPaid: number
    isCompleted: number
    isRejected: number
    step: number
    registrationDate: number
    directorData: number
    shareholderData: number
    servicesSelected: number
    createdAt: number
    razorpayOrderId: number
    emailOtp: number
    emailOtpExpires: number
    _all: number
  }


  export type StagingCompanyAvgAggregateInputType = {
    step?: true
  }

  export type StagingCompanySumAggregateInputType = {
    step?: true
  }

  export type StagingCompanyMinAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactNumber?: true
    isEmailVerified?: true
    isPaid?: true
    isCompleted?: true
    isRejected?: true
    step?: true
    registrationDate?: true
    directorData?: true
    shareholderData?: true
    servicesSelected?: true
    createdAt?: true
    razorpayOrderId?: true
    emailOtp?: true
    emailOtpExpires?: true
  }

  export type StagingCompanyMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactNumber?: true
    isEmailVerified?: true
    isPaid?: true
    isCompleted?: true
    isRejected?: true
    step?: true
    registrationDate?: true
    directorData?: true
    shareholderData?: true
    servicesSelected?: true
    createdAt?: true
    razorpayOrderId?: true
    emailOtp?: true
    emailOtpExpires?: true
  }

  export type StagingCompanyCountAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactNumber?: true
    isEmailVerified?: true
    isPaid?: true
    isCompleted?: true
    isRejected?: true
    step?: true
    registrationDate?: true
    directorData?: true
    shareholderData?: true
    servicesSelected?: true
    createdAt?: true
    razorpayOrderId?: true
    emailOtp?: true
    emailOtpExpires?: true
    _all?: true
  }

  export type StagingCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StagingCompany to aggregate.
     */
    where?: StagingCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StagingCompanies to fetch.
     */
    orderBy?: StagingCompanyOrderByWithRelationInput | StagingCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StagingCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StagingCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StagingCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StagingCompanies
    **/
    _count?: true | StagingCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StagingCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StagingCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StagingCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StagingCompanyMaxAggregateInputType
  }

  export type GetStagingCompanyAggregateType<T extends StagingCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateStagingCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStagingCompany[P]>
      : GetScalarType<T[P], AggregateStagingCompany[P]>
  }




  export type StagingCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StagingCompanyWhereInput
    orderBy?: StagingCompanyOrderByWithAggregationInput | StagingCompanyOrderByWithAggregationInput[]
    by: StagingCompanyScalarFieldEnum[] | StagingCompanyScalarFieldEnum
    having?: StagingCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StagingCompanyCountAggregateInputType | true
    _avg?: StagingCompanyAvgAggregateInputType
    _sum?: StagingCompanySumAggregateInputType
    _min?: StagingCompanyMinAggregateInputType
    _max?: StagingCompanyMaxAggregateInputType
  }

  export type StagingCompanyGroupByOutputType = {
    id: string
    companyName: string
    contactEmail: string | null
    contactNumber: string | null
    isEmailVerified: boolean
    isPaid: boolean
    isCompleted: boolean
    isRejected: boolean
    step: number
    registrationDate: Date | null
    directorData: string | null
    shareholderData: string | null
    servicesSelected: string | null
    createdAt: Date
    razorpayOrderId: string | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    _count: StagingCompanyCountAggregateOutputType | null
    _avg: StagingCompanyAvgAggregateOutputType | null
    _sum: StagingCompanySumAggregateOutputType | null
    _min: StagingCompanyMinAggregateOutputType | null
    _max: StagingCompanyMaxAggregateOutputType | null
  }

  type GetStagingCompanyGroupByPayload<T extends StagingCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StagingCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StagingCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StagingCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], StagingCompanyGroupByOutputType[P]>
        }
      >
    >


  export type StagingCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactNumber?: boolean
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step?: boolean
    registrationDate?: boolean
    directorData?: boolean
    shareholderData?: boolean
    servicesSelected?: boolean
    createdAt?: boolean
    razorpayOrderId?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    payments?: boolean | StagingCompany$paymentsArgs<ExtArgs>
    _count?: boolean | StagingCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stagingCompany"]>

  export type StagingCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactNumber?: boolean
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step?: boolean
    registrationDate?: boolean
    directorData?: boolean
    shareholderData?: boolean
    servicesSelected?: boolean
    createdAt?: boolean
    razorpayOrderId?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
  }, ExtArgs["result"]["stagingCompany"]>

  export type StagingCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactNumber?: boolean
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step?: boolean
    registrationDate?: boolean
    directorData?: boolean
    shareholderData?: boolean
    servicesSelected?: boolean
    createdAt?: boolean
    razorpayOrderId?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
  }, ExtArgs["result"]["stagingCompany"]>

  export type StagingCompanySelectScalar = {
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactNumber?: boolean
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step?: boolean
    registrationDate?: boolean
    directorData?: boolean
    shareholderData?: boolean
    servicesSelected?: boolean
    createdAt?: boolean
    razorpayOrderId?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
  }

  export type StagingCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactEmail" | "contactNumber" | "isEmailVerified" | "isPaid" | "isCompleted" | "isRejected" | "step" | "registrationDate" | "directorData" | "shareholderData" | "servicesSelected" | "createdAt" | "razorpayOrderId" | "emailOtp" | "emailOtpExpires", ExtArgs["result"]["stagingCompany"]>
  export type StagingCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | StagingCompany$paymentsArgs<ExtArgs>
    _count?: boolean | StagingCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StagingCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StagingCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StagingCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StagingCompany"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      contactEmail: string | null
      contactNumber: string | null
      isEmailVerified: boolean
      isPaid: boolean
      isCompleted: boolean
      isRejected: boolean
      step: number
      registrationDate: Date | null
      directorData: string | null
      shareholderData: string | null
      servicesSelected: string | null
      createdAt: Date
      razorpayOrderId: string | null
      emailOtp: string | null
      emailOtpExpires: Date | null
    }, ExtArgs["result"]["stagingCompany"]>
    composites: {}
  }

  type StagingCompanyGetPayload<S extends boolean | null | undefined | StagingCompanyDefaultArgs> = $Result.GetResult<Prisma.$StagingCompanyPayload, S>

  type StagingCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StagingCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StagingCompanyCountAggregateInputType | true
    }

  export interface StagingCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StagingCompany'], meta: { name: 'StagingCompany' } }
    /**
     * Find zero or one StagingCompany that matches the filter.
     * @param {StagingCompanyFindUniqueArgs} args - Arguments to find a StagingCompany
     * @example
     * // Get one StagingCompany
     * const stagingCompany = await prisma.stagingCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StagingCompanyFindUniqueArgs>(args: SelectSubset<T, StagingCompanyFindUniqueArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StagingCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StagingCompanyFindUniqueOrThrowArgs} args - Arguments to find a StagingCompany
     * @example
     * // Get one StagingCompany
     * const stagingCompany = await prisma.stagingCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StagingCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, StagingCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StagingCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyFindFirstArgs} args - Arguments to find a StagingCompany
     * @example
     * // Get one StagingCompany
     * const stagingCompany = await prisma.stagingCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StagingCompanyFindFirstArgs>(args?: SelectSubset<T, StagingCompanyFindFirstArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StagingCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyFindFirstOrThrowArgs} args - Arguments to find a StagingCompany
     * @example
     * // Get one StagingCompany
     * const stagingCompany = await prisma.stagingCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StagingCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, StagingCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StagingCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StagingCompanies
     * const stagingCompanies = await prisma.stagingCompany.findMany()
     * 
     * // Get first 10 StagingCompanies
     * const stagingCompanies = await prisma.stagingCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stagingCompanyWithIdOnly = await prisma.stagingCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StagingCompanyFindManyArgs>(args?: SelectSubset<T, StagingCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StagingCompany.
     * @param {StagingCompanyCreateArgs} args - Arguments to create a StagingCompany.
     * @example
     * // Create one StagingCompany
     * const StagingCompany = await prisma.stagingCompany.create({
     *   data: {
     *     // ... data to create a StagingCompany
     *   }
     * })
     * 
     */
    create<T extends StagingCompanyCreateArgs>(args: SelectSubset<T, StagingCompanyCreateArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StagingCompanies.
     * @param {StagingCompanyCreateManyArgs} args - Arguments to create many StagingCompanies.
     * @example
     * // Create many StagingCompanies
     * const stagingCompany = await prisma.stagingCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StagingCompanyCreateManyArgs>(args?: SelectSubset<T, StagingCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StagingCompanies and returns the data saved in the database.
     * @param {StagingCompanyCreateManyAndReturnArgs} args - Arguments to create many StagingCompanies.
     * @example
     * // Create many StagingCompanies
     * const stagingCompany = await prisma.stagingCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StagingCompanies and only return the `id`
     * const stagingCompanyWithIdOnly = await prisma.stagingCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StagingCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, StagingCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StagingCompany.
     * @param {StagingCompanyDeleteArgs} args - Arguments to delete one StagingCompany.
     * @example
     * // Delete one StagingCompany
     * const StagingCompany = await prisma.stagingCompany.delete({
     *   where: {
     *     // ... filter to delete one StagingCompany
     *   }
     * })
     * 
     */
    delete<T extends StagingCompanyDeleteArgs>(args: SelectSubset<T, StagingCompanyDeleteArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StagingCompany.
     * @param {StagingCompanyUpdateArgs} args - Arguments to update one StagingCompany.
     * @example
     * // Update one StagingCompany
     * const stagingCompany = await prisma.stagingCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StagingCompanyUpdateArgs>(args: SelectSubset<T, StagingCompanyUpdateArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StagingCompanies.
     * @param {StagingCompanyDeleteManyArgs} args - Arguments to filter StagingCompanies to delete.
     * @example
     * // Delete a few StagingCompanies
     * const { count } = await prisma.stagingCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StagingCompanyDeleteManyArgs>(args?: SelectSubset<T, StagingCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StagingCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StagingCompanies
     * const stagingCompany = await prisma.stagingCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StagingCompanyUpdateManyArgs>(args: SelectSubset<T, StagingCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StagingCompanies and returns the data updated in the database.
     * @param {StagingCompanyUpdateManyAndReturnArgs} args - Arguments to update many StagingCompanies.
     * @example
     * // Update many StagingCompanies
     * const stagingCompany = await prisma.stagingCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StagingCompanies and only return the `id`
     * const stagingCompanyWithIdOnly = await prisma.stagingCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StagingCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, StagingCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StagingCompany.
     * @param {StagingCompanyUpsertArgs} args - Arguments to update or create a StagingCompany.
     * @example
     * // Update or create a StagingCompany
     * const stagingCompany = await prisma.stagingCompany.upsert({
     *   create: {
     *     // ... data to create a StagingCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StagingCompany we want to update
     *   }
     * })
     */
    upsert<T extends StagingCompanyUpsertArgs>(args: SelectSubset<T, StagingCompanyUpsertArgs<ExtArgs>>): Prisma__StagingCompanyClient<$Result.GetResult<Prisma.$StagingCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StagingCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyCountArgs} args - Arguments to filter StagingCompanies to count.
     * @example
     * // Count the number of StagingCompanies
     * const count = await prisma.stagingCompany.count({
     *   where: {
     *     // ... the filter for the StagingCompanies we want to count
     *   }
     * })
    **/
    count<T extends StagingCompanyCountArgs>(
      args?: Subset<T, StagingCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StagingCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StagingCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StagingCompanyAggregateArgs>(args: Subset<T, StagingCompanyAggregateArgs>): Prisma.PrismaPromise<GetStagingCompanyAggregateType<T>>

    /**
     * Group by StagingCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StagingCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StagingCompanyGroupByArgs['orderBy'] }
        : { orderBy?: StagingCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StagingCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStagingCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StagingCompany model
   */
  readonly fields: StagingCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StagingCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StagingCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends StagingCompany$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, StagingCompany$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StagingCompany model
   */
  interface StagingCompanyFieldRefs {
    readonly id: FieldRef<"StagingCompany", 'String'>
    readonly companyName: FieldRef<"StagingCompany", 'String'>
    readonly contactEmail: FieldRef<"StagingCompany", 'String'>
    readonly contactNumber: FieldRef<"StagingCompany", 'String'>
    readonly isEmailVerified: FieldRef<"StagingCompany", 'Boolean'>
    readonly isPaid: FieldRef<"StagingCompany", 'Boolean'>
    readonly isCompleted: FieldRef<"StagingCompany", 'Boolean'>
    readonly isRejected: FieldRef<"StagingCompany", 'Boolean'>
    readonly step: FieldRef<"StagingCompany", 'Int'>
    readonly registrationDate: FieldRef<"StagingCompany", 'DateTime'>
    readonly directorData: FieldRef<"StagingCompany", 'String'>
    readonly shareholderData: FieldRef<"StagingCompany", 'String'>
    readonly servicesSelected: FieldRef<"StagingCompany", 'String'>
    readonly createdAt: FieldRef<"StagingCompany", 'DateTime'>
    readonly razorpayOrderId: FieldRef<"StagingCompany", 'String'>
    readonly emailOtp: FieldRef<"StagingCompany", 'String'>
    readonly emailOtpExpires: FieldRef<"StagingCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StagingCompany findUnique
   */
  export type StagingCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter, which StagingCompany to fetch.
     */
    where: StagingCompanyWhereUniqueInput
  }

  /**
   * StagingCompany findUniqueOrThrow
   */
  export type StagingCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter, which StagingCompany to fetch.
     */
    where: StagingCompanyWhereUniqueInput
  }

  /**
   * StagingCompany findFirst
   */
  export type StagingCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter, which StagingCompany to fetch.
     */
    where?: StagingCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StagingCompanies to fetch.
     */
    orderBy?: StagingCompanyOrderByWithRelationInput | StagingCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StagingCompanies.
     */
    cursor?: StagingCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StagingCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StagingCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StagingCompanies.
     */
    distinct?: StagingCompanyScalarFieldEnum | StagingCompanyScalarFieldEnum[]
  }

  /**
   * StagingCompany findFirstOrThrow
   */
  export type StagingCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter, which StagingCompany to fetch.
     */
    where?: StagingCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StagingCompanies to fetch.
     */
    orderBy?: StagingCompanyOrderByWithRelationInput | StagingCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StagingCompanies.
     */
    cursor?: StagingCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StagingCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StagingCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StagingCompanies.
     */
    distinct?: StagingCompanyScalarFieldEnum | StagingCompanyScalarFieldEnum[]
  }

  /**
   * StagingCompany findMany
   */
  export type StagingCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter, which StagingCompanies to fetch.
     */
    where?: StagingCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StagingCompanies to fetch.
     */
    orderBy?: StagingCompanyOrderByWithRelationInput | StagingCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StagingCompanies.
     */
    cursor?: StagingCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StagingCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StagingCompanies.
     */
    skip?: number
    distinct?: StagingCompanyScalarFieldEnum | StagingCompanyScalarFieldEnum[]
  }

  /**
   * StagingCompany create
   */
  export type StagingCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a StagingCompany.
     */
    data: XOR<StagingCompanyCreateInput, StagingCompanyUncheckedCreateInput>
  }

  /**
   * StagingCompany createMany
   */
  export type StagingCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StagingCompanies.
     */
    data: StagingCompanyCreateManyInput | StagingCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StagingCompany createManyAndReturn
   */
  export type StagingCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many StagingCompanies.
     */
    data: StagingCompanyCreateManyInput | StagingCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StagingCompany update
   */
  export type StagingCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a StagingCompany.
     */
    data: XOR<StagingCompanyUpdateInput, StagingCompanyUncheckedUpdateInput>
    /**
     * Choose, which StagingCompany to update.
     */
    where: StagingCompanyWhereUniqueInput
  }

  /**
   * StagingCompany updateMany
   */
  export type StagingCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StagingCompanies.
     */
    data: XOR<StagingCompanyUpdateManyMutationInput, StagingCompanyUncheckedUpdateManyInput>
    /**
     * Filter which StagingCompanies to update
     */
    where?: StagingCompanyWhereInput
    /**
     * Limit how many StagingCompanies to update.
     */
    limit?: number
  }

  /**
   * StagingCompany updateManyAndReturn
   */
  export type StagingCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * The data used to update StagingCompanies.
     */
    data: XOR<StagingCompanyUpdateManyMutationInput, StagingCompanyUncheckedUpdateManyInput>
    /**
     * Filter which StagingCompanies to update
     */
    where?: StagingCompanyWhereInput
    /**
     * Limit how many StagingCompanies to update.
     */
    limit?: number
  }

  /**
   * StagingCompany upsert
   */
  export type StagingCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the StagingCompany to update in case it exists.
     */
    where: StagingCompanyWhereUniqueInput
    /**
     * In case the StagingCompany found by the `where` argument doesn't exist, create a new StagingCompany with this data.
     */
    create: XOR<StagingCompanyCreateInput, StagingCompanyUncheckedCreateInput>
    /**
     * In case the StagingCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StagingCompanyUpdateInput, StagingCompanyUncheckedUpdateInput>
  }

  /**
   * StagingCompany delete
   */
  export type StagingCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
    /**
     * Filter which StagingCompany to delete.
     */
    where: StagingCompanyWhereUniqueInput
  }

  /**
   * StagingCompany deleteMany
   */
  export type StagingCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StagingCompanies to delete
     */
    where?: StagingCompanyWhereInput
    /**
     * Limit how many StagingCompanies to delete.
     */
    limit?: number
  }

  /**
   * StagingCompany.payments
   */
  export type StagingCompany$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * StagingCompany without action
   */
  export type StagingCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StagingCompany
     */
    select?: StagingCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingCompany
     */
    omit?: StagingCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StagingCompanyInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    actorId: number | null
    companyId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    actorId: number | null
    companyId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    actorId: number | null
    role: $Enums.UserRole | null
    action: string | null
    target: string | null
    companyId: number | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    actorId: number | null
    role: $Enums.UserRole | null
    action: string | null
    target: string | null
    companyId: number | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    role: number
    action: number
    target: number
    companyId: number
    timestamp: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    actorId?: true
    companyId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    actorId?: true
    companyId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    role?: true
    action?: true
    target?: true
    companyId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    role?: true
    action?: true
    target?: true
    companyId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    role?: true
    action?: true
    target?: true
    companyId?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    actorId: number
    role: $Enums.UserRole
    action: string
    target: string
    companyId: number | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    role?: boolean
    action?: boolean
    target?: boolean
    companyId?: boolean
    timestamp?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    role?: boolean
    action?: boolean
    target?: boolean
    companyId?: boolean
    timestamp?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    role?: boolean
    action?: boolean
    target?: boolean
    companyId?: boolean
    timestamp?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    role?: boolean
    action?: boolean
    target?: boolean
    companyId?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "role" | "action" | "target" | "companyId" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actorId: number
      role: $Enums.UserRole
      action: string
      target: string
      companyId: number | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends AuditLog$companyArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly actorId: FieldRef<"AuditLog", 'Int'>
    readonly role: FieldRef<"AuditLog", 'UserRole'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly target: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'Int'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.company
   */
  export type AuditLog$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model RegisteredCompanyName
   */

  export type AggregateRegisteredCompanyName = {
    _count: RegisteredCompanyNameCountAggregateOutputType | null
    _avg: RegisteredCompanyNameAvgAggregateOutputType | null
    _sum: RegisteredCompanyNameSumAggregateOutputType | null
    _min: RegisteredCompanyNameMinAggregateOutputType | null
    _max: RegisteredCompanyNameMaxAggregateOutputType | null
  }

  export type RegisteredCompanyNameAvgAggregateOutputType = {
    id: number | null
  }

  export type RegisteredCompanyNameSumAggregateOutputType = {
    id: number | null
  }

  export type RegisteredCompanyNameMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    createdAt: Date | null
  }

  export type RegisteredCompanyNameMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    createdAt: Date | null
  }

  export type RegisteredCompanyNameCountAggregateOutputType = {
    id: number
    companyName: number
    createdAt: number
    _all: number
  }


  export type RegisteredCompanyNameAvgAggregateInputType = {
    id?: true
  }

  export type RegisteredCompanyNameSumAggregateInputType = {
    id?: true
  }

  export type RegisteredCompanyNameMinAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
  }

  export type RegisteredCompanyNameMaxAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
  }

  export type RegisteredCompanyNameCountAggregateInputType = {
    id?: true
    companyName?: true
    createdAt?: true
    _all?: true
  }

  export type RegisteredCompanyNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisteredCompanyName to aggregate.
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredCompanyNames to fetch.
     */
    orderBy?: RegisteredCompanyNameOrderByWithRelationInput | RegisteredCompanyNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisteredCompanyNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredCompanyNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredCompanyNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisteredCompanyNames
    **/
    _count?: true | RegisteredCompanyNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegisteredCompanyNameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegisteredCompanyNameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisteredCompanyNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisteredCompanyNameMaxAggregateInputType
  }

  export type GetRegisteredCompanyNameAggregateType<T extends RegisteredCompanyNameAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisteredCompanyName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisteredCompanyName[P]>
      : GetScalarType<T[P], AggregateRegisteredCompanyName[P]>
  }




  export type RegisteredCompanyNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisteredCompanyNameWhereInput
    orderBy?: RegisteredCompanyNameOrderByWithAggregationInput | RegisteredCompanyNameOrderByWithAggregationInput[]
    by: RegisteredCompanyNameScalarFieldEnum[] | RegisteredCompanyNameScalarFieldEnum
    having?: RegisteredCompanyNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisteredCompanyNameCountAggregateInputType | true
    _avg?: RegisteredCompanyNameAvgAggregateInputType
    _sum?: RegisteredCompanyNameSumAggregateInputType
    _min?: RegisteredCompanyNameMinAggregateInputType
    _max?: RegisteredCompanyNameMaxAggregateInputType
  }

  export type RegisteredCompanyNameGroupByOutputType = {
    id: number
    companyName: string
    createdAt: Date
    _count: RegisteredCompanyNameCountAggregateOutputType | null
    _avg: RegisteredCompanyNameAvgAggregateOutputType | null
    _sum: RegisteredCompanyNameSumAggregateOutputType | null
    _min: RegisteredCompanyNameMinAggregateOutputType | null
    _max: RegisteredCompanyNameMaxAggregateOutputType | null
  }

  type GetRegisteredCompanyNameGroupByPayload<T extends RegisteredCompanyNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegisteredCompanyNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisteredCompanyNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisteredCompanyNameGroupByOutputType[P]>
            : GetScalarType<T[P], RegisteredCompanyNameGroupByOutputType[P]>
        }
      >
    >


  export type RegisteredCompanyNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["registeredCompanyName"]>

  export type RegisteredCompanyNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["registeredCompanyName"]>

  export type RegisteredCompanyNameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["registeredCompanyName"]>

  export type RegisteredCompanyNameSelectScalar = {
    id?: boolean
    companyName?: boolean
    createdAt?: boolean
  }

  export type RegisteredCompanyNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "createdAt", ExtArgs["result"]["registeredCompanyName"]>

  export type $RegisteredCompanyNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegisteredCompanyName"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      createdAt: Date
    }, ExtArgs["result"]["registeredCompanyName"]>
    composites: {}
  }

  type RegisteredCompanyNameGetPayload<S extends boolean | null | undefined | RegisteredCompanyNameDefaultArgs> = $Result.GetResult<Prisma.$RegisteredCompanyNamePayload, S>

  type RegisteredCompanyNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegisteredCompanyNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegisteredCompanyNameCountAggregateInputType | true
    }

  export interface RegisteredCompanyNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisteredCompanyName'], meta: { name: 'RegisteredCompanyName' } }
    /**
     * Find zero or one RegisteredCompanyName that matches the filter.
     * @param {RegisteredCompanyNameFindUniqueArgs} args - Arguments to find a RegisteredCompanyName
     * @example
     * // Get one RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegisteredCompanyNameFindUniqueArgs>(args: SelectSubset<T, RegisteredCompanyNameFindUniqueArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegisteredCompanyName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegisteredCompanyNameFindUniqueOrThrowArgs} args - Arguments to find a RegisteredCompanyName
     * @example
     * // Get one RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegisteredCompanyNameFindUniqueOrThrowArgs>(args: SelectSubset<T, RegisteredCompanyNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisteredCompanyName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameFindFirstArgs} args - Arguments to find a RegisteredCompanyName
     * @example
     * // Get one RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegisteredCompanyNameFindFirstArgs>(args?: SelectSubset<T, RegisteredCompanyNameFindFirstArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisteredCompanyName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameFindFirstOrThrowArgs} args - Arguments to find a RegisteredCompanyName
     * @example
     * // Get one RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegisteredCompanyNameFindFirstOrThrowArgs>(args?: SelectSubset<T, RegisteredCompanyNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisteredCompanyNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisteredCompanyNames
     * const registeredCompanyNames = await prisma.registeredCompanyName.findMany()
     * 
     * // Get first 10 RegisteredCompanyNames
     * const registeredCompanyNames = await prisma.registeredCompanyName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registeredCompanyNameWithIdOnly = await prisma.registeredCompanyName.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegisteredCompanyNameFindManyArgs>(args?: SelectSubset<T, RegisteredCompanyNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegisteredCompanyName.
     * @param {RegisteredCompanyNameCreateArgs} args - Arguments to create a RegisteredCompanyName.
     * @example
     * // Create one RegisteredCompanyName
     * const RegisteredCompanyName = await prisma.registeredCompanyName.create({
     *   data: {
     *     // ... data to create a RegisteredCompanyName
     *   }
     * })
     * 
     */
    create<T extends RegisteredCompanyNameCreateArgs>(args: SelectSubset<T, RegisteredCompanyNameCreateArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegisteredCompanyNames.
     * @param {RegisteredCompanyNameCreateManyArgs} args - Arguments to create many RegisteredCompanyNames.
     * @example
     * // Create many RegisteredCompanyNames
     * const registeredCompanyName = await prisma.registeredCompanyName.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegisteredCompanyNameCreateManyArgs>(args?: SelectSubset<T, RegisteredCompanyNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegisteredCompanyNames and returns the data saved in the database.
     * @param {RegisteredCompanyNameCreateManyAndReturnArgs} args - Arguments to create many RegisteredCompanyNames.
     * @example
     * // Create many RegisteredCompanyNames
     * const registeredCompanyName = await prisma.registeredCompanyName.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegisteredCompanyNames and only return the `id`
     * const registeredCompanyNameWithIdOnly = await prisma.registeredCompanyName.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegisteredCompanyNameCreateManyAndReturnArgs>(args?: SelectSubset<T, RegisteredCompanyNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegisteredCompanyName.
     * @param {RegisteredCompanyNameDeleteArgs} args - Arguments to delete one RegisteredCompanyName.
     * @example
     * // Delete one RegisteredCompanyName
     * const RegisteredCompanyName = await prisma.registeredCompanyName.delete({
     *   where: {
     *     // ... filter to delete one RegisteredCompanyName
     *   }
     * })
     * 
     */
    delete<T extends RegisteredCompanyNameDeleteArgs>(args: SelectSubset<T, RegisteredCompanyNameDeleteArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegisteredCompanyName.
     * @param {RegisteredCompanyNameUpdateArgs} args - Arguments to update one RegisteredCompanyName.
     * @example
     * // Update one RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegisteredCompanyNameUpdateArgs>(args: SelectSubset<T, RegisteredCompanyNameUpdateArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegisteredCompanyNames.
     * @param {RegisteredCompanyNameDeleteManyArgs} args - Arguments to filter RegisteredCompanyNames to delete.
     * @example
     * // Delete a few RegisteredCompanyNames
     * const { count } = await prisma.registeredCompanyName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegisteredCompanyNameDeleteManyArgs>(args?: SelectSubset<T, RegisteredCompanyNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisteredCompanyNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisteredCompanyNames
     * const registeredCompanyName = await prisma.registeredCompanyName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegisteredCompanyNameUpdateManyArgs>(args: SelectSubset<T, RegisteredCompanyNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisteredCompanyNames and returns the data updated in the database.
     * @param {RegisteredCompanyNameUpdateManyAndReturnArgs} args - Arguments to update many RegisteredCompanyNames.
     * @example
     * // Update many RegisteredCompanyNames
     * const registeredCompanyName = await prisma.registeredCompanyName.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegisteredCompanyNames and only return the `id`
     * const registeredCompanyNameWithIdOnly = await prisma.registeredCompanyName.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegisteredCompanyNameUpdateManyAndReturnArgs>(args: SelectSubset<T, RegisteredCompanyNameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegisteredCompanyName.
     * @param {RegisteredCompanyNameUpsertArgs} args - Arguments to update or create a RegisteredCompanyName.
     * @example
     * // Update or create a RegisteredCompanyName
     * const registeredCompanyName = await prisma.registeredCompanyName.upsert({
     *   create: {
     *     // ... data to create a RegisteredCompanyName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisteredCompanyName we want to update
     *   }
     * })
     */
    upsert<T extends RegisteredCompanyNameUpsertArgs>(args: SelectSubset<T, RegisteredCompanyNameUpsertArgs<ExtArgs>>): Prisma__RegisteredCompanyNameClient<$Result.GetResult<Prisma.$RegisteredCompanyNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegisteredCompanyNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameCountArgs} args - Arguments to filter RegisteredCompanyNames to count.
     * @example
     * // Count the number of RegisteredCompanyNames
     * const count = await prisma.registeredCompanyName.count({
     *   where: {
     *     // ... the filter for the RegisteredCompanyNames we want to count
     *   }
     * })
    **/
    count<T extends RegisteredCompanyNameCountArgs>(
      args?: Subset<T, RegisteredCompanyNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisteredCompanyNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisteredCompanyName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisteredCompanyNameAggregateArgs>(args: Subset<T, RegisteredCompanyNameAggregateArgs>): Prisma.PrismaPromise<GetRegisteredCompanyNameAggregateType<T>>

    /**
     * Group by RegisteredCompanyName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisteredCompanyNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisteredCompanyNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisteredCompanyNameGroupByArgs['orderBy'] }
        : { orderBy?: RegisteredCompanyNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisteredCompanyNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisteredCompanyNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegisteredCompanyName model
   */
  readonly fields: RegisteredCompanyNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisteredCompanyName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegisteredCompanyNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegisteredCompanyName model
   */
  interface RegisteredCompanyNameFieldRefs {
    readonly id: FieldRef<"RegisteredCompanyName", 'Int'>
    readonly companyName: FieldRef<"RegisteredCompanyName", 'String'>
    readonly createdAt: FieldRef<"RegisteredCompanyName", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegisteredCompanyName findUnique
   */
  export type RegisteredCompanyNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter, which RegisteredCompanyName to fetch.
     */
    where: RegisteredCompanyNameWhereUniqueInput
  }

  /**
   * RegisteredCompanyName findUniqueOrThrow
   */
  export type RegisteredCompanyNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter, which RegisteredCompanyName to fetch.
     */
    where: RegisteredCompanyNameWhereUniqueInput
  }

  /**
   * RegisteredCompanyName findFirst
   */
  export type RegisteredCompanyNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter, which RegisteredCompanyName to fetch.
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredCompanyNames to fetch.
     */
    orderBy?: RegisteredCompanyNameOrderByWithRelationInput | RegisteredCompanyNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisteredCompanyNames.
     */
    cursor?: RegisteredCompanyNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredCompanyNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredCompanyNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisteredCompanyNames.
     */
    distinct?: RegisteredCompanyNameScalarFieldEnum | RegisteredCompanyNameScalarFieldEnum[]
  }

  /**
   * RegisteredCompanyName findFirstOrThrow
   */
  export type RegisteredCompanyNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter, which RegisteredCompanyName to fetch.
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredCompanyNames to fetch.
     */
    orderBy?: RegisteredCompanyNameOrderByWithRelationInput | RegisteredCompanyNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisteredCompanyNames.
     */
    cursor?: RegisteredCompanyNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredCompanyNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredCompanyNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisteredCompanyNames.
     */
    distinct?: RegisteredCompanyNameScalarFieldEnum | RegisteredCompanyNameScalarFieldEnum[]
  }

  /**
   * RegisteredCompanyName findMany
   */
  export type RegisteredCompanyNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter, which RegisteredCompanyNames to fetch.
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisteredCompanyNames to fetch.
     */
    orderBy?: RegisteredCompanyNameOrderByWithRelationInput | RegisteredCompanyNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisteredCompanyNames.
     */
    cursor?: RegisteredCompanyNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisteredCompanyNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisteredCompanyNames.
     */
    skip?: number
    distinct?: RegisteredCompanyNameScalarFieldEnum | RegisteredCompanyNameScalarFieldEnum[]
  }

  /**
   * RegisteredCompanyName create
   */
  export type RegisteredCompanyNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * The data needed to create a RegisteredCompanyName.
     */
    data: XOR<RegisteredCompanyNameCreateInput, RegisteredCompanyNameUncheckedCreateInput>
  }

  /**
   * RegisteredCompanyName createMany
   */
  export type RegisteredCompanyNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisteredCompanyNames.
     */
    data: RegisteredCompanyNameCreateManyInput | RegisteredCompanyNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegisteredCompanyName createManyAndReturn
   */
  export type RegisteredCompanyNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * The data used to create many RegisteredCompanyNames.
     */
    data: RegisteredCompanyNameCreateManyInput | RegisteredCompanyNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegisteredCompanyName update
   */
  export type RegisteredCompanyNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * The data needed to update a RegisteredCompanyName.
     */
    data: XOR<RegisteredCompanyNameUpdateInput, RegisteredCompanyNameUncheckedUpdateInput>
    /**
     * Choose, which RegisteredCompanyName to update.
     */
    where: RegisteredCompanyNameWhereUniqueInput
  }

  /**
   * RegisteredCompanyName updateMany
   */
  export type RegisteredCompanyNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisteredCompanyNames.
     */
    data: XOR<RegisteredCompanyNameUpdateManyMutationInput, RegisteredCompanyNameUncheckedUpdateManyInput>
    /**
     * Filter which RegisteredCompanyNames to update
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * Limit how many RegisteredCompanyNames to update.
     */
    limit?: number
  }

  /**
   * RegisteredCompanyName updateManyAndReturn
   */
  export type RegisteredCompanyNameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * The data used to update RegisteredCompanyNames.
     */
    data: XOR<RegisteredCompanyNameUpdateManyMutationInput, RegisteredCompanyNameUncheckedUpdateManyInput>
    /**
     * Filter which RegisteredCompanyNames to update
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * Limit how many RegisteredCompanyNames to update.
     */
    limit?: number
  }

  /**
   * RegisteredCompanyName upsert
   */
  export type RegisteredCompanyNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * The filter to search for the RegisteredCompanyName to update in case it exists.
     */
    where: RegisteredCompanyNameWhereUniqueInput
    /**
     * In case the RegisteredCompanyName found by the `where` argument doesn't exist, create a new RegisteredCompanyName with this data.
     */
    create: XOR<RegisteredCompanyNameCreateInput, RegisteredCompanyNameUncheckedCreateInput>
    /**
     * In case the RegisteredCompanyName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisteredCompanyNameUpdateInput, RegisteredCompanyNameUncheckedUpdateInput>
  }

  /**
   * RegisteredCompanyName delete
   */
  export type RegisteredCompanyNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
    /**
     * Filter which RegisteredCompanyName to delete.
     */
    where: RegisteredCompanyNameWhereUniqueInput
  }

  /**
   * RegisteredCompanyName deleteMany
   */
  export type RegisteredCompanyNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisteredCompanyNames to delete
     */
    where?: RegisteredCompanyNameWhereInput
    /**
     * Limit how many RegisteredCompanyNames to delete.
     */
    limit?: number
  }

  /**
   * RegisteredCompanyName without action
   */
  export type RegisteredCompanyNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisteredCompanyName
     */
    select?: RegisteredCompanyNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisteredCompanyName
     */
    omit?: RegisteredCompanyNameOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    mobile: 'mobile',
    country: 'country',
    role: 'role',
    profilePic: 'profilePic',
    profileThumbnail: 'profileThumbnail',
    lastLogin: 'lastLogin',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordExpires: 'resetPasswordExpires',
    otp: 'otp',
    otpExpires: 'otpExpires',
    refreshToken: 'refreshToken',
    isVerified: 'isVerified',
    isDeactivated: 'isDeactivated',
    isDeleted: 'isDeleted',
    isSuspended: 'isSuspended',
    suspendMessage: 'suspendMessage',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    companyId: 'companyId',
    companyName: 'companyName',
    registrationDate: 'registrationDate',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    country: 'country',
    postalCode: 'postalCode',
    proposedShares: 'proposedShares',
    currency: 'currency',
    proposedShareCapital: 'proposedShareCapital',
    businessActivity1: 'businessActivity1',
    businessActivity1Desc: 'businessActivity1Desc',
    businessActivity2: 'businessActivity2',
    businessActivity2Desc: 'businessActivity2Desc',
    createdAt: 'createdAt',
    status: 'status',
    statusRemarks: 'statusRemarks',
    isDeleted: 'isDeleted',
    userId: 'userId',
    canEditC: 'canEditC',
    canEditD: 'canEditD',
    canEditS: 'canEditS'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyStatusMessageScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    senderId: 'senderId',
    senderRole: 'senderRole',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type CompanyStatusMessageScalarFieldEnum = (typeof CompanyStatusMessageScalarFieldEnum)[keyof typeof CompanyStatusMessageScalarFieldEnum]


  export const DirectorScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    directorName: 'directorName',
    email: 'email',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    country: 'country',
    postalCode: 'postalCode',
    contactNumber: 'contactNumber',
    nationality: 'nationality',
    idType: 'idType',
    idExpiryDate: 'idExpiryDate',
    idNumber: 'idNumber',
    isShareholder: 'isShareholder',
    identityProof: 'identityProof',
    addressProof: 'addressProof',
    dateOfBirth: 'dateOfBirth',
    createdAt: 'createdAt'
  };

  export type DirectorScalarFieldEnum = (typeof DirectorScalarFieldEnum)[keyof typeof DirectorScalarFieldEnum]


  export const ShareholderScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    shareholderName: 'shareholderName',
    email: 'email',
    type: 'type',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    country: 'country',
    postalCode: 'postalCode',
    contactNumber: 'contactNumber',
    nationality: 'nationality',
    idType: 'idType',
    idExpiryDate: 'idExpiryDate',
    idNumber: 'idNumber',
    dateOfBirth: 'dateOfBirth',
    numberOfShares: 'numberOfShares',
    shareCapitalAllocation: 'shareCapitalAllocation',
    createdAt: 'createdAt'
  };

  export type ShareholderScalarFieldEnum = (typeof ShareholderScalarFieldEnum)[keyof typeof ShareholderScalarFieldEnum]


  export const CompanyDocumentScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    documentLabel: 'documentLabel',
    documentPath: 'documentPath',
    documentType: 'documentType',
    purpose: 'purpose',
    thumbnail: 'thumbnail',
    uploadedAt: 'uploadedAt',
    isVerified: 'isVerified',
    uploadedBy: 'uploadedBy',
    uploadedRole: 'uploadedRole',
    uploadedFor: 'uploadedFor'
  };

  export type CompanyDocumentScalarFieldEnum = (typeof CompanyDocumentScalarFieldEnum)[keyof typeof CompanyDocumentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    stagingCompanyId: 'stagingCompanyId',
    paymentDate: 'paymentDate',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    paymentReference: 'paymentReference',
    services: 'services'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    refundId: 'refundId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    serviceName: 'serviceName',
    serviceDescription: 'serviceDescription',
    cost: 'cost',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const CompanyServiceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    serviceId: 'serviceId',
    updateDate: 'updateDate'
  };

  export type CompanyServiceScalarFieldEnum = (typeof CompanyServiceScalarFieldEnum)[keyof typeof CompanyServiceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InsightRecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    sampleDocUrls: 'sampleDocUrls',
    createdAt: 'createdAt'
  };

  export type InsightRecommendationScalarFieldEnum = (typeof InsightRecommendationScalarFieldEnum)[keyof typeof InsightRecommendationScalarFieldEnum]


  export const CalendarActionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    userId: 'userId',
    companyId: 'companyId',
    dueDate: 'dueDate',
    notes: 'notes',
    status: 'status',
    createdBy: 'createdBy',
    createdByRole: 'createdByRole'
  };

  export type CalendarActionScalarFieldEnum = (typeof CalendarActionScalarFieldEnum)[keyof typeof CalendarActionScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    sentAt: 'sentAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const DashboardStateScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    step: 'step',
    completedAt: 'completedAt'
  };

  export type DashboardStateScalarFieldEnum = (typeof DashboardStateScalarFieldEnum)[keyof typeof DashboardStateScalarFieldEnum]


  export const RoleAssignmentScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    companyId: 'companyId',
    role: 'role',
    assignedAt: 'assignedAt'
  };

  export type RoleAssignmentScalarFieldEnum = (typeof RoleAssignmentScalarFieldEnum)[keyof typeof RoleAssignmentScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    status: 'status',
    createdAt: 'createdAt',
    publishedAt: 'publishedAt',
    imagePath: 'imagePath',
    views: 'views',
    hashtag: 'hashtag'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    details: 'details',
    status: 'status',
    ticketUpdate: 'ticketUpdate',
    createdAt: 'createdAt'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const StagingCompanyScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactEmail: 'contactEmail',
    contactNumber: 'contactNumber',
    isEmailVerified: 'isEmailVerified',
    isPaid: 'isPaid',
    isCompleted: 'isCompleted',
    isRejected: 'isRejected',
    step: 'step',
    registrationDate: 'registrationDate',
    directorData: 'directorData',
    shareholderData: 'shareholderData',
    servicesSelected: 'servicesSelected',
    createdAt: 'createdAt',
    razorpayOrderId: 'razorpayOrderId',
    emailOtp: 'emailOtp',
    emailOtpExpires: 'emailOtpExpires'
  };

  export type StagingCompanyScalarFieldEnum = (typeof StagingCompanyScalarFieldEnum)[keyof typeof StagingCompanyScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    role: 'role',
    action: 'action',
    target: 'target',
    companyId: 'companyId',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RegisteredCompanyNameScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    createdAt: 'createdAt'
  };

  export type RegisteredCompanyNameScalarFieldEnum = (typeof RegisteredCompanyNameScalarFieldEnum)[keyof typeof RegisteredCompanyNameScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'CompanyStatus'
   */
  export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


  /**
   * Reference to a field of type 'CompanyStatus[]'
   */
  export type ListEnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus[]'>
    


  /**
   * Reference to a field of type 'ShareholderType'
   */
  export type EnumShareholderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareholderType'>
    


  /**
   * Reference to a field of type 'ShareholderType[]'
   */
  export type ListEnumShareholderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShareholderType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentPurpose'
   */
  export type EnumDocumentPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentPurpose'>
    


  /**
   * Reference to a field of type 'DocumentPurpose[]'
   */
  export type ListEnumDocumentPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentPurpose[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    mobile?: StringFilter<"User"> | string
    country?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profilePic?: StringNullableFilter<"User"> | string | null
    profileThumbnail?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isDeactivated?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    isSuspended?: BoolFilter<"User"> | boolean
    suspendMessage?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    assignedTasks?: CalendarActionListRelationFilter
    messagesReceived?: ChatMessageListRelationFilter
    messagesSent?: ChatMessageListRelationFilter
    companies?: CompanyListRelationFilter
    insights?: InsightRecommendationListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    assignedRoles?: RoleAssignmentListRelationFilter
    revertMessage?: CompanyStatusMessageListRelationFilter
    uploadedDocs?: CompanyDocumentListRelationFilter
    receivedDocs?: CompanyDocumentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    CalendarAction?: CalendarActionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    country?: SortOrder
    role?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    profileThumbnail?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isDeactivated?: SortOrder
    isDeleted?: SortOrder
    isSuspended?: SortOrder
    suspendMessage?: SortOrder
    createdAt?: SortOrder
    assignedTasks?: CalendarActionOrderByRelationAggregateInput
    messagesReceived?: ChatMessageOrderByRelationAggregateInput
    messagesSent?: ChatMessageOrderByRelationAggregateInput
    companies?: CompanyOrderByRelationAggregateInput
    insights?: InsightRecommendationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    assignedRoles?: RoleAssignmentOrderByRelationAggregateInput
    revertMessage?: CompanyStatusMessageOrderByRelationAggregateInput
    uploadedDocs?: CompanyDocumentOrderByRelationAggregateInput
    receivedDocs?: CompanyDocumentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    CalendarAction?: CalendarActionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    mobile?: StringFilter<"User"> | string
    country?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profilePic?: StringNullableFilter<"User"> | string | null
    profileThumbnail?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isDeactivated?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    isSuspended?: BoolFilter<"User"> | boolean
    suspendMessage?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    assignedTasks?: CalendarActionListRelationFilter
    messagesReceived?: ChatMessageListRelationFilter
    messagesSent?: ChatMessageListRelationFilter
    companies?: CompanyListRelationFilter
    insights?: InsightRecommendationListRelationFilter
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    assignedRoles?: RoleAssignmentListRelationFilter
    revertMessage?: CompanyStatusMessageListRelationFilter
    uploadedDocs?: CompanyDocumentListRelationFilter
    receivedDocs?: CompanyDocumentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    CalendarAction?: CalendarActionListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    country?: SortOrder
    role?: SortOrder
    profilePic?: SortOrderInput | SortOrder
    profileThumbnail?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isDeactivated?: SortOrder
    isDeleted?: SortOrder
    isSuspended?: SortOrder
    suspendMessage?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    mobile?: StringWithAggregatesFilter<"User"> | string
    country?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    profilePic?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileThumbnail?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    otp?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isDeactivated?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    isSuspended?: BoolWithAggregatesFilter<"User"> | boolean
    suspendMessage?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    companyId?: IntFilter<"Company"> | number
    companyName?: StringFilter<"Company"> | string
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    addressLine1?: StringFilter<"Company"> | string
    addressLine2?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    proposedShares?: IntFilter<"Company"> | number
    currency?: StringFilter<"Company"> | string
    proposedShareCapital?: DecimalFilter<"Company"> | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFilter<"Company"> | string
    businessActivity1Desc?: StringFilter<"Company"> | string
    businessActivity2?: StringFilter<"Company"> | string
    businessActivity2Desc?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    statusRemarks?: StringNullableFilter<"Company"> | string | null
    isDeleted?: BoolFilter<"Company"> | boolean
    userId?: IntFilter<"Company"> | number
    canEditC?: BoolFilter<"Company"> | boolean
    canEditD?: BoolFilter<"Company"> | boolean
    canEditS?: BoolFilter<"Company"> | boolean
    tasks?: CalendarActionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    documents?: CompanyDocumentListRelationFilter
    companyServices?: CompanyServiceListRelationFilter
    dashboardState?: XOR<DashboardStateNullableScalarRelationFilter, DashboardStateWhereInput> | null
    directors?: DirectorListRelationFilter
    payments?: PaymentListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
    shareholders?: ShareholderListRelationFilter
    revertMessage?: CompanyStatusMessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    companyId?: SortOrder
    companyName?: SortOrder
    registrationDate?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    proposedShares?: SortOrder
    currency?: SortOrder
    proposedShareCapital?: SortOrder
    businessActivity1?: SortOrder
    businessActivity1Desc?: SortOrder
    businessActivity2?: SortOrder
    businessActivity2Desc?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    statusRemarks?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    canEditC?: SortOrder
    canEditD?: SortOrder
    canEditS?: SortOrder
    tasks?: CalendarActionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    documents?: CompanyDocumentOrderByRelationAggregateInput
    companyServices?: CompanyServiceOrderByRelationAggregateInput
    dashboardState?: DashboardStateOrderByWithRelationInput
    directors?: DirectorOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    roleAssignments?: RoleAssignmentOrderByRelationAggregateInput
    shareholders?: ShareholderOrderByRelationAggregateInput
    revertMessage?: CompanyStatusMessageOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    companyId?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    companyName?: StringFilter<"Company"> | string
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    addressLine1?: StringFilter<"Company"> | string
    addressLine2?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    proposedShares?: IntFilter<"Company"> | number
    currency?: StringFilter<"Company"> | string
    proposedShareCapital?: DecimalFilter<"Company"> | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFilter<"Company"> | string
    businessActivity1Desc?: StringFilter<"Company"> | string
    businessActivity2?: StringFilter<"Company"> | string
    businessActivity2Desc?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    statusRemarks?: StringNullableFilter<"Company"> | string | null
    isDeleted?: BoolFilter<"Company"> | boolean
    userId?: IntFilter<"Company"> | number
    canEditC?: BoolFilter<"Company"> | boolean
    canEditD?: BoolFilter<"Company"> | boolean
    canEditS?: BoolFilter<"Company"> | boolean
    tasks?: CalendarActionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    documents?: CompanyDocumentListRelationFilter
    companyServices?: CompanyServiceListRelationFilter
    dashboardState?: XOR<DashboardStateNullableScalarRelationFilter, DashboardStateWhereInput> | null
    directors?: DirectorListRelationFilter
    payments?: PaymentListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
    shareholders?: ShareholderListRelationFilter
    revertMessage?: CompanyStatusMessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "companyId">

  export type CompanyOrderByWithAggregationInput = {
    companyId?: SortOrder
    companyName?: SortOrder
    registrationDate?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    proposedShares?: SortOrder
    currency?: SortOrder
    proposedShareCapital?: SortOrder
    businessActivity1?: SortOrder
    businessActivity1Desc?: SortOrder
    businessActivity2?: SortOrder
    businessActivity2Desc?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    statusRemarks?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    canEditC?: SortOrder
    canEditD?: SortOrder
    canEditS?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    companyId?: IntWithAggregatesFilter<"Company"> | number
    companyName?: StringWithAggregatesFilter<"Company"> | string
    registrationDate?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    addressLine1?: StringWithAggregatesFilter<"Company"> | string
    addressLine2?: StringWithAggregatesFilter<"Company"> | string
    country?: StringWithAggregatesFilter<"Company"> | string
    postalCode?: StringWithAggregatesFilter<"Company"> | string
    proposedShares?: IntWithAggregatesFilter<"Company"> | number
    currency?: StringWithAggregatesFilter<"Company"> | string
    proposedShareCapital?: DecimalWithAggregatesFilter<"Company"> | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringWithAggregatesFilter<"Company"> | string
    businessActivity1Desc?: StringWithAggregatesFilter<"Company"> | string
    businessActivity2?: StringWithAggregatesFilter<"Company"> | string
    businessActivity2Desc?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    status?: EnumCompanyStatusWithAggregatesFilter<"Company"> | $Enums.CompanyStatus
    statusRemarks?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Company"> | boolean
    userId?: IntWithAggregatesFilter<"Company"> | number
    canEditC?: BoolWithAggregatesFilter<"Company"> | boolean
    canEditD?: BoolWithAggregatesFilter<"Company"> | boolean
    canEditS?: BoolWithAggregatesFilter<"Company"> | boolean
  }

  export type CompanyStatusMessageWhereInput = {
    AND?: CompanyStatusMessageWhereInput | CompanyStatusMessageWhereInput[]
    OR?: CompanyStatusMessageWhereInput[]
    NOT?: CompanyStatusMessageWhereInput | CompanyStatusMessageWhereInput[]
    id?: IntFilter<"CompanyStatusMessage"> | number
    companyId?: IntFilter<"CompanyStatusMessage"> | number
    senderId?: IntFilter<"CompanyStatusMessage"> | number
    senderRole?: EnumUserRoleFilter<"CompanyStatusMessage"> | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    message?: StringFilter<"CompanyStatusMessage"> | string
    createdAt?: DateTimeFilter<"CompanyStatusMessage"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyStatusMessageOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type CompanyStatusMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyStatusMessageWhereInput | CompanyStatusMessageWhereInput[]
    OR?: CompanyStatusMessageWhereInput[]
    NOT?: CompanyStatusMessageWhereInput | CompanyStatusMessageWhereInput[]
    companyId?: IntFilter<"CompanyStatusMessage"> | number
    senderId?: IntFilter<"CompanyStatusMessage"> | number
    senderRole?: EnumUserRoleFilter<"CompanyStatusMessage"> | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    message?: StringFilter<"CompanyStatusMessage"> | string
    createdAt?: DateTimeFilter<"CompanyStatusMessage"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CompanyStatusMessageOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyStatusMessageCountOrderByAggregateInput
    _avg?: CompanyStatusMessageAvgOrderByAggregateInput
    _max?: CompanyStatusMessageMaxOrderByAggregateInput
    _min?: CompanyStatusMessageMinOrderByAggregateInput
    _sum?: CompanyStatusMessageSumOrderByAggregateInput
  }

  export type CompanyStatusMessageScalarWhereWithAggregatesInput = {
    AND?: CompanyStatusMessageScalarWhereWithAggregatesInput | CompanyStatusMessageScalarWhereWithAggregatesInput[]
    OR?: CompanyStatusMessageScalarWhereWithAggregatesInput[]
    NOT?: CompanyStatusMessageScalarWhereWithAggregatesInput | CompanyStatusMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyStatusMessage"> | number
    companyId?: IntWithAggregatesFilter<"CompanyStatusMessage"> | number
    senderId?: IntWithAggregatesFilter<"CompanyStatusMessage"> | number
    senderRole?: EnumUserRoleWithAggregatesFilter<"CompanyStatusMessage"> | $Enums.UserRole
    fromStatus?: EnumCompanyStatusWithAggregatesFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusWithAggregatesFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    message?: StringWithAggregatesFilter<"CompanyStatusMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyStatusMessage"> | Date | string
  }

  export type DirectorWhereInput = {
    AND?: DirectorWhereInput | DirectorWhereInput[]
    OR?: DirectorWhereInput[]
    NOT?: DirectorWhereInput | DirectorWhereInput[]
    id?: IntFilter<"Director"> | number
    companyId?: IntFilter<"Director"> | number
    directorName?: StringFilter<"Director"> | string
    email?: StringFilter<"Director"> | string
    addressLine1?: StringFilter<"Director"> | string
    addressLine2?: StringFilter<"Director"> | string
    country?: StringFilter<"Director"> | string
    postalCode?: StringFilter<"Director"> | string
    contactNumber?: StringFilter<"Director"> | string
    nationality?: StringFilter<"Director"> | string
    idType?: StringFilter<"Director"> | string
    idExpiryDate?: DateTimeFilter<"Director"> | Date | string
    idNumber?: StringFilter<"Director"> | string
    isShareholder?: BoolFilter<"Director"> | boolean
    identityProof?: StringFilter<"Director"> | string
    addressProof?: StringFilter<"Director"> | string
    dateOfBirth?: DateTimeFilter<"Director"> | Date | string
    createdAt?: DateTimeFilter<"Director"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DirectorOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    directorName?: SortOrder
    email?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    isShareholder?: SortOrder
    identityProof?: SortOrder
    addressProof?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DirectorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DirectorWhereInput | DirectorWhereInput[]
    OR?: DirectorWhereInput[]
    NOT?: DirectorWhereInput | DirectorWhereInput[]
    companyId?: IntFilter<"Director"> | number
    directorName?: StringFilter<"Director"> | string
    email?: StringFilter<"Director"> | string
    addressLine1?: StringFilter<"Director"> | string
    addressLine2?: StringFilter<"Director"> | string
    country?: StringFilter<"Director"> | string
    postalCode?: StringFilter<"Director"> | string
    contactNumber?: StringFilter<"Director"> | string
    nationality?: StringFilter<"Director"> | string
    idType?: StringFilter<"Director"> | string
    idExpiryDate?: DateTimeFilter<"Director"> | Date | string
    idNumber?: StringFilter<"Director"> | string
    isShareholder?: BoolFilter<"Director"> | boolean
    identityProof?: StringFilter<"Director"> | string
    addressProof?: StringFilter<"Director"> | string
    dateOfBirth?: DateTimeFilter<"Director"> | Date | string
    createdAt?: DateTimeFilter<"Director"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type DirectorOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    directorName?: SortOrder
    email?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    isShareholder?: SortOrder
    identityProof?: SortOrder
    addressProof?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    _count?: DirectorCountOrderByAggregateInput
    _avg?: DirectorAvgOrderByAggregateInput
    _max?: DirectorMaxOrderByAggregateInput
    _min?: DirectorMinOrderByAggregateInput
    _sum?: DirectorSumOrderByAggregateInput
  }

  export type DirectorScalarWhereWithAggregatesInput = {
    AND?: DirectorScalarWhereWithAggregatesInput | DirectorScalarWhereWithAggregatesInput[]
    OR?: DirectorScalarWhereWithAggregatesInput[]
    NOT?: DirectorScalarWhereWithAggregatesInput | DirectorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Director"> | number
    companyId?: IntWithAggregatesFilter<"Director"> | number
    directorName?: StringWithAggregatesFilter<"Director"> | string
    email?: StringWithAggregatesFilter<"Director"> | string
    addressLine1?: StringWithAggregatesFilter<"Director"> | string
    addressLine2?: StringWithAggregatesFilter<"Director"> | string
    country?: StringWithAggregatesFilter<"Director"> | string
    postalCode?: StringWithAggregatesFilter<"Director"> | string
    contactNumber?: StringWithAggregatesFilter<"Director"> | string
    nationality?: StringWithAggregatesFilter<"Director"> | string
    idType?: StringWithAggregatesFilter<"Director"> | string
    idExpiryDate?: DateTimeWithAggregatesFilter<"Director"> | Date | string
    idNumber?: StringWithAggregatesFilter<"Director"> | string
    isShareholder?: BoolWithAggregatesFilter<"Director"> | boolean
    identityProof?: StringWithAggregatesFilter<"Director"> | string
    addressProof?: StringWithAggregatesFilter<"Director"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Director"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Director"> | Date | string
  }

  export type ShareholderWhereInput = {
    AND?: ShareholderWhereInput | ShareholderWhereInput[]
    OR?: ShareholderWhereInput[]
    NOT?: ShareholderWhereInput | ShareholderWhereInput[]
    id?: IntFilter<"Shareholder"> | number
    companyId?: IntFilter<"Shareholder"> | number
    shareholderName?: StringFilter<"Shareholder"> | string
    email?: StringFilter<"Shareholder"> | string
    type?: EnumShareholderTypeFilter<"Shareholder"> | $Enums.ShareholderType
    addressLine1?: StringFilter<"Shareholder"> | string
    addressLine2?: StringFilter<"Shareholder"> | string
    country?: StringFilter<"Shareholder"> | string
    postalCode?: StringFilter<"Shareholder"> | string
    contactNumber?: StringFilter<"Shareholder"> | string
    nationality?: StringFilter<"Shareholder"> | string
    idType?: StringFilter<"Shareholder"> | string
    idExpiryDate?: DateTimeFilter<"Shareholder"> | Date | string
    idNumber?: StringFilter<"Shareholder"> | string
    dateOfBirth?: DateTimeFilter<"Shareholder"> | Date | string
    numberOfShares?: IntFilter<"Shareholder"> | number
    shareCapitalAllocation?: DecimalFilter<"Shareholder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ShareholderOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderName?: SortOrder
    email?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    dateOfBirth?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ShareholderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShareholderWhereInput | ShareholderWhereInput[]
    OR?: ShareholderWhereInput[]
    NOT?: ShareholderWhereInput | ShareholderWhereInput[]
    companyId?: IntFilter<"Shareholder"> | number
    shareholderName?: StringFilter<"Shareholder"> | string
    email?: StringFilter<"Shareholder"> | string
    type?: EnumShareholderTypeFilter<"Shareholder"> | $Enums.ShareholderType
    addressLine1?: StringFilter<"Shareholder"> | string
    addressLine2?: StringFilter<"Shareholder"> | string
    country?: StringFilter<"Shareholder"> | string
    postalCode?: StringFilter<"Shareholder"> | string
    contactNumber?: StringFilter<"Shareholder"> | string
    nationality?: StringFilter<"Shareholder"> | string
    idType?: StringFilter<"Shareholder"> | string
    idExpiryDate?: DateTimeFilter<"Shareholder"> | Date | string
    idNumber?: StringFilter<"Shareholder"> | string
    dateOfBirth?: DateTimeFilter<"Shareholder"> | Date | string
    numberOfShares?: IntFilter<"Shareholder"> | number
    shareCapitalAllocation?: DecimalFilter<"Shareholder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type ShareholderOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderName?: SortOrder
    email?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    dateOfBirth?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
    createdAt?: SortOrder
    _count?: ShareholderCountOrderByAggregateInput
    _avg?: ShareholderAvgOrderByAggregateInput
    _max?: ShareholderMaxOrderByAggregateInput
    _min?: ShareholderMinOrderByAggregateInput
    _sum?: ShareholderSumOrderByAggregateInput
  }

  export type ShareholderScalarWhereWithAggregatesInput = {
    AND?: ShareholderScalarWhereWithAggregatesInput | ShareholderScalarWhereWithAggregatesInput[]
    OR?: ShareholderScalarWhereWithAggregatesInput[]
    NOT?: ShareholderScalarWhereWithAggregatesInput | ShareholderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shareholder"> | number
    companyId?: IntWithAggregatesFilter<"Shareholder"> | number
    shareholderName?: StringWithAggregatesFilter<"Shareholder"> | string
    email?: StringWithAggregatesFilter<"Shareholder"> | string
    type?: EnumShareholderTypeWithAggregatesFilter<"Shareholder"> | $Enums.ShareholderType
    addressLine1?: StringWithAggregatesFilter<"Shareholder"> | string
    addressLine2?: StringWithAggregatesFilter<"Shareholder"> | string
    country?: StringWithAggregatesFilter<"Shareholder"> | string
    postalCode?: StringWithAggregatesFilter<"Shareholder"> | string
    contactNumber?: StringWithAggregatesFilter<"Shareholder"> | string
    nationality?: StringWithAggregatesFilter<"Shareholder"> | string
    idType?: StringWithAggregatesFilter<"Shareholder"> | string
    idExpiryDate?: DateTimeWithAggregatesFilter<"Shareholder"> | Date | string
    idNumber?: StringWithAggregatesFilter<"Shareholder"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Shareholder"> | Date | string
    numberOfShares?: IntWithAggregatesFilter<"Shareholder"> | number
    shareCapitalAllocation?: DecimalWithAggregatesFilter<"Shareholder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Shareholder"> | Date | string
  }

  export type CompanyDocumentWhereInput = {
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    id?: IntFilter<"CompanyDocument"> | number
    companyId?: IntFilter<"CompanyDocument"> | number
    documentLabel?: StringFilter<"CompanyDocument"> | string
    documentPath?: StringFilter<"CompanyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"CompanyDocument"> | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFilter<"CompanyDocument"> | $Enums.DocumentPurpose
    thumbnail?: StringNullableFilter<"CompanyDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CompanyDocument"> | Date | string
    isVerified?: BoolFilter<"CompanyDocument"> | boolean
    uploadedBy?: IntFilter<"CompanyDocument"> | number
    uploadedRole?: EnumUserRoleFilter<"CompanyDocument"> | $Enums.UserRole
    uploadedFor?: IntNullableFilter<"CompanyDocument"> | number | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    forUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CompanyDocumentOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    documentLabel?: SortOrder
    documentPath?: SortOrder
    documentType?: SortOrder
    purpose?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    isVerified?: SortOrder
    uploadedBy?: SortOrder
    uploadedRole?: SortOrder
    uploadedFor?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    forUser?: UserOrderByWithRelationInput
  }

  export type CompanyDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    companyId?: IntFilter<"CompanyDocument"> | number
    documentLabel?: StringFilter<"CompanyDocument"> | string
    documentPath?: StringFilter<"CompanyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"CompanyDocument"> | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFilter<"CompanyDocument"> | $Enums.DocumentPurpose
    thumbnail?: StringNullableFilter<"CompanyDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CompanyDocument"> | Date | string
    isVerified?: BoolFilter<"CompanyDocument"> | boolean
    uploadedBy?: IntFilter<"CompanyDocument"> | number
    uploadedRole?: EnumUserRoleFilter<"CompanyDocument"> | $Enums.UserRole
    uploadedFor?: IntNullableFilter<"CompanyDocument"> | number | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    forUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CompanyDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    documentLabel?: SortOrder
    documentPath?: SortOrder
    documentType?: SortOrder
    purpose?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    isVerified?: SortOrder
    uploadedBy?: SortOrder
    uploadedRole?: SortOrder
    uploadedFor?: SortOrderInput | SortOrder
    _count?: CompanyDocumentCountOrderByAggregateInput
    _avg?: CompanyDocumentAvgOrderByAggregateInput
    _max?: CompanyDocumentMaxOrderByAggregateInput
    _min?: CompanyDocumentMinOrderByAggregateInput
    _sum?: CompanyDocumentSumOrderByAggregateInput
  }

  export type CompanyDocumentScalarWhereWithAggregatesInput = {
    AND?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    OR?: CompanyDocumentScalarWhereWithAggregatesInput[]
    NOT?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyDocument"> | number
    companyId?: IntWithAggregatesFilter<"CompanyDocument"> | number
    documentLabel?: StringWithAggregatesFilter<"CompanyDocument"> | string
    documentPath?: StringWithAggregatesFilter<"CompanyDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"CompanyDocument"> | $Enums.DocumentType
    purpose?: EnumDocumentPurposeWithAggregatesFilter<"CompanyDocument"> | $Enums.DocumentPurpose
    thumbnail?: StringNullableWithAggregatesFilter<"CompanyDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"CompanyDocument"> | Date | string
    isVerified?: BoolWithAggregatesFilter<"CompanyDocument"> | boolean
    uploadedBy?: IntWithAggregatesFilter<"CompanyDocument"> | number
    uploadedRole?: EnumUserRoleWithAggregatesFilter<"CompanyDocument"> | $Enums.UserRole
    uploadedFor?: IntNullableWithAggregatesFilter<"CompanyDocument"> | number | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    companyId?: IntNullableFilter<"Payment"> | number | null
    userId?: IntNullableFilter<"Payment"> | number | null
    stagingCompanyId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentReference?: StringFilter<"Payment"> | string
    services?: StringFilter<"Payment"> | string
    refunds?: RefundListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    stagingCompany?: XOR<StagingCompanyNullableScalarRelationFilter, StagingCompanyWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    stagingCompanyId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paymentReference?: SortOrder
    services?: SortOrder
    refunds?: RefundOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    stagingCompany?: StagingCompanyOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    paymentReference?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    companyId?: IntNullableFilter<"Payment"> | number | null
    userId?: IntNullableFilter<"Payment"> | number | null
    stagingCompanyId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    services?: StringFilter<"Payment"> | string
    refunds?: RefundListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    stagingCompany?: XOR<StagingCompanyNullableScalarRelationFilter, StagingCompanyWhereInput> | null
  }, "id" | "paymentReference">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    stagingCompanyId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paymentReference?: SortOrder
    services?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    companyId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    stagingCompanyId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentReference?: StringWithAggregatesFilter<"Payment"> | string
    services?: StringWithAggregatesFilter<"Payment"> | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: IntFilter<"Refund"> | number
    paymentId?: IntFilter<"Refund"> | number
    refundId?: StringFilter<"Refund"> | string
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    refundId?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    paymentId?: IntFilter<"Refund"> | number
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id" | "refundId">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Refund"> | number
    paymentId?: IntWithAggregatesFilter<"Refund"> | number
    refundId?: StringWithAggregatesFilter<"Refund"> | string
    amount?: DecimalWithAggregatesFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusWithAggregatesFilter<"Refund"> | $Enums.RefundStatus
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    serviceName?: StringFilter<"Service"> | string
    serviceDescription?: StringFilter<"Service"> | string
    cost?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    companyServices?: CompanyServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceDescription?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    companyServices?: CompanyServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    serviceName?: StringFilter<"Service"> | string
    serviceDescription?: StringFilter<"Service"> | string
    cost?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    companyServices?: CompanyServiceListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceDescription?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    serviceName?: StringWithAggregatesFilter<"Service"> | string
    serviceDescription?: StringWithAggregatesFilter<"Service"> | string
    cost?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Service"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type CompanyServiceWhereInput = {
    AND?: CompanyServiceWhereInput | CompanyServiceWhereInput[]
    OR?: CompanyServiceWhereInput[]
    NOT?: CompanyServiceWhereInput | CompanyServiceWhereInput[]
    id?: IntFilter<"CompanyService"> | number
    companyId?: IntFilter<"CompanyService"> | number
    serviceId?: IntFilter<"CompanyService"> | number
    updateDate?: DateTimeFilter<"CompanyService"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type CompanyServiceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    updateDate?: SortOrder
    company?: CompanyOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type CompanyServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyServiceWhereInput | CompanyServiceWhereInput[]
    OR?: CompanyServiceWhereInput[]
    NOT?: CompanyServiceWhereInput | CompanyServiceWhereInput[]
    companyId?: IntFilter<"CompanyService"> | number
    serviceId?: IntFilter<"CompanyService"> | number
    updateDate?: DateTimeFilter<"CompanyService"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type CompanyServiceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    updateDate?: SortOrder
    _count?: CompanyServiceCountOrderByAggregateInput
    _avg?: CompanyServiceAvgOrderByAggregateInput
    _max?: CompanyServiceMaxOrderByAggregateInput
    _min?: CompanyServiceMinOrderByAggregateInput
    _sum?: CompanyServiceSumOrderByAggregateInput
  }

  export type CompanyServiceScalarWhereWithAggregatesInput = {
    AND?: CompanyServiceScalarWhereWithAggregatesInput | CompanyServiceScalarWhereWithAggregatesInput[]
    OR?: CompanyServiceScalarWhereWithAggregatesInput[]
    NOT?: CompanyServiceScalarWhereWithAggregatesInput | CompanyServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyService"> | number
    companyId?: IntWithAggregatesFilter<"CompanyService"> | number
    serviceId?: IntWithAggregatesFilter<"CompanyService"> | number
    updateDate?: DateTimeWithAggregatesFilter<"CompanyService"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InsightRecommendationWhereInput = {
    AND?: InsightRecommendationWhereInput | InsightRecommendationWhereInput[]
    OR?: InsightRecommendationWhereInput[]
    NOT?: InsightRecommendationWhereInput | InsightRecommendationWhereInput[]
    id?: IntFilter<"InsightRecommendation"> | number
    userId?: IntFilter<"InsightRecommendation"> | number
    content?: StringFilter<"InsightRecommendation"> | string
    sampleDocUrls?: StringNullableListFilter<"InsightRecommendation">
    createdAt?: DateTimeFilter<"InsightRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InsightRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sampleDocUrls?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InsightRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InsightRecommendationWhereInput | InsightRecommendationWhereInput[]
    OR?: InsightRecommendationWhereInput[]
    NOT?: InsightRecommendationWhereInput | InsightRecommendationWhereInput[]
    userId?: IntFilter<"InsightRecommendation"> | number
    content?: StringFilter<"InsightRecommendation"> | string
    sampleDocUrls?: StringNullableListFilter<"InsightRecommendation">
    createdAt?: DateTimeFilter<"InsightRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InsightRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sampleDocUrls?: SortOrder
    createdAt?: SortOrder
    _count?: InsightRecommendationCountOrderByAggregateInput
    _avg?: InsightRecommendationAvgOrderByAggregateInput
    _max?: InsightRecommendationMaxOrderByAggregateInput
    _min?: InsightRecommendationMinOrderByAggregateInput
    _sum?: InsightRecommendationSumOrderByAggregateInput
  }

  export type InsightRecommendationScalarWhereWithAggregatesInput = {
    AND?: InsightRecommendationScalarWhereWithAggregatesInput | InsightRecommendationScalarWhereWithAggregatesInput[]
    OR?: InsightRecommendationScalarWhereWithAggregatesInput[]
    NOT?: InsightRecommendationScalarWhereWithAggregatesInput | InsightRecommendationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InsightRecommendation"> | number
    userId?: IntWithAggregatesFilter<"InsightRecommendation"> | number
    content?: StringWithAggregatesFilter<"InsightRecommendation"> | string
    sampleDocUrls?: StringNullableListFilter<"InsightRecommendation">
    createdAt?: DateTimeWithAggregatesFilter<"InsightRecommendation"> | Date | string
  }

  export type CalendarActionWhereInput = {
    AND?: CalendarActionWhereInput | CalendarActionWhereInput[]
    OR?: CalendarActionWhereInput[]
    NOT?: CalendarActionWhereInput | CalendarActionWhereInput[]
    id?: IntFilter<"CalendarAction"> | number
    title?: StringFilter<"CalendarAction"> | string
    userId?: IntFilter<"CalendarAction"> | number
    companyId?: IntFilter<"CalendarAction"> | number
    dueDate?: DateTimeFilter<"CalendarAction"> | Date | string
    notes?: StringNullableFilter<"CalendarAction"> | string | null
    status?: StringFilter<"CalendarAction"> | string
    createdBy?: IntNullableFilter<"CalendarAction"> | number | null
    createdByRole?: EnumUserRoleFilter<"CalendarAction"> | $Enums.UserRole
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CalendarActionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByRole?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type CalendarActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CalendarActionWhereInput | CalendarActionWhereInput[]
    OR?: CalendarActionWhereInput[]
    NOT?: CalendarActionWhereInput | CalendarActionWhereInput[]
    title?: StringFilter<"CalendarAction"> | string
    userId?: IntFilter<"CalendarAction"> | number
    companyId?: IntFilter<"CalendarAction"> | number
    dueDate?: DateTimeFilter<"CalendarAction"> | Date | string
    notes?: StringNullableFilter<"CalendarAction"> | string | null
    status?: StringFilter<"CalendarAction"> | string
    createdBy?: IntNullableFilter<"CalendarAction"> | number | null
    createdByRole?: EnumUserRoleFilter<"CalendarAction"> | $Enums.UserRole
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CalendarActionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByRole?: SortOrder
    _count?: CalendarActionCountOrderByAggregateInput
    _avg?: CalendarActionAvgOrderByAggregateInput
    _max?: CalendarActionMaxOrderByAggregateInput
    _min?: CalendarActionMinOrderByAggregateInput
    _sum?: CalendarActionSumOrderByAggregateInput
  }

  export type CalendarActionScalarWhereWithAggregatesInput = {
    AND?: CalendarActionScalarWhereWithAggregatesInput | CalendarActionScalarWhereWithAggregatesInput[]
    OR?: CalendarActionScalarWhereWithAggregatesInput[]
    NOT?: CalendarActionScalarWhereWithAggregatesInput | CalendarActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalendarAction"> | number
    title?: StringWithAggregatesFilter<"CalendarAction"> | string
    userId?: IntWithAggregatesFilter<"CalendarAction"> | number
    companyId?: IntWithAggregatesFilter<"CalendarAction"> | number
    dueDate?: DateTimeWithAggregatesFilter<"CalendarAction"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"CalendarAction"> | string | null
    status?: StringWithAggregatesFilter<"CalendarAction"> | string
    createdBy?: IntNullableWithAggregatesFilter<"CalendarAction"> | number | null
    createdByRole?: EnumUserRoleWithAggregatesFilter<"CalendarAction"> | $Enums.UserRole
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    sentAt?: DateTimeFilter<"ChatMessage"> | Date | string
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    receiver?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    sentAt?: DateTimeFilter<"ChatMessage"> | Date | string
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    senderId?: IntWithAggregatesFilter<"ChatMessage"> | number
    receiverId?: IntWithAggregatesFilter<"ChatMessage"> | number
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    sentAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type DashboardStateWhereInput = {
    AND?: DashboardStateWhereInput | DashboardStateWhereInput[]
    OR?: DashboardStateWhereInput[]
    NOT?: DashboardStateWhereInput | DashboardStateWhereInput[]
    id?: IntFilter<"DashboardState"> | number
    companyId?: IntFilter<"DashboardState"> | number
    step?: StringFilter<"DashboardState"> | string
    completedAt?: DateTimeNullableFilter<"DashboardState"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DashboardStateOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    step?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type DashboardStateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId?: number
    AND?: DashboardStateWhereInput | DashboardStateWhereInput[]
    OR?: DashboardStateWhereInput[]
    NOT?: DashboardStateWhereInput | DashboardStateWhereInput[]
    step?: StringFilter<"DashboardState"> | string
    completedAt?: DateTimeNullableFilter<"DashboardState"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId">

  export type DashboardStateOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    step?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: DashboardStateCountOrderByAggregateInput
    _avg?: DashboardStateAvgOrderByAggregateInput
    _max?: DashboardStateMaxOrderByAggregateInput
    _min?: DashboardStateMinOrderByAggregateInput
    _sum?: DashboardStateSumOrderByAggregateInput
  }

  export type DashboardStateScalarWhereWithAggregatesInput = {
    AND?: DashboardStateScalarWhereWithAggregatesInput | DashboardStateScalarWhereWithAggregatesInput[]
    OR?: DashboardStateScalarWhereWithAggregatesInput[]
    NOT?: DashboardStateScalarWhereWithAggregatesInput | DashboardStateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DashboardState"> | number
    companyId?: IntWithAggregatesFilter<"DashboardState"> | number
    step?: StringWithAggregatesFilter<"DashboardState"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DashboardState"> | Date | string | null
  }

  export type RoleAssignmentWhereInput = {
    AND?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    OR?: RoleAssignmentWhereInput[]
    NOT?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    id?: IntFilter<"RoleAssignment"> | number
    agentId?: IntFilter<"RoleAssignment"> | number
    companyId?: IntFilter<"RoleAssignment"> | number
    role?: EnumUserRoleFilter<"RoleAssignment"> | $Enums.UserRole
    assignedAt?: DateTimeFilter<"RoleAssignment"> | Date | string
    agent?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type RoleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
    agent?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type RoleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    OR?: RoleAssignmentWhereInput[]
    NOT?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    agentId?: IntFilter<"RoleAssignment"> | number
    companyId?: IntFilter<"RoleAssignment"> | number
    role?: EnumUserRoleFilter<"RoleAssignment"> | $Enums.UserRole
    assignedAt?: DateTimeFilter<"RoleAssignment"> | Date | string
    agent?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type RoleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
    _count?: RoleAssignmentCountOrderByAggregateInput
    _avg?: RoleAssignmentAvgOrderByAggregateInput
    _max?: RoleAssignmentMaxOrderByAggregateInput
    _min?: RoleAssignmentMinOrderByAggregateInput
    _sum?: RoleAssignmentSumOrderByAggregateInput
  }

  export type RoleAssignmentScalarWhereWithAggregatesInput = {
    AND?: RoleAssignmentScalarWhereWithAggregatesInput | RoleAssignmentScalarWhereWithAggregatesInput[]
    OR?: RoleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: RoleAssignmentScalarWhereWithAggregatesInput | RoleAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleAssignment"> | number
    agentId?: IntWithAggregatesFilter<"RoleAssignment"> | number
    companyId?: IntWithAggregatesFilter<"RoleAssignment"> | number
    role?: EnumUserRoleWithAggregatesFilter<"RoleAssignment"> | $Enums.UserRole
    assignedAt?: DateTimeWithAggregatesFilter<"RoleAssignment"> | Date | string
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: IntFilter<"Article"> | number
    title?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    status?: StringFilter<"Article"> | string
    createdAt?: DateTimeFilter<"Article"> | Date | string
    publishedAt?: DateTimeFilter<"Article"> | Date | string
    imagePath?: StringFilter<"Article"> | string
    views?: IntFilter<"Article"> | number
    hashtag?: StringFilter<"Article"> | string
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    publishedAt?: SortOrder
    imagePath?: SortOrder
    views?: SortOrder
    hashtag?: SortOrder
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    title?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    status?: StringFilter<"Article"> | string
    createdAt?: DateTimeFilter<"Article"> | Date | string
    publishedAt?: DateTimeFilter<"Article"> | Date | string
    imagePath?: StringFilter<"Article"> | string
    views?: IntFilter<"Article"> | number
    hashtag?: StringFilter<"Article"> | string
  }, "id">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    publishedAt?: SortOrder
    imagePath?: SortOrder
    views?: SortOrder
    hashtag?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Article"> | number
    title?: StringWithAggregatesFilter<"Article"> | string
    content?: StringWithAggregatesFilter<"Article"> | string
    status?: StringWithAggregatesFilter<"Article"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    publishedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    imagePath?: StringWithAggregatesFilter<"Article"> | string
    views?: IntWithAggregatesFilter<"Article"> | number
    hashtag?: StringWithAggregatesFilter<"Article"> | string
  }

  export type ContactUsWhereInput = {
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    id?: IntFilter<"ContactUs"> | number
    name?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phone?: StringFilter<"ContactUs"> | string
    subject?: StringFilter<"ContactUs"> | string
    details?: StringFilter<"ContactUs"> | string
    status?: StringFilter<"ContactUs"> | string
    ticketUpdate?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    details?: SortOrder
    status?: SortOrder
    ticketUpdate?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    name?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    phone?: StringFilter<"ContactUs"> | string
    subject?: StringFilter<"ContactUs"> | string
    details?: StringFilter<"ContactUs"> | string
    status?: StringFilter<"ContactUs"> | string
    ticketUpdate?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
  }, "id">

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    details?: SortOrder
    status?: SortOrder
    ticketUpdate?: SortOrder
    createdAt?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _avg?: ContactUsAvgOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
    _sum?: ContactUsSumOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    OR?: ContactUsScalarWhereWithAggregatesInput[]
    NOT?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactUs"> | number
    name?: StringWithAggregatesFilter<"ContactUs"> | string
    email?: StringWithAggregatesFilter<"ContactUs"> | string
    phone?: StringWithAggregatesFilter<"ContactUs"> | string
    subject?: StringWithAggregatesFilter<"ContactUs"> | string
    details?: StringWithAggregatesFilter<"ContactUs"> | string
    status?: StringWithAggregatesFilter<"ContactUs"> | string
    ticketUpdate?: StringWithAggregatesFilter<"ContactUs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: IntFilter<"FAQ"> | number
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _avg?: FAQAvgOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
    _sum?: FAQSumOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FAQ"> | number
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
  }

  export type StagingCompanyWhereInput = {
    AND?: StagingCompanyWhereInput | StagingCompanyWhereInput[]
    OR?: StagingCompanyWhereInput[]
    NOT?: StagingCompanyWhereInput | StagingCompanyWhereInput[]
    id?: StringFilter<"StagingCompany"> | string
    companyName?: StringFilter<"StagingCompany"> | string
    contactEmail?: StringNullableFilter<"StagingCompany"> | string | null
    contactNumber?: StringNullableFilter<"StagingCompany"> | string | null
    isEmailVerified?: BoolFilter<"StagingCompany"> | boolean
    isPaid?: BoolFilter<"StagingCompany"> | boolean
    isCompleted?: BoolFilter<"StagingCompany"> | boolean
    isRejected?: BoolFilter<"StagingCompany"> | boolean
    step?: IntFilter<"StagingCompany"> | number
    registrationDate?: DateTimeNullableFilter<"StagingCompany"> | Date | string | null
    directorData?: StringNullableFilter<"StagingCompany"> | string | null
    shareholderData?: StringNullableFilter<"StagingCompany"> | string | null
    servicesSelected?: StringNullableFilter<"StagingCompany"> | string | null
    createdAt?: DateTimeFilter<"StagingCompany"> | Date | string
    razorpayOrderId?: StringNullableFilter<"StagingCompany"> | string | null
    emailOtp?: StringNullableFilter<"StagingCompany"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"StagingCompany"> | Date | string | null
    payments?: PaymentListRelationFilter
  }

  export type StagingCompanyOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    isPaid?: SortOrder
    isCompleted?: SortOrder
    isRejected?: SortOrder
    step?: SortOrder
    registrationDate?: SortOrderInput | SortOrder
    directorData?: SortOrderInput | SortOrder
    shareholderData?: SortOrderInput | SortOrder
    servicesSelected?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type StagingCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StagingCompanyWhereInput | StagingCompanyWhereInput[]
    OR?: StagingCompanyWhereInput[]
    NOT?: StagingCompanyWhereInput | StagingCompanyWhereInput[]
    companyName?: StringFilter<"StagingCompany"> | string
    contactEmail?: StringNullableFilter<"StagingCompany"> | string | null
    contactNumber?: StringNullableFilter<"StagingCompany"> | string | null
    isEmailVerified?: BoolFilter<"StagingCompany"> | boolean
    isPaid?: BoolFilter<"StagingCompany"> | boolean
    isCompleted?: BoolFilter<"StagingCompany"> | boolean
    isRejected?: BoolFilter<"StagingCompany"> | boolean
    step?: IntFilter<"StagingCompany"> | number
    registrationDate?: DateTimeNullableFilter<"StagingCompany"> | Date | string | null
    directorData?: StringNullableFilter<"StagingCompany"> | string | null
    shareholderData?: StringNullableFilter<"StagingCompany"> | string | null
    servicesSelected?: StringNullableFilter<"StagingCompany"> | string | null
    createdAt?: DateTimeFilter<"StagingCompany"> | Date | string
    razorpayOrderId?: StringNullableFilter<"StagingCompany"> | string | null
    emailOtp?: StringNullableFilter<"StagingCompany"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"StagingCompany"> | Date | string | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type StagingCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    isPaid?: SortOrder
    isCompleted?: SortOrder
    isRejected?: SortOrder
    step?: SortOrder
    registrationDate?: SortOrderInput | SortOrder
    directorData?: SortOrderInput | SortOrder
    shareholderData?: SortOrderInput | SortOrder
    servicesSelected?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    _count?: StagingCompanyCountOrderByAggregateInput
    _avg?: StagingCompanyAvgOrderByAggregateInput
    _max?: StagingCompanyMaxOrderByAggregateInput
    _min?: StagingCompanyMinOrderByAggregateInput
    _sum?: StagingCompanySumOrderByAggregateInput
  }

  export type StagingCompanyScalarWhereWithAggregatesInput = {
    AND?: StagingCompanyScalarWhereWithAggregatesInput | StagingCompanyScalarWhereWithAggregatesInput[]
    OR?: StagingCompanyScalarWhereWithAggregatesInput[]
    NOT?: StagingCompanyScalarWhereWithAggregatesInput | StagingCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StagingCompany"> | string
    companyName?: StringWithAggregatesFilter<"StagingCompany"> | string
    contactEmail?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    isEmailVerified?: BoolWithAggregatesFilter<"StagingCompany"> | boolean
    isPaid?: BoolWithAggregatesFilter<"StagingCompany"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"StagingCompany"> | boolean
    isRejected?: BoolWithAggregatesFilter<"StagingCompany"> | boolean
    step?: IntWithAggregatesFilter<"StagingCompany"> | number
    registrationDate?: DateTimeNullableWithAggregatesFilter<"StagingCompany"> | Date | string | null
    directorData?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    shareholderData?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    servicesSelected?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StagingCompany"> | Date | string
    razorpayOrderId?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    emailOtp?: StringNullableWithAggregatesFilter<"StagingCompany"> | string | null
    emailOtpExpires?: DateTimeNullableWithAggregatesFilter<"StagingCompany"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    actorId?: IntFilter<"AuditLog"> | number
    role?: EnumUserRoleFilter<"AuditLog"> | $Enums.UserRole
    action?: StringFilter<"AuditLog"> | string
    target?: StringFilter<"AuditLog"> | string
    companyId?: IntNullableFilter<"AuditLog"> | number | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
    action?: SortOrder
    target?: SortOrder
    companyId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    actor?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: IntFilter<"AuditLog"> | number
    role?: EnumUserRoleFilter<"AuditLog"> | $Enums.UserRole
    action?: StringFilter<"AuditLog"> | string
    target?: StringFilter<"AuditLog"> | string
    companyId?: IntNullableFilter<"AuditLog"> | number | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
    action?: SortOrder
    target?: SortOrder
    companyId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    actorId?: IntWithAggregatesFilter<"AuditLog"> | number
    role?: EnumUserRoleWithAggregatesFilter<"AuditLog"> | $Enums.UserRole
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    target?: StringWithAggregatesFilter<"AuditLog"> | string
    companyId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RegisteredCompanyNameWhereInput = {
    AND?: RegisteredCompanyNameWhereInput | RegisteredCompanyNameWhereInput[]
    OR?: RegisteredCompanyNameWhereInput[]
    NOT?: RegisteredCompanyNameWhereInput | RegisteredCompanyNameWhereInput[]
    id?: IntFilter<"RegisteredCompanyName"> | number
    companyName?: StringFilter<"RegisteredCompanyName"> | string
    createdAt?: DateTimeFilter<"RegisteredCompanyName"> | Date | string
  }

  export type RegisteredCompanyNameOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type RegisteredCompanyNameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyName?: string
    AND?: RegisteredCompanyNameWhereInput | RegisteredCompanyNameWhereInput[]
    OR?: RegisteredCompanyNameWhereInput[]
    NOT?: RegisteredCompanyNameWhereInput | RegisteredCompanyNameWhereInput[]
    createdAt?: DateTimeFilter<"RegisteredCompanyName"> | Date | string
  }, "id" | "companyName">

  export type RegisteredCompanyNameOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    _count?: RegisteredCompanyNameCountOrderByAggregateInput
    _avg?: RegisteredCompanyNameAvgOrderByAggregateInput
    _max?: RegisteredCompanyNameMaxOrderByAggregateInput
    _min?: RegisteredCompanyNameMinOrderByAggregateInput
    _sum?: RegisteredCompanyNameSumOrderByAggregateInput
  }

  export type RegisteredCompanyNameScalarWhereWithAggregatesInput = {
    AND?: RegisteredCompanyNameScalarWhereWithAggregatesInput | RegisteredCompanyNameScalarWhereWithAggregatesInput[]
    OR?: RegisteredCompanyNameScalarWhereWithAggregatesInput[]
    NOT?: RegisteredCompanyNameScalarWhereWithAggregatesInput | RegisteredCompanyNameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegisteredCompanyName"> | number
    companyName?: StringWithAggregatesFilter<"RegisteredCompanyName"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RegisteredCompanyName"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
  }

  export type CompanyUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyUncheckedUpdateManyInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyStatusMessageCreateInput = {
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutRevertMessageInput
    sender: UserCreateNestedOneWithoutRevertMessageInput
  }

  export type CompanyStatusMessageUncheckedCreateInput = {
    id?: number
    companyId: number
    senderId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type CompanyStatusMessageUpdateInput = {
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutRevertMessageNestedInput
    sender?: UserUpdateOneRequiredWithoutRevertMessageNestedInput
  }

  export type CompanyStatusMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageCreateManyInput = {
    id?: number
    companyId: number
    senderId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type CompanyStatusMessageUpdateManyMutationInput = {
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorCreateInput = {
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutDirectorsInput
  }

  export type DirectorUncheckedCreateInput = {
    id?: number
    companyId: number
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
  }

  export type DirectorUpdateInput = {
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDirectorsNestedInput
  }

  export type DirectorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorCreateManyInput = {
    id?: number
    companyId: number
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
  }

  export type DirectorUpdateManyMutationInput = {
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderCreateInput = {
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareholdersInput
  }

  export type ShareholderUncheckedCreateInput = {
    id?: number
    companyId: number
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ShareholderUpdateInput = {
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareholdersNestedInput
  }

  export type ShareholderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderCreateManyInput = {
    id?: number
    companyId: number
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ShareholderUpdateManyMutationInput = {
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentCreateInput = {
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    company: CompanyCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedDocsInput
    forUser?: UserCreateNestedOneWithoutReceivedDocsInput
  }

  export type CompanyDocumentUncheckedCreateInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyDocumentUpdateInput = {
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocsNestedInput
    forUser?: UserUpdateOneWithoutReceivedDocsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyDocumentCreateManyInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyDocumentUpdateManyMutationInput = {
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CompanyDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateInput = {
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    company?: CompanyCreateNestedOneWithoutPaymentsInput
    user?: UserCreateNestedOneWithoutPaymentsInput
    stagingCompany?: StagingCompanyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    companyId?: number | null
    userId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    company?: CompanyUpdateOneWithoutPaymentsNestedInput
    user?: UserUpdateOneWithoutPaymentsNestedInput
    stagingCompany?: StagingCompanyUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: number
    companyId?: number | null
    userId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
  }

  export type PaymentUpdateManyMutationInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }

  export type RefundCreateInput = {
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: number
    paymentId: number
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
  }

  export type RefundUpdateInput = {
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyInput = {
    id?: number
    paymentId: number
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
  }

  export type RefundUpdateManyMutationInput = {
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    serviceName: string
    serviceDescription: string
    cost: Decimal | DecimalJsLike | number | string
    status: string
    createdAt?: Date | string
    companyServices?: CompanyServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    serviceName: string
    serviceDescription: string
    cost: Decimal | DecimalJsLike | number | string
    status: string
    createdAt?: Date | string
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyServices?: CompanyServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    serviceName: string
    serviceDescription: string
    cost: Decimal | DecimalJsLike | number | string
    status: string
    createdAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceCreateInput = {
    updateDate: Date | string
    company: CompanyCreateNestedOneWithoutCompanyServicesInput
    service: ServiceCreateNestedOneWithoutCompanyServicesInput
  }

  export type CompanyServiceUncheckedCreateInput = {
    id?: number
    companyId: number
    serviceId: number
    updateDate: Date | string
  }

  export type CompanyServiceUpdateInput = {
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutCompanyServicesNestedInput
  }

  export type CompanyServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceCreateManyInput = {
    id?: number
    companyId: number
    serviceId: number
    updateDate: Date | string
  }

  export type CompanyServiceUpdateManyMutationInput = {
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightRecommendationCreateInput = {
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
  }

  export type InsightRecommendationUncheckedCreateInput = {
    id?: number
    userId: number
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
  }

  export type InsightRecommendationUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type InsightRecommendationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightRecommendationCreateManyInput = {
    id?: number
    userId: number
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
  }

  export type InsightRecommendationUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightRecommendationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarActionCreateInput = {
    title: string
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
    user: UserCreateNestedOneWithoutAssignedTasksInput
    company: CompanyCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutCalendarActionInput
  }

  export type CalendarActionUncheckedCreateInput = {
    id?: number
    title: string
    userId: number
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    user?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    company?: CompanyUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutCalendarActionNestedInput
  }

  export type CalendarActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionCreateManyInput = {
    id?: number
    title: string
    userId: number
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type ChatMessageCreateInput = {
    content: string
    sentAt?: Date | string
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    sentAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    sentAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardStateCreateInput = {
    step: string
    completedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutDashboardStateInput
  }

  export type DashboardStateUncheckedCreateInput = {
    id?: number
    companyId: number
    step: string
    completedAt?: Date | string | null
  }

  export type DashboardStateUpdateInput = {
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutDashboardStateNestedInput
  }

  export type DashboardStateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardStateCreateManyInput = {
    id?: number
    companyId: number
    step: string
    completedAt?: Date | string | null
  }

  export type DashboardStateUpdateManyMutationInput = {
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardStateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleAssignmentCreateInput = {
    role: $Enums.UserRole
    assignedAt?: Date | string
    agent: UserCreateNestedOneWithoutAssignedRolesInput
    company: CompanyCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateInput = {
    id?: number
    agentId: number
    companyId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type RoleAssignmentUpdateInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneRequiredWithoutAssignedRolesNestedInput
    company?: CompanyUpdateOneRequiredWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleAssignmentCreateManyInput = {
    id?: number
    agentId: number
    companyId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type RoleAssignmentUpdateManyMutationInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCreateInput = {
    title: string
    content: string
    status: string
    createdAt?: Date | string
    publishedAt: Date | string
    imagePath: string
    views: number
    hashtag: string
  }

  export type ArticleUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    status: string
    createdAt?: Date | string
    publishedAt: Date | string
    imagePath: string
    views: number
    hashtag: string
  }

  export type ArticleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCreateManyInput = {
    id?: number
    title: string
    content: string
    status: string
    createdAt?: Date | string
    publishedAt: Date | string
    imagePath: string
    views: number
    hashtag: string
  }

  export type ArticleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsCreateInput = {
    name: string
    email: string
    phone: string
    subject: string
    details: string
    status: string
    ticketUpdate: string
    createdAt?: Date | string
  }

  export type ContactUsUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    subject: string
    details: string
    status: string
    ticketUpdate: string
    createdAt?: Date | string
  }

  export type ContactUsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ticketUpdate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ticketUpdate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    subject: string
    details: string
    status: string
    ticketUpdate: string
    createdAt?: Date | string
  }

  export type ContactUsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ticketUpdate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ticketUpdate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateInput = {
    question: string
    answer: string
  }

  export type FAQUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
  }

  export type FAQUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQCreateManyInput = {
    id?: number
    question: string
    answer: string
  }

  export type FAQUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StagingCompanyCreateInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactNumber?: string | null
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step: number
    registrationDate?: Date | string | null
    directorData?: string | null
    shareholderData?: string | null
    servicesSelected?: string | null
    createdAt?: Date | string
    razorpayOrderId?: string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    payments?: PaymentCreateNestedManyWithoutStagingCompanyInput
  }

  export type StagingCompanyUncheckedCreateInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactNumber?: string | null
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step: number
    registrationDate?: Date | string | null
    directorData?: string | null
    shareholderData?: string | null
    servicesSelected?: string | null
    createdAt?: Date | string
    razorpayOrderId?: string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutStagingCompanyInput
  }

  export type StagingCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUpdateManyWithoutStagingCompanyNestedInput
  }

  export type StagingCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUncheckedUpdateManyWithoutStagingCompanyNestedInput
  }

  export type StagingCompanyCreateManyInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactNumber?: string | null
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step: number
    registrationDate?: Date | string | null
    directorData?: string | null
    shareholderData?: string | null
    servicesSelected?: string | null
    createdAt?: Date | string
    razorpayOrderId?: string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
  }

  export type StagingCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StagingCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    role: $Enums.UserRole
    action: string
    target: string
    timestamp?: Date | string
    actor: UserCreateNestedOneWithoutAuditLogsInput
    company?: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    actorId: number
    role: $Enums.UserRole
    action: string
    target: string
    companyId?: number | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    company?: CompanyUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    actorId: number
    role: $Enums.UserRole
    action: string
    target: string
    companyId?: number | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredCompanyNameCreateInput = {
    companyName: string
    createdAt?: Date | string
  }

  export type RegisteredCompanyNameUncheckedCreateInput = {
    id?: number
    companyName: string
    createdAt?: Date | string
  }

  export type RegisteredCompanyNameUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredCompanyNameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredCompanyNameCreateManyInput = {
    id?: number
    companyName: string
    createdAt?: Date | string
  }

  export type RegisteredCompanyNameUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisteredCompanyNameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CalendarActionListRelationFilter = {
    every?: CalendarActionWhereInput
    some?: CalendarActionWhereInput
    none?: CalendarActionWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type InsightRecommendationListRelationFilter = {
    every?: InsightRecommendationWhereInput
    some?: InsightRecommendationWhereInput
    none?: InsightRecommendationWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RoleAssignmentListRelationFilter = {
    every?: RoleAssignmentWhereInput
    some?: RoleAssignmentWhereInput
    none?: RoleAssignmentWhereInput
  }

  export type CompanyStatusMessageListRelationFilter = {
    every?: CompanyStatusMessageWhereInput
    some?: CompanyStatusMessageWhereInput
    none?: CompanyStatusMessageWhereInput
  }

  export type CompanyDocumentListRelationFilter = {
    every?: CompanyDocumentWhereInput
    some?: CompanyDocumentWhereInput
    none?: CompanyDocumentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CalendarActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyStatusMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    country?: SortOrder
    role?: SortOrder
    profilePic?: SortOrder
    profileThumbnail?: SortOrder
    lastLogin?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    refreshToken?: SortOrder
    isVerified?: SortOrder
    isDeactivated?: SortOrder
    isDeleted?: SortOrder
    isSuspended?: SortOrder
    suspendMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    country?: SortOrder
    role?: SortOrder
    profilePic?: SortOrder
    profileThumbnail?: SortOrder
    lastLogin?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    refreshToken?: SortOrder
    isVerified?: SortOrder
    isDeactivated?: SortOrder
    isDeleted?: SortOrder
    isSuspended?: SortOrder
    suspendMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    country?: SortOrder
    role?: SortOrder
    profilePic?: SortOrder
    profileThumbnail?: SortOrder
    lastLogin?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    refreshToken?: SortOrder
    isVerified?: SortOrder
    isDeactivated?: SortOrder
    isDeleted?: SortOrder
    isSuspended?: SortOrder
    suspendMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyServiceListRelationFilter = {
    every?: CompanyServiceWhereInput
    some?: CompanyServiceWhereInput
    none?: CompanyServiceWhereInput
  }

  export type DashboardStateNullableScalarRelationFilter = {
    is?: DashboardStateWhereInput | null
    isNot?: DashboardStateWhereInput | null
  }

  export type DirectorListRelationFilter = {
    every?: DirectorWhereInput
    some?: DirectorWhereInput
    none?: DirectorWhereInput
  }

  export type ShareholderListRelationFilter = {
    every?: ShareholderWhereInput
    some?: ShareholderWhereInput
    none?: ShareholderWhereInput
  }

  export type CompanyServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareholderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    companyId?: SortOrder
    companyName?: SortOrder
    registrationDate?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    proposedShares?: SortOrder
    currency?: SortOrder
    proposedShareCapital?: SortOrder
    businessActivity1?: SortOrder
    businessActivity1Desc?: SortOrder
    businessActivity2?: SortOrder
    businessActivity2Desc?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    statusRemarks?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    canEditC?: SortOrder
    canEditD?: SortOrder
    canEditS?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    companyId?: SortOrder
    proposedShares?: SortOrder
    proposedShareCapital?: SortOrder
    userId?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    companyId?: SortOrder
    companyName?: SortOrder
    registrationDate?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    proposedShares?: SortOrder
    currency?: SortOrder
    proposedShareCapital?: SortOrder
    businessActivity1?: SortOrder
    businessActivity1Desc?: SortOrder
    businessActivity2?: SortOrder
    businessActivity2Desc?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    statusRemarks?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    canEditC?: SortOrder
    canEditD?: SortOrder
    canEditS?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    companyId?: SortOrder
    companyName?: SortOrder
    registrationDate?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    proposedShares?: SortOrder
    currency?: SortOrder
    proposedShareCapital?: SortOrder
    businessActivity1?: SortOrder
    businessActivity1Desc?: SortOrder
    businessActivity2?: SortOrder
    businessActivity2Desc?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    statusRemarks?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    canEditC?: SortOrder
    canEditD?: SortOrder
    canEditS?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    companyId?: SortOrder
    proposedShares?: SortOrder
    proposedShareCapital?: SortOrder
    userId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyStatusMessageCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyStatusMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
  }

  export type CompanyStatusMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyStatusMessageMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyStatusMessageSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    senderId?: SortOrder
  }

  export type DirectorCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    directorName?: SortOrder
    email?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    isShareholder?: SortOrder
    identityProof?: SortOrder
    addressProof?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectorAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type DirectorMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    directorName?: SortOrder
    email?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    isShareholder?: SortOrder
    identityProof?: SortOrder
    addressProof?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectorMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    directorName?: SortOrder
    email?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    isShareholder?: SortOrder
    identityProof?: SortOrder
    addressProof?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectorSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type EnumShareholderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareholderType | EnumShareholderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareholderTypeFilter<$PrismaModel> | $Enums.ShareholderType
  }

  export type ShareholderCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderName?: SortOrder
    email?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    dateOfBirth?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareholderAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
  }

  export type ShareholderMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderName?: SortOrder
    email?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    dateOfBirth?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareholderMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderName?: SortOrder
    email?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    contactNumber?: SortOrder
    nationality?: SortOrder
    idType?: SortOrder
    idExpiryDate?: SortOrder
    idNumber?: SortOrder
    dateOfBirth?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareholderSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    numberOfShares?: SortOrder
    shareCapitalAllocation?: SortOrder
  }

  export type EnumShareholderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareholderType | EnumShareholderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareholderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareholderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareholderTypeFilter<$PrismaModel>
    _max?: NestedEnumShareholderTypeFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentPurpose | EnumDocumentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentPurposeFilter<$PrismaModel> | $Enums.DocumentPurpose
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CompanyDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    documentLabel?: SortOrder
    documentPath?: SortOrder
    documentType?: SortOrder
    purpose?: SortOrder
    thumbnail?: SortOrder
    uploadedAt?: SortOrder
    isVerified?: SortOrder
    uploadedBy?: SortOrder
    uploadedRole?: SortOrder
    uploadedFor?: SortOrder
  }

  export type CompanyDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    uploadedBy?: SortOrder
    uploadedFor?: SortOrder
  }

  export type CompanyDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    documentLabel?: SortOrder
    documentPath?: SortOrder
    documentType?: SortOrder
    purpose?: SortOrder
    thumbnail?: SortOrder
    uploadedAt?: SortOrder
    isVerified?: SortOrder
    uploadedBy?: SortOrder
    uploadedRole?: SortOrder
    uploadedFor?: SortOrder
  }

  export type CompanyDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    documentLabel?: SortOrder
    documentPath?: SortOrder
    documentType?: SortOrder
    purpose?: SortOrder
    thumbnail?: SortOrder
    uploadedAt?: SortOrder
    isVerified?: SortOrder
    uploadedBy?: SortOrder
    uploadedRole?: SortOrder
    uploadedFor?: SortOrder
  }

  export type CompanyDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    uploadedBy?: SortOrder
    uploadedFor?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentPurpose | EnumDocumentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentPurposeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentPurposeFilter<$PrismaModel>
    _max?: NestedEnumDocumentPurposeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type StagingCompanyNullableScalarRelationFilter = {
    is?: StagingCompanyWhereInput | null
    isNot?: StagingCompanyWhereInput | null
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    stagingCompanyId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paymentReference?: SortOrder
    services?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    stagingCompanyId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paymentReference?: SortOrder
    services?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    stagingCompanyId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paymentReference?: SortOrder
    services?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceDescription?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceDescription?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceName?: SortOrder
    serviceDescription?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type CompanyServiceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    updateDate?: SortOrder
  }

  export type CompanyServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
  }

  export type CompanyServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    updateDate?: SortOrder
  }

  export type CompanyServiceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
    updateDate?: SortOrder
  }

  export type CompanyServiceSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    serviceId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type InsightRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sampleDocUrls?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightRecommendationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InsightRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightRecommendationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CalendarActionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdByRole?: SortOrder
  }

  export type CalendarActionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdBy?: SortOrder
  }

  export type CalendarActionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdByRole?: SortOrder
  }

  export type CalendarActionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdByRole?: SortOrder
  }

  export type CalendarActionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdBy?: SortOrder
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type DashboardStateCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    step?: SortOrder
    completedAt?: SortOrder
  }

  export type DashboardStateAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type DashboardStateMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    step?: SortOrder
    completedAt?: SortOrder
  }

  export type DashboardStateMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    step?: SortOrder
    completedAt?: SortOrder
  }

  export type DashboardStateSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type RoleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type RoleAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
  }

  export type RoleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type RoleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    assignedAt?: SortOrder
  }

  export type RoleAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    companyId?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    publishedAt?: SortOrder
    imagePath?: SortOrder
    views?: SortOrder
    hashtag?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    publishedAt?: SortOrder
    imagePath?: SortOrder
    views?: SortOrder
    hashtag?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    publishedAt?: SortOrder
    imagePath?: SortOrder
    views?: SortOrder
    hashtag?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    details?: SortOrder
    status?: SortOrder
    ticketUpdate?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    details?: SortOrder
    status?: SortOrder
    ticketUpdate?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    details?: SortOrder
    status?: SortOrder
    ticketUpdate?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StagingCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactNumber?: SortOrder
    isEmailVerified?: SortOrder
    isPaid?: SortOrder
    isCompleted?: SortOrder
    isRejected?: SortOrder
    step?: SortOrder
    registrationDate?: SortOrder
    directorData?: SortOrder
    shareholderData?: SortOrder
    servicesSelected?: SortOrder
    createdAt?: SortOrder
    razorpayOrderId?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
  }

  export type StagingCompanyAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type StagingCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactNumber?: SortOrder
    isEmailVerified?: SortOrder
    isPaid?: SortOrder
    isCompleted?: SortOrder
    isRejected?: SortOrder
    step?: SortOrder
    registrationDate?: SortOrder
    directorData?: SortOrder
    shareholderData?: SortOrder
    servicesSelected?: SortOrder
    createdAt?: SortOrder
    razorpayOrderId?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
  }

  export type StagingCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactNumber?: SortOrder
    isEmailVerified?: SortOrder
    isPaid?: SortOrder
    isCompleted?: SortOrder
    isRejected?: SortOrder
    step?: SortOrder
    registrationDate?: SortOrder
    directorData?: SortOrder
    shareholderData?: SortOrder
    servicesSelected?: SortOrder
    createdAt?: SortOrder
    razorpayOrderId?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
  }

  export type StagingCompanySumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
    action?: SortOrder
    target?: SortOrder
    companyId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    companyId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
    action?: SortOrder
    target?: SortOrder
    companyId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    role?: SortOrder
    action?: SortOrder
    target?: SortOrder
    companyId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    companyId?: SortOrder
  }

  export type RegisteredCompanyNameCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type RegisteredCompanyNameAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegisteredCompanyNameMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type RegisteredCompanyNameMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type RegisteredCompanyNameSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CalendarActionCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput> | CalendarActionCreateWithoutUserInput[] | CalendarActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutUserInput | CalendarActionCreateOrConnectWithoutUserInput[]
    createMany?: CalendarActionCreateManyUserInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CompanyCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type InsightRecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput> | InsightRecommendationCreateWithoutUserInput[] | InsightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightRecommendationCreateOrConnectWithoutUserInput | InsightRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: InsightRecommendationCreateManyUserInputEnvelope
    connect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoleAssignmentCreateNestedManyWithoutAgentInput = {
    create?: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput> | RoleAssignmentCreateWithoutAgentInput[] | RoleAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutAgentInput | RoleAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: RoleAssignmentCreateManyAgentInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type CompanyStatusMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput> | CompanyStatusMessageCreateWithoutSenderInput[] | CompanyStatusMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutSenderInput | CompanyStatusMessageCreateOrConnectWithoutSenderInput[]
    createMany?: CompanyStatusMessageCreateManySenderInputEnvelope
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
  }

  export type CompanyDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyDocumentCreateNestedManyWithoutForUserInput = {
    create?: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput> | CompanyDocumentCreateWithoutForUserInput[] | CompanyDocumentUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutForUserInput | CompanyDocumentCreateOrConnectWithoutForUserInput[]
    createMany?: CompanyDocumentCreateManyForUserInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CalendarActionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput> | CalendarActionCreateWithoutCreatorInput[] | CalendarActionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCreatorInput | CalendarActionCreateOrConnectWithoutCreatorInput[]
    createMany?: CalendarActionCreateManyCreatorInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type CalendarActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput> | CalendarActionCreateWithoutUserInput[] | CalendarActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutUserInput | CalendarActionCreateOrConnectWithoutUserInput[]
    createMany?: CalendarActionCreateManyUserInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type InsightRecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput> | InsightRecommendationCreateWithoutUserInput[] | InsightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightRecommendationCreateOrConnectWithoutUserInput | InsightRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: InsightRecommendationCreateManyUserInputEnvelope
    connect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput> | RoleAssignmentCreateWithoutAgentInput[] | RoleAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutAgentInput | RoleAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: RoleAssignmentCreateManyAgentInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput> | CompanyStatusMessageCreateWithoutSenderInput[] | CompanyStatusMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutSenderInput | CompanyStatusMessageCreateOrConnectWithoutSenderInput[]
    createMany?: CompanyStatusMessageCreateManySenderInputEnvelope
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput = {
    create?: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput> | CompanyDocumentCreateWithoutForUserInput[] | CompanyDocumentUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutForUserInput | CompanyDocumentCreateOrConnectWithoutForUserInput[]
    createMany?: CompanyDocumentCreateManyForUserInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CalendarActionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput> | CalendarActionCreateWithoutCreatorInput[] | CalendarActionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCreatorInput | CalendarActionCreateOrConnectWithoutCreatorInput[]
    createMany?: CalendarActionCreateManyCreatorInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CalendarActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput> | CalendarActionCreateWithoutUserInput[] | CalendarActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutUserInput | CalendarActionCreateOrConnectWithoutUserInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutUserInput | CalendarActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarActionCreateManyUserInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutUserInput | CalendarActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutUserInput | CalendarActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CompanyUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUserInput | CompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUserInput | CompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUserInput | CompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type InsightRecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput> | InsightRecommendationCreateWithoutUserInput[] | InsightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightRecommendationCreateOrConnectWithoutUserInput | InsightRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: InsightRecommendationUpsertWithWhereUniqueWithoutUserInput | InsightRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightRecommendationCreateManyUserInputEnvelope
    set?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    disconnect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    delete?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    connect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    update?: InsightRecommendationUpdateWithWhereUniqueWithoutUserInput | InsightRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightRecommendationUpdateManyWithWhereWithoutUserInput | InsightRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightRecommendationScalarWhereInput | InsightRecommendationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoleAssignmentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput> | RoleAssignmentCreateWithoutAgentInput[] | RoleAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutAgentInput | RoleAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutAgentInput | RoleAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RoleAssignmentCreateManyAgentInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutAgentInput | RoleAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutAgentInput | RoleAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type CompanyStatusMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput> | CompanyStatusMessageCreateWithoutSenderInput[] | CompanyStatusMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutSenderInput | CompanyStatusMessageCreateOrConnectWithoutSenderInput[]
    upsert?: CompanyStatusMessageUpsertWithWhereUniqueWithoutSenderInput | CompanyStatusMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CompanyStatusMessageCreateManySenderInputEnvelope
    set?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    disconnect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    delete?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    update?: CompanyStatusMessageUpdateWithWhereUniqueWithoutSenderInput | CompanyStatusMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CompanyStatusMessageUpdateManyWithWhereWithoutSenderInput | CompanyStatusMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
  }

  export type CompanyDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyDocumentUpdateManyWithoutForUserNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput> | CompanyDocumentCreateWithoutForUserInput[] | CompanyDocumentUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutForUserInput | CompanyDocumentCreateOrConnectWithoutForUserInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutForUserInput | CompanyDocumentUpsertWithWhereUniqueWithoutForUserInput[]
    createMany?: CompanyDocumentCreateManyForUserInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutForUserInput | CompanyDocumentUpdateWithWhereUniqueWithoutForUserInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutForUserInput | CompanyDocumentUpdateManyWithWhereWithoutForUserInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CalendarActionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput> | CalendarActionCreateWithoutCreatorInput[] | CalendarActionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCreatorInput | CalendarActionCreateOrConnectWithoutCreatorInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutCreatorInput | CalendarActionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CalendarActionCreateManyCreatorInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutCreatorInput | CalendarActionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutCreatorInput | CalendarActionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CalendarActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput> | CalendarActionCreateWithoutUserInput[] | CalendarActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutUserInput | CalendarActionCreateOrConnectWithoutUserInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutUserInput | CalendarActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarActionCreateManyUserInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutUserInput | CalendarActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutUserInput | CalendarActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUserInput | CompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUserInput | CompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUserInput | CompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput> | InsightRecommendationCreateWithoutUserInput[] | InsightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightRecommendationCreateOrConnectWithoutUserInput | InsightRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: InsightRecommendationUpsertWithWhereUniqueWithoutUserInput | InsightRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightRecommendationCreateManyUserInputEnvelope
    set?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    disconnect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    delete?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    connect?: InsightRecommendationWhereUniqueInput | InsightRecommendationWhereUniqueInput[]
    update?: InsightRecommendationUpdateWithWhereUniqueWithoutUserInput | InsightRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightRecommendationUpdateManyWithWhereWithoutUserInput | InsightRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightRecommendationScalarWhereInput | InsightRecommendationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput> | RoleAssignmentCreateWithoutAgentInput[] | RoleAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutAgentInput | RoleAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutAgentInput | RoleAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RoleAssignmentCreateManyAgentInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutAgentInput | RoleAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutAgentInput | RoleAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput> | CompanyStatusMessageCreateWithoutSenderInput[] | CompanyStatusMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutSenderInput | CompanyStatusMessageCreateOrConnectWithoutSenderInput[]
    upsert?: CompanyStatusMessageUpsertWithWhereUniqueWithoutSenderInput | CompanyStatusMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: CompanyStatusMessageCreateManySenderInputEnvelope
    set?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    disconnect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    delete?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    update?: CompanyStatusMessageUpdateWithWhereUniqueWithoutSenderInput | CompanyStatusMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: CompanyStatusMessageUpdateManyWithWhereWithoutSenderInput | CompanyStatusMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput> | CompanyDocumentCreateWithoutForUserInput[] | CompanyDocumentUncheckedCreateWithoutForUserInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutForUserInput | CompanyDocumentCreateOrConnectWithoutForUserInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutForUserInput | CompanyDocumentUpsertWithWhereUniqueWithoutForUserInput[]
    createMany?: CompanyDocumentCreateManyForUserInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutForUserInput | CompanyDocumentUpdateWithWhereUniqueWithoutForUserInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutForUserInput | CompanyDocumentUpdateManyWithWhereWithoutForUserInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput> | CalendarActionCreateWithoutCreatorInput[] | CalendarActionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCreatorInput | CalendarActionCreateOrConnectWithoutCreatorInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutCreatorInput | CalendarActionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CalendarActionCreateManyCreatorInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutCreatorInput | CalendarActionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutCreatorInput | CalendarActionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type CalendarActionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput> | CalendarActionCreateWithoutCompanyInput[] | CalendarActionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCompanyInput | CalendarActionCreateOrConnectWithoutCompanyInput[]
    createMany?: CalendarActionCreateManyCompanyInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyDocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput> | CompanyDocumentCreateWithoutCompanyInput[] | CompanyDocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutCompanyInput | CompanyDocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyDocumentCreateManyCompanyInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyServiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput> | CompanyServiceCreateWithoutCompanyInput[] | CompanyServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutCompanyInput | CompanyServiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyServiceCreateManyCompanyInputEnvelope
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
  }

  export type DashboardStateCreateNestedOneWithoutCompanyInput = {
    create?: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DashboardStateCreateOrConnectWithoutCompanyInput
    connect?: DashboardStateWhereUniqueInput
  }

  export type DirectorCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput> | DirectorCreateWithoutCompanyInput[] | DirectorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DirectorCreateOrConnectWithoutCompanyInput | DirectorCreateOrConnectWithoutCompanyInput[]
    createMany?: DirectorCreateManyCompanyInputEnvelope
    connect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoleAssignmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput> | RoleAssignmentCreateWithoutCompanyInput[] | RoleAssignmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutCompanyInput | RoleAssignmentCreateOrConnectWithoutCompanyInput[]
    createMany?: RoleAssignmentCreateManyCompanyInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type ShareholderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput> | ShareholderCreateWithoutCompanyInput[] | ShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompanyInput | ShareholderCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareholderCreateManyCompanyInputEnvelope
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
  }

  export type CompanyStatusMessageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput> | CompanyStatusMessageCreateWithoutCompanyInput[] | CompanyStatusMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutCompanyInput | CompanyStatusMessageCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyStatusMessageCreateManyCompanyInputEnvelope
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CalendarActionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput> | CalendarActionCreateWithoutCompanyInput[] | CalendarActionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCompanyInput | CalendarActionCreateOrConnectWithoutCompanyInput[]
    createMany?: CalendarActionCreateManyCompanyInputEnvelope
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput> | CompanyDocumentCreateWithoutCompanyInput[] | CompanyDocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutCompanyInput | CompanyDocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyDocumentCreateManyCompanyInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput> | CompanyServiceCreateWithoutCompanyInput[] | CompanyServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutCompanyInput | CompanyServiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyServiceCreateManyCompanyInputEnvelope
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
  }

  export type DashboardStateUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DashboardStateCreateOrConnectWithoutCompanyInput
    connect?: DashboardStateWhereUniqueInput
  }

  export type DirectorUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput> | DirectorCreateWithoutCompanyInput[] | DirectorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DirectorCreateOrConnectWithoutCompanyInput | DirectorCreateOrConnectWithoutCompanyInput[]
    createMany?: DirectorCreateManyCompanyInputEnvelope
    connect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput> | RoleAssignmentCreateWithoutCompanyInput[] | RoleAssignmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutCompanyInput | RoleAssignmentCreateOrConnectWithoutCompanyInput[]
    createMany?: RoleAssignmentCreateManyCompanyInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type ShareholderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput> | ShareholderCreateWithoutCompanyInput[] | ShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompanyInput | ShareholderCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareholderCreateManyCompanyInputEnvelope
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
  }

  export type CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput> | CompanyStatusMessageCreateWithoutCompanyInput[] | CompanyStatusMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutCompanyInput | CompanyStatusMessageCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyStatusMessageCreateManyCompanyInputEnvelope
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCompanyStatusFieldUpdateOperationsInput = {
    set?: $Enums.CompanyStatus
  }

  export type CalendarActionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput> | CalendarActionCreateWithoutCompanyInput[] | CalendarActionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCompanyInput | CalendarActionCreateOrConnectWithoutCompanyInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutCompanyInput | CalendarActionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CalendarActionCreateManyCompanyInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutCompanyInput | CalendarActionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutCompanyInput | CalendarActionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompanyDocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput> | CompanyDocumentCreateWithoutCompanyInput[] | CompanyDocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutCompanyInput | CompanyDocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutCompanyInput | CompanyDocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyDocumentCreateManyCompanyInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutCompanyInput | CompanyDocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutCompanyInput | CompanyDocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyServiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput> | CompanyServiceCreateWithoutCompanyInput[] | CompanyServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutCompanyInput | CompanyServiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyServiceUpsertWithWhereUniqueWithoutCompanyInput | CompanyServiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyServiceCreateManyCompanyInputEnvelope
    set?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    disconnect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    delete?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    update?: CompanyServiceUpdateWithWhereUniqueWithoutCompanyInput | CompanyServiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyServiceUpdateManyWithWhereWithoutCompanyInput | CompanyServiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
  }

  export type DashboardStateUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DashboardStateCreateOrConnectWithoutCompanyInput
    upsert?: DashboardStateUpsertWithoutCompanyInput
    disconnect?: DashboardStateWhereInput | boolean
    delete?: DashboardStateWhereInput | boolean
    connect?: DashboardStateWhereUniqueInput
    update?: XOR<XOR<DashboardStateUpdateToOneWithWhereWithoutCompanyInput, DashboardStateUpdateWithoutCompanyInput>, DashboardStateUncheckedUpdateWithoutCompanyInput>
  }

  export type DirectorUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput> | DirectorCreateWithoutCompanyInput[] | DirectorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DirectorCreateOrConnectWithoutCompanyInput | DirectorCreateOrConnectWithoutCompanyInput[]
    upsert?: DirectorUpsertWithWhereUniqueWithoutCompanyInput | DirectorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DirectorCreateManyCompanyInputEnvelope
    set?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    disconnect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    delete?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    connect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    update?: DirectorUpdateWithWhereUniqueWithoutCompanyInput | DirectorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DirectorUpdateManyWithWhereWithoutCompanyInput | DirectorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DirectorScalarWhereInput | DirectorScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoleAssignmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput> | RoleAssignmentCreateWithoutCompanyInput[] | RoleAssignmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutCompanyInput | RoleAssignmentCreateOrConnectWithoutCompanyInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutCompanyInput | RoleAssignmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RoleAssignmentCreateManyCompanyInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutCompanyInput | RoleAssignmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutCompanyInput | RoleAssignmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type ShareholderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput> | ShareholderCreateWithoutCompanyInput[] | ShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompanyInput | ShareholderCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareholderUpsertWithWhereUniqueWithoutCompanyInput | ShareholderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareholderCreateManyCompanyInputEnvelope
    set?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    disconnect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    delete?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    update?: ShareholderUpdateWithWhereUniqueWithoutCompanyInput | ShareholderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareholderUpdateManyWithWhereWithoutCompanyInput | ShareholderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
  }

  export type CompanyStatusMessageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput> | CompanyStatusMessageCreateWithoutCompanyInput[] | CompanyStatusMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutCompanyInput | CompanyStatusMessageCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyStatusMessageUpsertWithWhereUniqueWithoutCompanyInput | CompanyStatusMessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyStatusMessageCreateManyCompanyInputEnvelope
    set?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    disconnect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    delete?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    update?: CompanyStatusMessageUpdateWithWhereUniqueWithoutCompanyInput | CompanyStatusMessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyStatusMessageUpdateManyWithWhereWithoutCompanyInput | CompanyStatusMessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput> | CalendarActionCreateWithoutCompanyInput[] | CalendarActionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CalendarActionCreateOrConnectWithoutCompanyInput | CalendarActionCreateOrConnectWithoutCompanyInput[]
    upsert?: CalendarActionUpsertWithWhereUniqueWithoutCompanyInput | CalendarActionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CalendarActionCreateManyCompanyInputEnvelope
    set?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    disconnect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    delete?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    connect?: CalendarActionWhereUniqueInput | CalendarActionWhereUniqueInput[]
    update?: CalendarActionUpdateWithWhereUniqueWithoutCompanyInput | CalendarActionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CalendarActionUpdateManyWithWhereWithoutCompanyInput | CalendarActionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput> | CompanyDocumentCreateWithoutCompanyInput[] | CompanyDocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutCompanyInput | CompanyDocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutCompanyInput | CompanyDocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyDocumentCreateManyCompanyInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutCompanyInput | CompanyDocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutCompanyInput | CompanyDocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput> | CompanyServiceCreateWithoutCompanyInput[] | CompanyServiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutCompanyInput | CompanyServiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyServiceUpsertWithWhereUniqueWithoutCompanyInput | CompanyServiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyServiceCreateManyCompanyInputEnvelope
    set?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    disconnect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    delete?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    update?: CompanyServiceUpdateWithWhereUniqueWithoutCompanyInput | CompanyServiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyServiceUpdateManyWithWhereWithoutCompanyInput | CompanyServiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
  }

  export type DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: DashboardStateCreateOrConnectWithoutCompanyInput
    upsert?: DashboardStateUpsertWithoutCompanyInput
    disconnect?: DashboardStateWhereInput | boolean
    delete?: DashboardStateWhereInput | boolean
    connect?: DashboardStateWhereUniqueInput
    update?: XOR<XOR<DashboardStateUpdateToOneWithWhereWithoutCompanyInput, DashboardStateUpdateWithoutCompanyInput>, DashboardStateUncheckedUpdateWithoutCompanyInput>
  }

  export type DirectorUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput> | DirectorCreateWithoutCompanyInput[] | DirectorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DirectorCreateOrConnectWithoutCompanyInput | DirectorCreateOrConnectWithoutCompanyInput[]
    upsert?: DirectorUpsertWithWhereUniqueWithoutCompanyInput | DirectorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DirectorCreateManyCompanyInputEnvelope
    set?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    disconnect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    delete?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    connect?: DirectorWhereUniqueInput | DirectorWhereUniqueInput[]
    update?: DirectorUpdateWithWhereUniqueWithoutCompanyInput | DirectorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DirectorUpdateManyWithWhereWithoutCompanyInput | DirectorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DirectorScalarWhereInput | DirectorScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput> | PaymentCreateWithoutCompanyInput[] | PaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCompanyInput | PaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCompanyInput | PaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PaymentCreateManyCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCompanyInput | PaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCompanyInput | PaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput> | RoleAssignmentCreateWithoutCompanyInput[] | RoleAssignmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutCompanyInput | RoleAssignmentCreateOrConnectWithoutCompanyInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutCompanyInput | RoleAssignmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RoleAssignmentCreateManyCompanyInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutCompanyInput | RoleAssignmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutCompanyInput | RoleAssignmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type ShareholderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput> | ShareholderCreateWithoutCompanyInput[] | ShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompanyInput | ShareholderCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareholderUpsertWithWhereUniqueWithoutCompanyInput | ShareholderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareholderCreateManyCompanyInputEnvelope
    set?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    disconnect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    delete?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    update?: ShareholderUpdateWithWhereUniqueWithoutCompanyInput | ShareholderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareholderUpdateManyWithWhereWithoutCompanyInput | ShareholderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
  }

  export type CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput> | CompanyStatusMessageCreateWithoutCompanyInput[] | CompanyStatusMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyStatusMessageCreateOrConnectWithoutCompanyInput | CompanyStatusMessageCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyStatusMessageUpsertWithWhereUniqueWithoutCompanyInput | CompanyStatusMessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyStatusMessageCreateManyCompanyInputEnvelope
    set?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    disconnect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    delete?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    connect?: CompanyStatusMessageWhereUniqueInput | CompanyStatusMessageWhereUniqueInput[]
    update?: CompanyStatusMessageUpdateWithWhereUniqueWithoutCompanyInput | CompanyStatusMessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyStatusMessageUpdateManyWithWhereWithoutCompanyInput | CompanyStatusMessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutRevertMessageInput = {
    create?: XOR<CompanyCreateWithoutRevertMessageInput, CompanyUncheckedCreateWithoutRevertMessageInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRevertMessageInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRevertMessageInput = {
    create?: XOR<UserCreateWithoutRevertMessageInput, UserUncheckedCreateWithoutRevertMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevertMessageInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutRevertMessageNestedInput = {
    create?: XOR<CompanyCreateWithoutRevertMessageInput, CompanyUncheckedCreateWithoutRevertMessageInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRevertMessageInput
    upsert?: CompanyUpsertWithoutRevertMessageInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRevertMessageInput, CompanyUpdateWithoutRevertMessageInput>, CompanyUncheckedUpdateWithoutRevertMessageInput>
  }

  export type UserUpdateOneRequiredWithoutRevertMessageNestedInput = {
    create?: XOR<UserCreateWithoutRevertMessageInput, UserUncheckedCreateWithoutRevertMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevertMessageInput
    upsert?: UserUpsertWithoutRevertMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRevertMessageInput, UserUpdateWithoutRevertMessageInput>, UserUncheckedUpdateWithoutRevertMessageInput>
  }

  export type CompanyCreateNestedOneWithoutDirectorsInput = {
    create?: XOR<CompanyCreateWithoutDirectorsInput, CompanyUncheckedCreateWithoutDirectorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDirectorsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDirectorsNestedInput = {
    create?: XOR<CompanyCreateWithoutDirectorsInput, CompanyUncheckedCreateWithoutDirectorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDirectorsInput
    upsert?: CompanyUpsertWithoutDirectorsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDirectorsInput, CompanyUpdateWithoutDirectorsInput>, CompanyUncheckedUpdateWithoutDirectorsInput>
  }

  export type CompanyCreateNestedOneWithoutShareholdersInput = {
    create?: XOR<CompanyCreateWithoutShareholdersInput, CompanyUncheckedCreateWithoutShareholdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareholdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumShareholderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShareholderType
  }

  export type CompanyUpdateOneRequiredWithoutShareholdersNestedInput = {
    create?: XOR<CompanyCreateWithoutShareholdersInput, CompanyUncheckedCreateWithoutShareholdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareholdersInput
    upsert?: CompanyUpsertWithoutShareholdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutShareholdersInput, CompanyUpdateWithoutShareholdersInput>, CompanyUncheckedUpdateWithoutShareholdersInput>
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocsInput = {
    create?: XOR<UserCreateWithoutUploadedDocsInput, UserUncheckedCreateWithoutUploadedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedDocsInput = {
    create?: XOR<UserCreateWithoutReceivedDocsInput, UserUncheckedCreateWithoutReceivedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedDocsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentPurposeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentPurpose
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocsInput, UserUncheckedCreateWithoutUploadedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocsInput
    upsert?: UserUpsertWithoutUploadedDocsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocsInput, UserUpdateWithoutUploadedDocsInput>, UserUncheckedUpdateWithoutUploadedDocsInput>
  }

  export type UserUpdateOneWithoutReceivedDocsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedDocsInput, UserUncheckedCreateWithoutReceivedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedDocsInput
    upsert?: UserUpsertWithoutReceivedDocsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedDocsInput, UserUpdateWithoutReceivedDocsInput>, UserUncheckedUpdateWithoutReceivedDocsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type StagingCompanyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StagingCompanyCreateWithoutPaymentsInput, StagingCompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StagingCompanyCreateOrConnectWithoutPaymentsInput
    connect?: StagingCompanyWhereUniqueInput
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPaymentsInput
    upsert?: CompanyUpsertWithoutPaymentsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPaymentsInput, CompanyUpdateWithoutPaymentsInput>, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type StagingCompanyUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<StagingCompanyCreateWithoutPaymentsInput, StagingCompanyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StagingCompanyCreateOrConnectWithoutPaymentsInput
    upsert?: StagingCompanyUpsertWithoutPaymentsInput
    disconnect?: StagingCompanyWhereInput | boolean
    delete?: StagingCompanyWhereInput | boolean
    connect?: StagingCompanyWhereUniqueInput
    update?: XOR<XOR<StagingCompanyUpdateToOneWithWhereWithoutPaymentsInput, StagingCompanyUpdateWithoutPaymentsInput>, StagingCompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type CompanyServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput> | CompanyServiceCreateWithoutServiceInput[] | CompanyServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutServiceInput | CompanyServiceCreateOrConnectWithoutServiceInput[]
    createMany?: CompanyServiceCreateManyServiceInputEnvelope
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
  }

  export type CompanyServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput> | CompanyServiceCreateWithoutServiceInput[] | CompanyServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutServiceInput | CompanyServiceCreateOrConnectWithoutServiceInput[]
    createMany?: CompanyServiceCreateManyServiceInputEnvelope
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
  }

  export type CompanyServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput> | CompanyServiceCreateWithoutServiceInput[] | CompanyServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutServiceInput | CompanyServiceCreateOrConnectWithoutServiceInput[]
    upsert?: CompanyServiceUpsertWithWhereUniqueWithoutServiceInput | CompanyServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CompanyServiceCreateManyServiceInputEnvelope
    set?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    disconnect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    delete?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    update?: CompanyServiceUpdateWithWhereUniqueWithoutServiceInput | CompanyServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CompanyServiceUpdateManyWithWhereWithoutServiceInput | CompanyServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
  }

  export type CompanyServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput> | CompanyServiceCreateWithoutServiceInput[] | CompanyServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CompanyServiceCreateOrConnectWithoutServiceInput | CompanyServiceCreateOrConnectWithoutServiceInput[]
    upsert?: CompanyServiceUpsertWithWhereUniqueWithoutServiceInput | CompanyServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CompanyServiceCreateManyServiceInputEnvelope
    set?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    disconnect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    delete?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    connect?: CompanyServiceWhereUniqueInput | CompanyServiceWhereUniqueInput[]
    update?: CompanyServiceUpdateWithWhereUniqueWithoutServiceInput | CompanyServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CompanyServiceUpdateManyWithWhereWithoutServiceInput | CompanyServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCompanyServicesInput = {
    create?: XOR<CompanyCreateWithoutCompanyServicesInput, CompanyUncheckedCreateWithoutCompanyServicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyServicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutCompanyServicesInput = {
    create?: XOR<ServiceCreateWithoutCompanyServicesInput, ServiceUncheckedCreateWithoutCompanyServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanyServicesNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyServicesInput, CompanyUncheckedCreateWithoutCompanyServicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyServicesInput
    upsert?: CompanyUpsertWithoutCompanyServicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyServicesInput, CompanyUpdateWithoutCompanyServicesInput>, CompanyUncheckedUpdateWithoutCompanyServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutCompanyServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutCompanyServicesInput, ServiceUncheckedCreateWithoutCompanyServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCompanyServicesInput
    upsert?: ServiceUpsertWithoutCompanyServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutCompanyServicesInput, ServiceUpdateWithoutCompanyServicesInput>, ServiceUncheckedUpdateWithoutCompanyServicesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type InsightRecommendationCreatesampleDocUrlsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutInsightsInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type InsightRecommendationUpdatesampleDocUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    upsert?: UserUpsertWithoutInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightsInput, UserUpdateWithoutInsightsInput>, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTasksInput = {
    create?: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTasksInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCalendarActionInput = {
    create?: XOR<UserCreateWithoutCalendarActionInput, UserUncheckedCreateWithoutCalendarActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarActionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type CompanyUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTasksInput
    upsert?: CompanyUpsertWithoutTasksInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTasksInput, CompanyUpdateWithoutTasksInput>, CompanyUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutCalendarActionNestedInput = {
    create?: XOR<UserCreateWithoutCalendarActionInput, UserUncheckedCreateWithoutCalendarActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarActionInput
    upsert?: UserUpsertWithoutCalendarActionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarActionInput, UserUpdateWithoutCalendarActionInput>, UserUncheckedUpdateWithoutCalendarActionInput>
  }

  export type UserCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UserUpsertWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesReceivedInput, UserUpdateWithoutMessagesReceivedInput>, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type CompanyCreateNestedOneWithoutDashboardStateInput = {
    create?: XOR<CompanyCreateWithoutDashboardStateInput, CompanyUncheckedCreateWithoutDashboardStateInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDashboardStateInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDashboardStateNestedInput = {
    create?: XOR<CompanyCreateWithoutDashboardStateInput, CompanyUncheckedCreateWithoutDashboardStateInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDashboardStateInput
    upsert?: CompanyUpsertWithoutDashboardStateInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDashboardStateInput, CompanyUpdateWithoutDashboardStateInput>, CompanyUncheckedUpdateWithoutDashboardStateInput>
  }

  export type UserCreateNestedOneWithoutAssignedRolesInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutRoleAssignmentsInput = {
    create?: XOR<CompanyCreateWithoutRoleAssignmentsInput, CompanyUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRoleAssignmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAssignedRolesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    upsert?: UserUpsertWithoutAssignedRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedRolesInput, UserUpdateWithoutAssignedRolesInput>, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type CompanyUpdateOneRequiredWithoutRoleAssignmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutRoleAssignmentsInput, CompanyUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRoleAssignmentsInput
    upsert?: CompanyUpsertWithoutRoleAssignmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRoleAssignmentsInput, CompanyUpdateWithoutRoleAssignmentsInput>, CompanyUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type PaymentCreateNestedManyWithoutStagingCompanyInput = {
    create?: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput> | PaymentCreateWithoutStagingCompanyInput[] | PaymentUncheckedCreateWithoutStagingCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStagingCompanyInput | PaymentCreateOrConnectWithoutStagingCompanyInput[]
    createMany?: PaymentCreateManyStagingCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutStagingCompanyInput = {
    create?: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput> | PaymentCreateWithoutStagingCompanyInput[] | PaymentUncheckedCreateWithoutStagingCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStagingCompanyInput | PaymentCreateOrConnectWithoutStagingCompanyInput[]
    createMany?: PaymentCreateManyStagingCompanyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutStagingCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput> | PaymentCreateWithoutStagingCompanyInput[] | PaymentUncheckedCreateWithoutStagingCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStagingCompanyInput | PaymentCreateOrConnectWithoutStagingCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStagingCompanyInput | PaymentUpsertWithWhereUniqueWithoutStagingCompanyInput[]
    createMany?: PaymentCreateManyStagingCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStagingCompanyInput | PaymentUpdateWithWhereUniqueWithoutStagingCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStagingCompanyInput | PaymentUpdateManyWithWhereWithoutStagingCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutStagingCompanyNestedInput = {
    create?: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput> | PaymentCreateWithoutStagingCompanyInput[] | PaymentUncheckedCreateWithoutStagingCompanyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStagingCompanyInput | PaymentCreateOrConnectWithoutStagingCompanyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStagingCompanyInput | PaymentUpsertWithWhereUniqueWithoutStagingCompanyInput[]
    createMany?: PaymentCreateManyStagingCompanyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStagingCompanyInput | PaymentUpdateWithWhereUniqueWithoutStagingCompanyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStagingCompanyInput | PaymentUpdateManyWithWhereWithoutStagingCompanyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyStatus[] | ListEnumCompanyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type NestedEnumShareholderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareholderType | EnumShareholderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareholderTypeFilter<$PrismaModel> | $Enums.ShareholderType
  }

  export type NestedEnumShareholderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShareholderType | EnumShareholderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShareholderType[] | ListEnumShareholderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShareholderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShareholderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShareholderTypeFilter<$PrismaModel>
    _max?: NestedEnumShareholderTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentPurpose | EnumDocumentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentPurposeFilter<$PrismaModel> | $Enums.DocumentPurpose
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentPurpose | EnumDocumentPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentPurpose[] | ListEnumDocumentPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentPurposeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentPurposeFilter<$PrismaModel>
    _max?: NestedEnumDocumentPurposeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type CalendarActionCreateWithoutUserInput = {
    title: string
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
    company: CompanyCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutCalendarActionInput
  }

  export type CalendarActionUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionCreateOrConnectWithoutUserInput = {
    where: CalendarActionWhereUniqueInput
    create: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput>
  }

  export type CalendarActionCreateManyUserInputEnvelope = {
    data: CalendarActionCreateManyUserInput | CalendarActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutReceiverInput = {
    content: string
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type ChatMessageUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    content: string
    sentAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageCreateManyReceiverInputEnvelope = {
    data: ChatMessageCreateManyReceiverInput | ChatMessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    content: string
    sentAt?: Date | string
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    content: string
    sentAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUserInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CompanyCreateManyUserInputEnvelope = {
    data: CompanyCreateManyUserInput | CompanyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InsightRecommendationCreateWithoutUserInput = {
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
  }

  export type InsightRecommendationUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
  }

  export type InsightRecommendationCreateOrConnectWithoutUserInput = {
    where: InsightRecommendationWhereUniqueInput
    create: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput>
  }

  export type InsightRecommendationCreateManyUserInputEnvelope = {
    data: InsightRecommendationCreateManyUserInput | InsightRecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    company?: CompanyCreateNestedOneWithoutPaymentsInput
    stagingCompany?: StagingCompanyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: number
    companyId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssignmentCreateWithoutAgentInput = {
    role: $Enums.UserRole
    assignedAt?: Date | string
    company: CompanyCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateWithoutAgentInput = {
    id?: number
    companyId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type RoleAssignmentCreateOrConnectWithoutAgentInput = {
    where: RoleAssignmentWhereUniqueInput
    create: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type RoleAssignmentCreateManyAgentInputEnvelope = {
    data: RoleAssignmentCreateManyAgentInput | RoleAssignmentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyStatusMessageCreateWithoutSenderInput = {
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutRevertMessageInput
  }

  export type CompanyStatusMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    companyId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type CompanyStatusMessageCreateOrConnectWithoutSenderInput = {
    where: CompanyStatusMessageWhereUniqueInput
    create: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput>
  }

  export type CompanyStatusMessageCreateManySenderInputEnvelope = {
    data: CompanyStatusMessageCreateManySenderInput | CompanyStatusMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyDocumentCreateWithoutUploaderInput = {
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    company: CompanyCreateNestedOneWithoutDocumentsInput
    forUser?: UserCreateNestedOneWithoutReceivedDocsInput
  }

  export type CompanyDocumentUncheckedCreateWithoutUploaderInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyDocumentCreateOrConnectWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentCreateManyUploaderInputEnvelope = {
    data: CompanyDocumentCreateManyUploaderInput | CompanyDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyDocumentCreateWithoutForUserInput = {
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    company: CompanyCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedDocsInput
  }

  export type CompanyDocumentUncheckedCreateWithoutForUserInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
  }

  export type CompanyDocumentCreateOrConnectWithoutForUserInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput>
  }

  export type CompanyDocumentCreateManyForUserInputEnvelope = {
    data: CompanyDocumentCreateManyForUserInput | CompanyDocumentCreateManyForUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    role: $Enums.UserRole
    action: string
    target: string
    timestamp?: Date | string
    company?: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: number
    role: $Enums.UserRole
    action: string
    target: string
    companyId?: number | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type CalendarActionCreateWithoutCreatorInput = {
    title: string
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
    user: UserCreateNestedOneWithoutAssignedTasksInput
    company: CompanyCreateNestedOneWithoutTasksInput
  }

  export type CalendarActionUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    userId: number
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionCreateOrConnectWithoutCreatorInput = {
    where: CalendarActionWhereUniqueInput
    create: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput>
  }

  export type CalendarActionCreateManyCreatorInputEnvelope = {
    data: CalendarActionCreateManyCreatorInput | CalendarActionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CalendarActionUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarActionWhereUniqueInput
    update: XOR<CalendarActionUpdateWithoutUserInput, CalendarActionUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarActionCreateWithoutUserInput, CalendarActionUncheckedCreateWithoutUserInput>
  }

  export type CalendarActionUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarActionWhereUniqueInput
    data: XOR<CalendarActionUpdateWithoutUserInput, CalendarActionUncheckedUpdateWithoutUserInput>
  }

  export type CalendarActionUpdateManyWithWhereWithoutUserInput = {
    where: CalendarActionScalarWhereInput
    data: XOR<CalendarActionUpdateManyMutationInput, CalendarActionUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarActionScalarWhereInput = {
    AND?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
    OR?: CalendarActionScalarWhereInput[]
    NOT?: CalendarActionScalarWhereInput | CalendarActionScalarWhereInput[]
    id?: IntFilter<"CalendarAction"> | number
    title?: StringFilter<"CalendarAction"> | string
    userId?: IntFilter<"CalendarAction"> | number
    companyId?: IntFilter<"CalendarAction"> | number
    dueDate?: DateTimeFilter<"CalendarAction"> | Date | string
    notes?: StringNullableFilter<"CalendarAction"> | string | null
    status?: StringFilter<"CalendarAction"> | string
    createdBy?: IntNullableFilter<"CalendarAction"> | number | null
    createdByRole?: EnumUserRoleFilter<"CalendarAction"> | $Enums.UserRole
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    sentAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type CompanyUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUpdateManyWithWhereWithoutUserInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    companyId?: IntFilter<"Company"> | number
    companyName?: StringFilter<"Company"> | string
    registrationDate?: DateTimeFilter<"Company"> | Date | string
    addressLine1?: StringFilter<"Company"> | string
    addressLine2?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    postalCode?: StringFilter<"Company"> | string
    proposedShares?: IntFilter<"Company"> | number
    currency?: StringFilter<"Company"> | string
    proposedShareCapital?: DecimalFilter<"Company"> | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFilter<"Company"> | string
    businessActivity1Desc?: StringFilter<"Company"> | string
    businessActivity2?: StringFilter<"Company"> | string
    businessActivity2Desc?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    statusRemarks?: StringNullableFilter<"Company"> | string | null
    isDeleted?: BoolFilter<"Company"> | boolean
    userId?: IntFilter<"Company"> | number
    canEditC?: BoolFilter<"Company"> | boolean
    canEditD?: BoolFilter<"Company"> | boolean
    canEditS?: BoolFilter<"Company"> | boolean
  }

  export type InsightRecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: InsightRecommendationWhereUniqueInput
    update: XOR<InsightRecommendationUpdateWithoutUserInput, InsightRecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<InsightRecommendationCreateWithoutUserInput, InsightRecommendationUncheckedCreateWithoutUserInput>
  }

  export type InsightRecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: InsightRecommendationWhereUniqueInput
    data: XOR<InsightRecommendationUpdateWithoutUserInput, InsightRecommendationUncheckedUpdateWithoutUserInput>
  }

  export type InsightRecommendationUpdateManyWithWhereWithoutUserInput = {
    where: InsightRecommendationScalarWhereInput
    data: XOR<InsightRecommendationUpdateManyMutationInput, InsightRecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type InsightRecommendationScalarWhereInput = {
    AND?: InsightRecommendationScalarWhereInput | InsightRecommendationScalarWhereInput[]
    OR?: InsightRecommendationScalarWhereInput[]
    NOT?: InsightRecommendationScalarWhereInput | InsightRecommendationScalarWhereInput[]
    id?: IntFilter<"InsightRecommendation"> | number
    userId?: IntFilter<"InsightRecommendation"> | number
    content?: StringFilter<"InsightRecommendation"> | string
    sampleDocUrls?: StringNullableListFilter<"InsightRecommendation">
    createdAt?: DateTimeFilter<"InsightRecommendation"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    companyId?: IntNullableFilter<"Payment"> | number | null
    userId?: IntNullableFilter<"Payment"> | number | null
    stagingCompanyId?: StringNullableFilter<"Payment"> | string | null
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentReference?: StringFilter<"Payment"> | string
    services?: StringFilter<"Payment"> | string
  }

  export type RoleAssignmentUpsertWithWhereUniqueWithoutAgentInput = {
    where: RoleAssignmentWhereUniqueInput
    update: XOR<RoleAssignmentUpdateWithoutAgentInput, RoleAssignmentUncheckedUpdateWithoutAgentInput>
    create: XOR<RoleAssignmentCreateWithoutAgentInput, RoleAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type RoleAssignmentUpdateWithWhereUniqueWithoutAgentInput = {
    where: RoleAssignmentWhereUniqueInput
    data: XOR<RoleAssignmentUpdateWithoutAgentInput, RoleAssignmentUncheckedUpdateWithoutAgentInput>
  }

  export type RoleAssignmentUpdateManyWithWhereWithoutAgentInput = {
    where: RoleAssignmentScalarWhereInput
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyWithoutAgentInput>
  }

  export type RoleAssignmentScalarWhereInput = {
    AND?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
    OR?: RoleAssignmentScalarWhereInput[]
    NOT?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
    id?: IntFilter<"RoleAssignment"> | number
    agentId?: IntFilter<"RoleAssignment"> | number
    companyId?: IntFilter<"RoleAssignment"> | number
    role?: EnumUserRoleFilter<"RoleAssignment"> | $Enums.UserRole
    assignedAt?: DateTimeFilter<"RoleAssignment"> | Date | string
  }

  export type CompanyStatusMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: CompanyStatusMessageWhereUniqueInput
    update: XOR<CompanyStatusMessageUpdateWithoutSenderInput, CompanyStatusMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<CompanyStatusMessageCreateWithoutSenderInput, CompanyStatusMessageUncheckedCreateWithoutSenderInput>
  }

  export type CompanyStatusMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: CompanyStatusMessageWhereUniqueInput
    data: XOR<CompanyStatusMessageUpdateWithoutSenderInput, CompanyStatusMessageUncheckedUpdateWithoutSenderInput>
  }

  export type CompanyStatusMessageUpdateManyWithWhereWithoutSenderInput = {
    where: CompanyStatusMessageScalarWhereInput
    data: XOR<CompanyStatusMessageUpdateManyMutationInput, CompanyStatusMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type CompanyStatusMessageScalarWhereInput = {
    AND?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
    OR?: CompanyStatusMessageScalarWhereInput[]
    NOT?: CompanyStatusMessageScalarWhereInput | CompanyStatusMessageScalarWhereInput[]
    id?: IntFilter<"CompanyStatusMessage"> | number
    companyId?: IntFilter<"CompanyStatusMessage"> | number
    senderId?: IntFilter<"CompanyStatusMessage"> | number
    senderRole?: EnumUserRoleFilter<"CompanyStatusMessage"> | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFilter<"CompanyStatusMessage"> | $Enums.CompanyStatus
    message?: StringFilter<"CompanyStatusMessage"> | string
    createdAt?: DateTimeFilter<"CompanyStatusMessage"> | Date | string
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type CompanyDocumentScalarWhereInput = {
    AND?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    OR?: CompanyDocumentScalarWhereInput[]
    NOT?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    id?: IntFilter<"CompanyDocument"> | number
    companyId?: IntFilter<"CompanyDocument"> | number
    documentLabel?: StringFilter<"CompanyDocument"> | string
    documentPath?: StringFilter<"CompanyDocument"> | string
    documentType?: EnumDocumentTypeFilter<"CompanyDocument"> | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFilter<"CompanyDocument"> | $Enums.DocumentPurpose
    thumbnail?: StringNullableFilter<"CompanyDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CompanyDocument"> | Date | string
    isVerified?: BoolFilter<"CompanyDocument"> | boolean
    uploadedBy?: IntFilter<"CompanyDocument"> | number
    uploadedRole?: EnumUserRoleFilter<"CompanyDocument"> | $Enums.UserRole
    uploadedFor?: IntNullableFilter<"CompanyDocument"> | number | null
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutForUserInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutForUserInput, CompanyDocumentUncheckedUpdateWithoutForUserInput>
    create: XOR<CompanyDocumentCreateWithoutForUserInput, CompanyDocumentUncheckedCreateWithoutForUserInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutForUserInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutForUserInput, CompanyDocumentUncheckedUpdateWithoutForUserInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutForUserInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutForUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    actorId?: IntFilter<"AuditLog"> | number
    role?: EnumUserRoleFilter<"AuditLog"> | $Enums.UserRole
    action?: StringFilter<"AuditLog"> | string
    target?: StringFilter<"AuditLog"> | string
    companyId?: IntNullableFilter<"AuditLog"> | number | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CalendarActionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CalendarActionWhereUniqueInput
    update: XOR<CalendarActionUpdateWithoutCreatorInput, CalendarActionUncheckedUpdateWithoutCreatorInput>
    create: XOR<CalendarActionCreateWithoutCreatorInput, CalendarActionUncheckedCreateWithoutCreatorInput>
  }

  export type CalendarActionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CalendarActionWhereUniqueInput
    data: XOR<CalendarActionUpdateWithoutCreatorInput, CalendarActionUncheckedUpdateWithoutCreatorInput>
  }

  export type CalendarActionUpdateManyWithWhereWithoutCreatorInput = {
    where: CalendarActionScalarWhereInput
    data: XOR<CalendarActionUpdateManyMutationInput, CalendarActionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CalendarActionCreateWithoutCompanyInput = {
    title: string
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
    user: UserCreateNestedOneWithoutAssignedTasksInput
    creator?: UserCreateNestedOneWithoutCalendarActionInput
  }

  export type CalendarActionUncheckedCreateWithoutCompanyInput = {
    id?: number
    title: string
    userId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionCreateOrConnectWithoutCompanyInput = {
    where: CalendarActionWhereUniqueInput
    create: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput>
  }

  export type CalendarActionCreateManyCompanyInputEnvelope = {
    data: CalendarActionCreateManyCompanyInput | CalendarActionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompaniesInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyDocumentCreateWithoutCompanyInput = {
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    uploader: UserCreateNestedOneWithoutUploadedDocsInput
    forUser?: UserCreateNestedOneWithoutReceivedDocsInput
  }

  export type CompanyDocumentUncheckedCreateWithoutCompanyInput = {
    id?: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyDocumentCreateOrConnectWithoutCompanyInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyDocumentCreateManyCompanyInputEnvelope = {
    data: CompanyDocumentCreateManyCompanyInput | CompanyDocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyServiceCreateWithoutCompanyInput = {
    updateDate: Date | string
    service: ServiceCreateNestedOneWithoutCompanyServicesInput
  }

  export type CompanyServiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    serviceId: number
    updateDate: Date | string
  }

  export type CompanyServiceCreateOrConnectWithoutCompanyInput = {
    where: CompanyServiceWhereUniqueInput
    create: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyServiceCreateManyCompanyInputEnvelope = {
    data: CompanyServiceCreateManyCompanyInput | CompanyServiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DashboardStateCreateWithoutCompanyInput = {
    step: string
    completedAt?: Date | string | null
  }

  export type DashboardStateUncheckedCreateWithoutCompanyInput = {
    id?: number
    step: string
    completedAt?: Date | string | null
  }

  export type DashboardStateCreateOrConnectWithoutCompanyInput = {
    where: DashboardStateWhereUniqueInput
    create: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
  }

  export type DirectorCreateWithoutCompanyInput = {
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
  }

  export type DirectorUncheckedCreateWithoutCompanyInput = {
    id?: number
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
  }

  export type DirectorCreateOrConnectWithoutCompanyInput = {
    where: DirectorWhereUniqueInput
    create: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput>
  }

  export type DirectorCreateManyCompanyInputEnvelope = {
    data: DirectorCreateManyCompanyInput | DirectorCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCompanyInput = {
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    user?: UserCreateNestedOneWithoutPaymentsInput
    stagingCompany?: StagingCompanyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentCreateManyCompanyInputEnvelope = {
    data: PaymentCreateManyCompanyInput | PaymentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssignmentCreateWithoutCompanyInput = {
    role: $Enums.UserRole
    assignedAt?: Date | string
    agent: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type RoleAssignmentUncheckedCreateWithoutCompanyInput = {
    id?: number
    agentId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type RoleAssignmentCreateOrConnectWithoutCompanyInput = {
    where: RoleAssignmentWhereUniqueInput
    create: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput>
  }

  export type RoleAssignmentCreateManyCompanyInputEnvelope = {
    data: RoleAssignmentCreateManyCompanyInput | RoleAssignmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ShareholderCreateWithoutCompanyInput = {
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ShareholderUncheckedCreateWithoutCompanyInput = {
    id?: number
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ShareholderCreateOrConnectWithoutCompanyInput = {
    where: ShareholderWhereUniqueInput
    create: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput>
  }

  export type ShareholderCreateManyCompanyInputEnvelope = {
    data: ShareholderCreateManyCompanyInput | ShareholderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyStatusMessageCreateWithoutCompanyInput = {
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutRevertMessageInput
  }

  export type CompanyStatusMessageUncheckedCreateWithoutCompanyInput = {
    id?: number
    senderId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type CompanyStatusMessageCreateOrConnectWithoutCompanyInput = {
    where: CompanyStatusMessageWhereUniqueInput
    create: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyStatusMessageCreateManyCompanyInputEnvelope = {
    data: CompanyStatusMessageCreateManyCompanyInput | CompanyStatusMessageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    role: $Enums.UserRole
    action: string
    target: string
    timestamp?: Date | string
    actor: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: number
    actorId: number
    role: $Enums.UserRole
    action: string
    target: string
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CalendarActionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CalendarActionWhereUniqueInput
    update: XOR<CalendarActionUpdateWithoutCompanyInput, CalendarActionUncheckedUpdateWithoutCompanyInput>
    create: XOR<CalendarActionCreateWithoutCompanyInput, CalendarActionUncheckedCreateWithoutCompanyInput>
  }

  export type CalendarActionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CalendarActionWhereUniqueInput
    data: XOR<CalendarActionUpdateWithoutCompanyInput, CalendarActionUncheckedUpdateWithoutCompanyInput>
  }

  export type CalendarActionUpdateManyWithWhereWithoutCompanyInput = {
    where: CalendarActionScalarWhereInput
    data: XOR<CalendarActionUpdateManyMutationInput, CalendarActionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutCompanyInput, CompanyDocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyDocumentCreateWithoutCompanyInput, CompanyDocumentUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutCompanyInput, CompanyDocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyServiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyServiceWhereUniqueInput
    update: XOR<CompanyServiceUpdateWithoutCompanyInput, CompanyServiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyServiceCreateWithoutCompanyInput, CompanyServiceUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyServiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyServiceWhereUniqueInput
    data: XOR<CompanyServiceUpdateWithoutCompanyInput, CompanyServiceUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyServiceUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyServiceScalarWhereInput
    data: XOR<CompanyServiceUpdateManyMutationInput, CompanyServiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyServiceScalarWhereInput = {
    AND?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
    OR?: CompanyServiceScalarWhereInput[]
    NOT?: CompanyServiceScalarWhereInput | CompanyServiceScalarWhereInput[]
    id?: IntFilter<"CompanyService"> | number
    companyId?: IntFilter<"CompanyService"> | number
    serviceId?: IntFilter<"CompanyService"> | number
    updateDate?: DateTimeFilter<"CompanyService"> | Date | string
  }

  export type DashboardStateUpsertWithoutCompanyInput = {
    update: XOR<DashboardStateUpdateWithoutCompanyInput, DashboardStateUncheckedUpdateWithoutCompanyInput>
    create: XOR<DashboardStateCreateWithoutCompanyInput, DashboardStateUncheckedCreateWithoutCompanyInput>
    where?: DashboardStateWhereInput
  }

  export type DashboardStateUpdateToOneWithWhereWithoutCompanyInput = {
    where?: DashboardStateWhereInput
    data: XOR<DashboardStateUpdateWithoutCompanyInput, DashboardStateUncheckedUpdateWithoutCompanyInput>
  }

  export type DashboardStateUpdateWithoutCompanyInput = {
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardStateUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    step?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DirectorUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DirectorWhereUniqueInput
    update: XOR<DirectorUpdateWithoutCompanyInput, DirectorUncheckedUpdateWithoutCompanyInput>
    create: XOR<DirectorCreateWithoutCompanyInput, DirectorUncheckedCreateWithoutCompanyInput>
  }

  export type DirectorUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DirectorWhereUniqueInput
    data: XOR<DirectorUpdateWithoutCompanyInput, DirectorUncheckedUpdateWithoutCompanyInput>
  }

  export type DirectorUpdateManyWithWhereWithoutCompanyInput = {
    where: DirectorScalarWhereInput
    data: XOR<DirectorUpdateManyMutationInput, DirectorUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DirectorScalarWhereInput = {
    AND?: DirectorScalarWhereInput | DirectorScalarWhereInput[]
    OR?: DirectorScalarWhereInput[]
    NOT?: DirectorScalarWhereInput | DirectorScalarWhereInput[]
    id?: IntFilter<"Director"> | number
    companyId?: IntFilter<"Director"> | number
    directorName?: StringFilter<"Director"> | string
    email?: StringFilter<"Director"> | string
    addressLine1?: StringFilter<"Director"> | string
    addressLine2?: StringFilter<"Director"> | string
    country?: StringFilter<"Director"> | string
    postalCode?: StringFilter<"Director"> | string
    contactNumber?: StringFilter<"Director"> | string
    nationality?: StringFilter<"Director"> | string
    idType?: StringFilter<"Director"> | string
    idExpiryDate?: DateTimeFilter<"Director"> | Date | string
    idNumber?: StringFilter<"Director"> | string
    isShareholder?: BoolFilter<"Director"> | boolean
    identityProof?: StringFilter<"Director"> | string
    addressProof?: StringFilter<"Director"> | string
    dateOfBirth?: DateTimeFilter<"Director"> | Date | string
    createdAt?: DateTimeFilter<"Director"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
    create: XOR<PaymentCreateWithoutCompanyInput, PaymentUncheckedCreateWithoutCompanyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCompanyInput, PaymentUncheckedUpdateWithoutCompanyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCompanyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type RoleAssignmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: RoleAssignmentWhereUniqueInput
    update: XOR<RoleAssignmentUpdateWithoutCompanyInput, RoleAssignmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<RoleAssignmentCreateWithoutCompanyInput, RoleAssignmentUncheckedCreateWithoutCompanyInput>
  }

  export type RoleAssignmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: RoleAssignmentWhereUniqueInput
    data: XOR<RoleAssignmentUpdateWithoutCompanyInput, RoleAssignmentUncheckedUpdateWithoutCompanyInput>
  }

  export type RoleAssignmentUpdateManyWithWhereWithoutCompanyInput = {
    where: RoleAssignmentScalarWhereInput
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShareholderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShareholderWhereUniqueInput
    update: XOR<ShareholderUpdateWithoutCompanyInput, ShareholderUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShareholderCreateWithoutCompanyInput, ShareholderUncheckedCreateWithoutCompanyInput>
  }

  export type ShareholderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShareholderWhereUniqueInput
    data: XOR<ShareholderUpdateWithoutCompanyInput, ShareholderUncheckedUpdateWithoutCompanyInput>
  }

  export type ShareholderUpdateManyWithWhereWithoutCompanyInput = {
    where: ShareholderScalarWhereInput
    data: XOR<ShareholderUpdateManyMutationInput, ShareholderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShareholderScalarWhereInput = {
    AND?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
    OR?: ShareholderScalarWhereInput[]
    NOT?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
    id?: IntFilter<"Shareholder"> | number
    companyId?: IntFilter<"Shareholder"> | number
    shareholderName?: StringFilter<"Shareholder"> | string
    email?: StringFilter<"Shareholder"> | string
    type?: EnumShareholderTypeFilter<"Shareholder"> | $Enums.ShareholderType
    addressLine1?: StringFilter<"Shareholder"> | string
    addressLine2?: StringFilter<"Shareholder"> | string
    country?: StringFilter<"Shareholder"> | string
    postalCode?: StringFilter<"Shareholder"> | string
    contactNumber?: StringFilter<"Shareholder"> | string
    nationality?: StringFilter<"Shareholder"> | string
    idType?: StringFilter<"Shareholder"> | string
    idExpiryDate?: DateTimeFilter<"Shareholder"> | Date | string
    idNumber?: StringFilter<"Shareholder"> | string
    dateOfBirth?: DateTimeFilter<"Shareholder"> | Date | string
    numberOfShares?: IntFilter<"Shareholder"> | number
    shareCapitalAllocation?: DecimalFilter<"Shareholder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
  }

  export type CompanyStatusMessageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyStatusMessageWhereUniqueInput
    update: XOR<CompanyStatusMessageUpdateWithoutCompanyInput, CompanyStatusMessageUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyStatusMessageCreateWithoutCompanyInput, CompanyStatusMessageUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyStatusMessageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyStatusMessageWhereUniqueInput
    data: XOR<CompanyStatusMessageUpdateWithoutCompanyInput, CompanyStatusMessageUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyStatusMessageUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyStatusMessageScalarWhereInput
    data: XOR<CompanyStatusMessageUpdateManyMutationInput, CompanyStatusMessageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCreateWithoutRevertMessageInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRevertMessageInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRevertMessageInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRevertMessageInput, CompanyUncheckedCreateWithoutRevertMessageInput>
  }

  export type UserCreateWithoutRevertMessageInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRevertMessageInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRevertMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRevertMessageInput, UserUncheckedCreateWithoutRevertMessageInput>
  }

  export type CompanyUpsertWithoutRevertMessageInput = {
    update: XOR<CompanyUpdateWithoutRevertMessageInput, CompanyUncheckedUpdateWithoutRevertMessageInput>
    create: XOR<CompanyCreateWithoutRevertMessageInput, CompanyUncheckedCreateWithoutRevertMessageInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRevertMessageInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRevertMessageInput, CompanyUncheckedUpdateWithoutRevertMessageInput>
  }

  export type CompanyUpdateWithoutRevertMessageInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRevertMessageInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutRevertMessageInput = {
    update: XOR<UserUpdateWithoutRevertMessageInput, UserUncheckedUpdateWithoutRevertMessageInput>
    create: XOR<UserCreateWithoutRevertMessageInput, UserUncheckedCreateWithoutRevertMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRevertMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRevertMessageInput, UserUncheckedUpdateWithoutRevertMessageInput>
  }

  export type UserUpdateWithoutRevertMessageInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRevertMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyCreateWithoutDirectorsInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDirectorsInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDirectorsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDirectorsInput, CompanyUncheckedCreateWithoutDirectorsInput>
  }

  export type CompanyUpsertWithoutDirectorsInput = {
    update: XOR<CompanyUpdateWithoutDirectorsInput, CompanyUncheckedUpdateWithoutDirectorsInput>
    create: XOR<CompanyCreateWithoutDirectorsInput, CompanyUncheckedCreateWithoutDirectorsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDirectorsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDirectorsInput, CompanyUncheckedUpdateWithoutDirectorsInput>
  }

  export type CompanyUpdateWithoutDirectorsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDirectorsInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutShareholdersInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutShareholdersInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutShareholdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutShareholdersInput, CompanyUncheckedCreateWithoutShareholdersInput>
  }

  export type CompanyUpsertWithoutShareholdersInput = {
    update: XOR<CompanyUpdateWithoutShareholdersInput, CompanyUncheckedUpdateWithoutShareholdersInput>
    create: XOR<CompanyCreateWithoutShareholdersInput, CompanyUncheckedCreateWithoutShareholdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutShareholdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutShareholdersInput, CompanyUncheckedUpdateWithoutShareholdersInput>
  }

  export type CompanyUpdateWithoutShareholdersInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutShareholdersInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutDocumentsInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUploadedDocsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUploadedDocsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocsInput, UserUncheckedCreateWithoutUploadedDocsInput>
  }

  export type UserCreateWithoutReceivedDocsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReceivedDocsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReceivedDocsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedDocsInput, UserUncheckedCreateWithoutReceivedDocsInput>
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutUploadedDocsInput = {
    update: XOR<UserUpdateWithoutUploadedDocsInput, UserUncheckedUpdateWithoutUploadedDocsInput>
    create: XOR<UserCreateWithoutUploadedDocsInput, UserUncheckedCreateWithoutUploadedDocsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocsInput, UserUncheckedUpdateWithoutUploadedDocsInput>
  }

  export type UserUpdateWithoutUploadedDocsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutReceivedDocsInput = {
    update: XOR<UserUpdateWithoutReceivedDocsInput, UserUncheckedUpdateWithoutReceivedDocsInput>
    create: XOR<UserCreateWithoutReceivedDocsInput, UserUncheckedCreateWithoutReceivedDocsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedDocsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedDocsInput, UserUncheckedUpdateWithoutReceivedDocsInput>
  }

  export type UserUpdateWithoutReceivedDocsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RefundCreateWithoutPaymentInput = {
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: number
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutPaymentsInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPaymentsInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPaymentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type StagingCompanyCreateWithoutPaymentsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactNumber?: string | null
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step: number
    registrationDate?: Date | string | null
    directorData?: string | null
    shareholderData?: string | null
    servicesSelected?: string | null
    createdAt?: Date | string
    razorpayOrderId?: string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
  }

  export type StagingCompanyUncheckedCreateWithoutPaymentsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactNumber?: string | null
    isEmailVerified?: boolean
    isPaid?: boolean
    isCompleted?: boolean
    isRejected?: boolean
    step: number
    registrationDate?: Date | string | null
    directorData?: string | null
    shareholderData?: string | null
    servicesSelected?: string | null
    createdAt?: Date | string
    razorpayOrderId?: string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
  }

  export type StagingCompanyCreateOrConnectWithoutPaymentsInput = {
    where: StagingCompanyWhereUniqueInput
    create: XOR<StagingCompanyCreateWithoutPaymentsInput, StagingCompanyUncheckedCreateWithoutPaymentsInput>
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: IntFilter<"Refund"> | number
    paymentId?: IntFilter<"Refund"> | number
    refundId?: StringFilter<"Refund"> | string
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"Refund"> | Date | string
  }

  export type CompanyUpsertWithoutPaymentsInput = {
    update: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CompanyCreateWithoutPaymentsInput, CompanyUncheckedCreateWithoutPaymentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPaymentsInput, CompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type CompanyUpdateWithoutPaymentsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPaymentsInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type StagingCompanyUpsertWithoutPaymentsInput = {
    update: XOR<StagingCompanyUpdateWithoutPaymentsInput, StagingCompanyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StagingCompanyCreateWithoutPaymentsInput, StagingCompanyUncheckedCreateWithoutPaymentsInput>
    where?: StagingCompanyWhereInput
  }

  export type StagingCompanyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StagingCompanyWhereInput
    data: XOR<StagingCompanyUpdateWithoutPaymentsInput, StagingCompanyUncheckedUpdateWithoutPaymentsInput>
  }

  export type StagingCompanyUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StagingCompanyUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    step?: IntFieldUpdateOperationsInput | number
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directorData?: NullableStringFieldUpdateOperationsInput | string | null
    shareholderData?: NullableStringFieldUpdateOperationsInput | string | null
    servicesSelected?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateWithoutRefundsInput = {
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    company?: CompanyCreateNestedOneWithoutPaymentsInput
    user?: UserCreateNestedOneWithoutPaymentsInput
    stagingCompany?: StagingCompanyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: number
    companyId?: number | null
    userId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutPaymentsNestedInput
    user?: UserUpdateOneWithoutPaymentsNestedInput
    stagingCompany?: StagingCompanyUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyServiceCreateWithoutServiceInput = {
    updateDate: Date | string
    company: CompanyCreateNestedOneWithoutCompanyServicesInput
  }

  export type CompanyServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    companyId: number
    updateDate: Date | string
  }

  export type CompanyServiceCreateOrConnectWithoutServiceInput = {
    where: CompanyServiceWhereUniqueInput
    create: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput>
  }

  export type CompanyServiceCreateManyServiceInputEnvelope = {
    data: CompanyServiceCreateManyServiceInput | CompanyServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: CompanyServiceWhereUniqueInput
    update: XOR<CompanyServiceUpdateWithoutServiceInput, CompanyServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<CompanyServiceCreateWithoutServiceInput, CompanyServiceUncheckedCreateWithoutServiceInput>
  }

  export type CompanyServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: CompanyServiceWhereUniqueInput
    data: XOR<CompanyServiceUpdateWithoutServiceInput, CompanyServiceUncheckedUpdateWithoutServiceInput>
  }

  export type CompanyServiceUpdateManyWithWhereWithoutServiceInput = {
    where: CompanyServiceScalarWhereInput
    data: XOR<CompanyServiceUpdateManyMutationInput, CompanyServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type CompanyCreateWithoutCompanyServicesInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanyServicesInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanyServicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyServicesInput, CompanyUncheckedCreateWithoutCompanyServicesInput>
  }

  export type ServiceCreateWithoutCompanyServicesInput = {
    serviceName: string
    serviceDescription: string
    cost: Decimal | DecimalJsLike | number | string
    status: string
    createdAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutCompanyServicesInput = {
    id?: number
    serviceName: string
    serviceDescription: string
    cost: Decimal | DecimalJsLike | number | string
    status: string
    createdAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutCompanyServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCompanyServicesInput, ServiceUncheckedCreateWithoutCompanyServicesInput>
  }

  export type CompanyUpsertWithoutCompanyServicesInput = {
    update: XOR<CompanyUpdateWithoutCompanyServicesInput, CompanyUncheckedUpdateWithoutCompanyServicesInput>
    create: XOR<CompanyCreateWithoutCompanyServicesInput, CompanyUncheckedCreateWithoutCompanyServicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyServicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyServicesInput, CompanyUncheckedUpdateWithoutCompanyServicesInput>
  }

  export type CompanyUpdateWithoutCompanyServicesInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanyServicesInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ServiceUpsertWithoutCompanyServicesInput = {
    update: XOR<ServiceUpdateWithoutCompanyServicesInput, ServiceUncheckedUpdateWithoutCompanyServicesInput>
    create: XOR<ServiceCreateWithoutCompanyServicesInput, ServiceUncheckedCreateWithoutCompanyServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutCompanyServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutCompanyServicesInput, ServiceUncheckedUpdateWithoutCompanyServicesInput>
  }

  export type ServiceUpdateWithoutCompanyServicesInput = {
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutCompanyServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutInsightsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutInsightsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
  }

  export type UserUpsertWithoutInsightsInput = {
    update: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserUpdateWithoutInsightsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAssignedTasksInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type CompanyCreateWithoutTasksInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTasksInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTasksInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutCalendarActionInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCalendarActionInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCalendarActionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarActionInput, UserUncheckedCreateWithoutCalendarActionInput>
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutTasksInput = {
    update: XOR<CompanyUpdateWithoutTasksInput, CompanyUncheckedUpdateWithoutTasksInput>
    create: XOR<CompanyCreateWithoutTasksInput, CompanyUncheckedCreateWithoutTasksInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTasksInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTasksInput, CompanyUncheckedUpdateWithoutTasksInput>
  }

  export type CompanyUpdateWithoutTasksInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTasksInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCalendarActionInput = {
    update: XOR<UserUpdateWithoutCalendarActionInput, UserUncheckedUpdateWithoutCalendarActionInput>
    create: XOR<UserCreateWithoutCalendarActionInput, UserUncheckedCreateWithoutCalendarActionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarActionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarActionInput, UserUncheckedUpdateWithoutCalendarActionInput>
  }

  export type UserUpdateWithoutCalendarActionInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarActionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutMessagesReceivedInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMessagesReceivedInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMessagesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type UserCreateWithoutMessagesSentInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserUpsertWithoutMessagesReceivedInput = {
    update: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateWithoutMessagesReceivedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyCreateWithoutDashboardStateInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDashboardStateInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDashboardStateInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDashboardStateInput, CompanyUncheckedCreateWithoutDashboardStateInput>
  }

  export type CompanyUpsertWithoutDashboardStateInput = {
    update: XOR<CompanyUpdateWithoutDashboardStateInput, CompanyUncheckedUpdateWithoutDashboardStateInput>
    create: XOR<CompanyCreateWithoutDashboardStateInput, CompanyUncheckedCreateWithoutDashboardStateInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDashboardStateInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDashboardStateInput, CompanyUncheckedUpdateWithoutDashboardStateInput>
  }

  export type CompanyUpdateWithoutDashboardStateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDashboardStateInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutAssignedRolesInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAssignedRolesInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAssignedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
  }

  export type CompanyCreateWithoutRoleAssignmentsInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRoleAssignmentsInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRoleAssignmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRoleAssignmentsInput, CompanyUncheckedCreateWithoutRoleAssignmentsInput>
  }

  export type UserUpsertWithoutAssignedRolesInput = {
    update: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type UserUpdateWithoutAssignedRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutRoleAssignmentsInput = {
    update: XOR<CompanyUpdateWithoutRoleAssignmentsInput, CompanyUncheckedUpdateWithoutRoleAssignmentsInput>
    create: XOR<CompanyCreateWithoutRoleAssignmentsInput, CompanyUncheckedCreateWithoutRoleAssignmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRoleAssignmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRoleAssignmentsInput, CompanyUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type CompanyUpdateWithoutRoleAssignmentsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRoleAssignmentsInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PaymentCreateWithoutStagingCompanyInput = {
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    company?: CompanyCreateNestedOneWithoutPaymentsInput
    user?: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutStagingCompanyInput = {
    id?: number
    companyId?: number | null
    userId?: number | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutStagingCompanyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput>
  }

  export type PaymentCreateManyStagingCompanyInputEnvelope = {
    data: PaymentCreateManyStagingCompanyInput | PaymentCreateManyStagingCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutStagingCompanyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutStagingCompanyInput, PaymentUncheckedUpdateWithoutStagingCompanyInput>
    create: XOR<PaymentCreateWithoutStagingCompanyInput, PaymentUncheckedCreateWithoutStagingCompanyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutStagingCompanyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutStagingCompanyInput, PaymentUncheckedUpdateWithoutStagingCompanyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutStagingCompanyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutStagingCompanyInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageCreateNestedManyWithoutSenderInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentCreateNestedManyWithoutForUserInput
    CalendarAction?: CalendarActionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    username: string
    email: string
    password: string
    mobile: string
    country: string
    role: $Enums.UserRole
    profilePic?: string | null
    profileThumbnail?: string | null
    lastLogin?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    otp?: string | null
    otpExpires?: Date | string | null
    refreshToken?: string | null
    isVerified?: boolean
    isDeactivated?: boolean
    isDeleted?: boolean
    isSuspended?: boolean
    suspendMessage?: string
    createdAt?: Date | string
    assignedTasks?: CalendarActionUncheckedCreateNestedManyWithoutUserInput
    messagesReceived?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    messagesSent?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightRecommendationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: RoleAssignmentUncheckedCreateNestedManyWithoutAgentInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutSenderInput
    uploadedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    receivedDocs?: CompanyDocumentUncheckedCreateNestedManyWithoutForUserInput
    CalendarAction?: CalendarActionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionCreateNestedManyWithoutCompanyInput
    user: UserCreateNestedOneWithoutCompaniesInput
    documents?: CompanyDocumentCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateCreateNestedOneWithoutCompanyInput
    directors?: DirectorCreateNestedManyWithoutCompanyInput
    payments?: PaymentCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    userId: number
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
    tasks?: CalendarActionUncheckedCreateNestedManyWithoutCompanyInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutCompanyInput
    companyServices?: CompanyServiceUncheckedCreateNestedManyWithoutCompanyInput
    dashboardState?: DashboardStateUncheckedCreateNestedOneWithoutCompanyInput
    directors?: DirectorUncheckedCreateNestedManyWithoutCompanyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCompanyInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutCompanyInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutCompanyInput
    revertMessage?: CompanyStatusMessageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUpdateManyWithoutSenderNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUpdateManyWithoutForUserNestedInput
    CalendarAction?: CalendarActionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    profileThumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspendMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTasks?: CalendarActionUncheckedUpdateManyWithoutUserNestedInput
    messagesReceived?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    messagesSent?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: RoleAssignmentUncheckedUpdateManyWithoutAgentNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutSenderNestedInput
    uploadedDocs?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    receivedDocs?: CompanyDocumentUncheckedUpdateManyWithoutForUserNestedInput
    CalendarAction?: CalendarActionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CalendarActionCreateManyUserInput = {
    id?: number
    title: string
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type ChatMessageCreateManyReceiverInput = {
    id?: number
    senderId: number
    content: string
    sentAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: number
    receiverId: number
    content: string
    sentAt?: Date | string
  }

  export type CompanyCreateManyUserInput = {
    companyId?: number
    companyName: string
    registrationDate: Date | string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    proposedShares: number
    currency: string
    proposedShareCapital: Decimal | DecimalJsLike | number | string
    businessActivity1: string
    businessActivity1Desc: string
    businessActivity2: string
    businessActivity2Desc: string
    createdAt?: Date | string
    status?: $Enums.CompanyStatus
    statusRemarks?: string | null
    isDeleted?: boolean
    canEditC?: boolean
    canEditD?: boolean
    canEditS?: boolean
  }

  export type InsightRecommendationCreateManyUserInput = {
    id?: number
    content: string
    sampleDocUrls?: InsightRecommendationCreatesampleDocUrlsInput | string[]
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: number
    companyId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
  }

  export type RoleAssignmentCreateManyAgentInput = {
    id?: number
    companyId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type CompanyStatusMessageCreateManySenderInput = {
    id?: number
    companyId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type CompanyDocumentCreateManyUploaderInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyDocumentCreateManyForUserInput = {
    id?: number
    companyId: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
  }

  export type AuditLogCreateManyActorInput = {
    id?: number
    role: $Enums.UserRole
    action: string
    target: string
    companyId?: number | null
    timestamp?: Date | string
  }

  export type CalendarActionCreateManyCreatorInput = {
    id?: number
    title: string
    userId: number
    companyId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdByRole: $Enums.UserRole
  }

  export type CalendarActionUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    company?: CompanyUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutCalendarActionNestedInput
  }

  export type CalendarActionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type ChatMessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpdateWithoutUserInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
    tasks?: CalendarActionUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutCompanyNestedInput
    companyServices?: CompanyServiceUncheckedUpdateManyWithoutCompanyNestedInput
    dashboardState?: DashboardStateUncheckedUpdateOneWithoutCompanyNestedInput
    directors?: DirectorUncheckedUpdateManyWithoutCompanyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCompanyNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutCompanyNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    revertMessage?: CompanyStatusMessageUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutUserInput = {
    companyId?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    proposedShares?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    proposedShareCapital?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    businessActivity1?: StringFieldUpdateOperationsInput | string
    businessActivity1Desc?: StringFieldUpdateOperationsInput | string
    businessActivity2?: StringFieldUpdateOperationsInput | string
    businessActivity2Desc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    statusRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    canEditC?: BoolFieldUpdateOperationsInput | boolean
    canEditD?: BoolFieldUpdateOperationsInput | boolean
    canEditS?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InsightRecommendationUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightRecommendationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightRecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sampleDocUrls?: InsightRecommendationUpdatesampleDocUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    company?: CompanyUpdateOneWithoutPaymentsNestedInput
    stagingCompany?: StagingCompanyUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssignmentUpdateWithoutAgentInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageUpdateWithoutSenderInput = {
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutRevertMessageNestedInput
  }

  export type CompanyStatusMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUpdateWithoutUploaderInput = {
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    forUser?: UserUpdateOneWithoutReceivedDocsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyDocumentUpdateWithoutForUserInput = {
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateWithoutForUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutForUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type AuditLogUpdateWithoutActorInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarActionUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    user?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    company?: CompanyUpdateOneRequiredWithoutTasksNestedInput
  }

  export type CalendarActionUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionCreateManyCompanyInput = {
    id?: number
    title: string
    userId: number
    dueDate: Date | string
    notes?: string | null
    status?: string
    createdBy?: number | null
    createdByRole: $Enums.UserRole
  }

  export type CompanyDocumentCreateManyCompanyInput = {
    id?: number
    documentLabel: string
    documentPath: string
    documentType: $Enums.DocumentType
    purpose?: $Enums.DocumentPurpose
    thumbnail?: string | null
    uploadedAt?: Date | string
    isVerified?: boolean
    uploadedBy: number
    uploadedRole: $Enums.UserRole
    uploadedFor?: number | null
  }

  export type CompanyServiceCreateManyCompanyInput = {
    id?: number
    serviceId: number
    updateDate: Date | string
  }

  export type DirectorCreateManyCompanyInput = {
    id?: number
    directorName: string
    email: string
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    isShareholder: boolean
    identityProof: string
    addressProof: string
    dateOfBirth: Date | string
    createdAt?: Date | string
  }

  export type PaymentCreateManyCompanyInput = {
    id?: number
    userId?: number | null
    stagingCompanyId?: string | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
  }

  export type RoleAssignmentCreateManyCompanyInput = {
    id?: number
    agentId: number
    role: $Enums.UserRole
    assignedAt?: Date | string
  }

  export type ShareholderCreateManyCompanyInput = {
    id?: number
    shareholderName: string
    email: string
    type: $Enums.ShareholderType
    addressLine1: string
    addressLine2: string
    country: string
    postalCode: string
    contactNumber: string
    nationality: string
    idType: string
    idExpiryDate: Date | string
    idNumber: string
    dateOfBirth: Date | string
    numberOfShares: number
    shareCapitalAllocation: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CompanyStatusMessageCreateManyCompanyInput = {
    id?: number
    senderId: number
    senderRole: $Enums.UserRole
    fromStatus: $Enums.CompanyStatus
    toStatus: $Enums.CompanyStatus
    message: string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: number
    actorId: number
    role: $Enums.UserRole
    action: string
    target: string
    timestamp?: Date | string
  }

  export type CalendarActionUpdateWithoutCompanyInput = {
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    user?: UserUpdateOneRequiredWithoutAssignedTasksNestedInput
    creator?: UserUpdateOneWithoutCalendarActionNestedInput
  }

  export type CalendarActionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CalendarActionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdByRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type CompanyDocumentUpdateWithoutCompanyInput = {
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploader?: UserUpdateOneRequiredWithoutUploadedDocsNestedInput
    forUser?: UserUpdateOneWithoutReceivedDocsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentLabel?: StringFieldUpdateOperationsInput | string
    documentPath?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    purpose?: EnumDocumentPurposeFieldUpdateOperationsInput | $Enums.DocumentPurpose
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    uploadedFor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyServiceUpdateWithoutCompanyInput = {
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutCompanyServicesNestedInput
  }

  export type CompanyServiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorUpdateWithoutCompanyInput = {
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectorUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    directorName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    isShareholder?: BoolFieldUpdateOperationsInput | boolean
    identityProof?: StringFieldUpdateOperationsInput | string
    addressProof?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCompanyInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    user?: UserUpdateOneWithoutPaymentsNestedInput
    stagingCompany?: StagingCompanyUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    stagingCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }

  export type RoleAssignmentUpdateWithoutCompanyInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneRequiredWithoutAssignedRolesNestedInput
  }

  export type RoleAssignmentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUpdateWithoutCompanyInput = {
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareholderName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumShareholderTypeFieldUpdateOperationsInput | $Enums.ShareholderType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idNumber?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfShares?: IntFieldUpdateOperationsInput | number
    shareCapitalAllocation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageUpdateWithoutCompanyInput = {
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutRevertMessageNestedInput
  }

  export type CompanyStatusMessageUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyStatusMessageUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    fromStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    toStatus?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyPaymentInput = {
    id?: number
    refundId: string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
  }

  export type RefundUpdateWithoutPaymentInput = {
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    refundId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceCreateManyServiceInput = {
    id?: number
    companyId: number
    updateDate: Date | string
  }

  export type CompanyServiceUpdateWithoutServiceInput = {
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyServicesNestedInput
  }

  export type CompanyServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyStagingCompanyInput = {
    id?: number
    companyId?: number | null
    userId?: number | null
    paymentDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    paymentMethod: string
    paymentStatus?: $Enums.PaymentStatus
    paymentReference: string
    services: string
  }

  export type PaymentUpdateWithoutStagingCompanyInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    company?: CompanyUpdateOneWithoutPaymentsNestedInput
    user?: UserUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStagingCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutStagingCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentReference?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}